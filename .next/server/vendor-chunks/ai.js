"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AbstractChat: () => (/* binding */ AbstractChat),\n/* harmony export */   DefaultChatTransport: () => (/* binding */ DefaultChatTransport),\n/* harmony export */   DefaultGeneratedFile: () => (/* binding */ DefaultGeneratedFile),\n/* harmony export */   DirectChatTransport: () => (/* binding */ DirectChatTransport),\n/* harmony export */   DownloadError: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   Experimental_Agent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   HttpChatTransport: () => (/* binding */ HttpChatTransport),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidStreamPartError: () => (/* binding */ InvalidStreamPartError),\n/* harmony export */   InvalidToolApprovalError: () => (/* binding */ InvalidToolApprovalError),\n/* harmony export */   InvalidToolInputError: () => (/* binding */ InvalidToolInputError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   JsonToSseTransformStream: () => (/* binding */ JsonToSseTransformStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadSettingError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MissingToolResultsError: () => (/* binding */ MissingToolResultsError),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoImageGeneratedError: () => (/* binding */ NoImageGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoOutputGeneratedError: () => (/* binding */ NoOutputGeneratedError),\n/* harmony export */   NoSpeechGeneratedError: () => (/* binding */ NoSpeechGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   NoTranscriptGeneratedError: () => (/* binding */ NoTranscriptGeneratedError),\n/* harmony export */   NoVideoGeneratedError: () => (/* binding */ NoVideoGeneratedError),\n/* harmony export */   Output: () => (/* binding */ output_exports),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   SerialJobExecutor: () => (/* binding */ SerialJobExecutor),\n/* harmony export */   TextStreamChatTransport: () => (/* binding */ TextStreamChatTransport),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TooManyEmbeddingValuesForCallError),\n/* harmony export */   ToolCallNotFoundForApprovalError: () => (/* binding */ ToolCallNotFoundForApprovalError),\n/* harmony export */   ToolCallRepairError: () => (/* binding */ ToolCallRepairError),\n/* harmony export */   ToolLoopAgent: () => (/* binding */ ToolLoopAgent),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UIMessageStreamError: () => (/* binding */ UIMessageStreamError),\n/* harmony export */   UI_MESSAGE_STREAM_HEADERS: () => (/* binding */ UI_MESSAGE_STREAM_HEADERS),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedModelVersionError: () => (/* binding */ UnsupportedModelVersionError),\n/* harmony export */   addToolInputExamplesMiddleware: () => (/* binding */ addToolInputExamplesMiddleware),\n/* harmony export */   asSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema),\n/* harmony export */   assistantModelMessageSchema: () => (/* binding */ assistantModelMessageSchema),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   consumeStream: () => (/* binding */ consumeStream),\n/* harmony export */   convertFileListToFileUIParts: () => (/* binding */ convertFileListToFileUIParts),\n/* harmony export */   convertToModelMessages: () => (/* binding */ convertToModelMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createAgentUIStream: () => (/* binding */ createAgentUIStream),\n/* harmony export */   createAgentUIStreamResponse: () => (/* binding */ createAgentUIStreamResponse),\n/* harmony export */   createGateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.createGateway),\n/* harmony export */   createIdGenerator: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator),\n/* harmony export */   createProviderRegistry: () => (/* binding */ createProviderRegistry),\n/* harmony export */   createTextStreamResponse: () => (/* binding */ createTextStreamResponse),\n/* harmony export */   createUIMessageStream: () => (/* binding */ createUIMessageStream),\n/* harmony export */   createUIMessageStreamResponse: () => (/* binding */ createUIMessageStreamResponse),\n/* harmony export */   customProvider: () => (/* binding */ customProvider),\n/* harmony export */   defaultEmbeddingSettingsMiddleware: () => (/* binding */ defaultEmbeddingSettingsMiddleware),\n/* harmony export */   defaultSettingsMiddleware: () => (/* binding */ defaultSettingsMiddleware),\n/* harmony export */   dynamicTool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.dynamicTool),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateImage: () => (/* binding */ experimental_generateImage),\n/* harmony export */   experimental_generateSpeech: () => (/* binding */ generateSpeech),\n/* harmony export */   experimental_generateVideo: () => (/* binding */ experimental_generateVideo),\n/* harmony export */   experimental_transcribe: () => (/* binding */ transcribe),\n/* harmony export */   extractJsonMiddleware: () => (/* binding */ extractJsonMiddleware),\n/* harmony export */   extractReasoningMiddleware: () => (/* binding */ extractReasoningMiddleware),\n/* harmony export */   gateway: () => (/* reexport safe */ _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId),\n/* harmony export */   generateImage: () => (/* binding */ generateImage),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getStaticToolName: () => (/* binding */ getStaticToolName),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   getToolName: () => (/* binding */ getToolName),\n/* harmony export */   getToolOrDynamicToolName: () => (/* binding */ getToolOrDynamicToolName),\n/* harmony export */   hasToolCall: () => (/* binding */ hasToolCall),\n/* harmony export */   isDataUIPart: () => (/* binding */ isDataUIPart),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   isFileUIPart: () => (/* binding */ isFileUIPart),\n/* harmony export */   isReasoningUIPart: () => (/* binding */ isReasoningUIPart),\n/* harmony export */   isStaticToolUIPart: () => (/* binding */ isStaticToolUIPart),\n/* harmony export */   isTextUIPart: () => (/* binding */ isTextUIPart),\n/* harmony export */   isToolOrDynamicToolUIPart: () => (/* binding */ isToolOrDynamicToolUIPart),\n/* harmony export */   isToolUIPart: () => (/* binding */ isToolUIPart),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.jsonSchema),\n/* harmony export */   lastAssistantMessageIsCompleteWithApprovalResponses: () => (/* binding */ lastAssistantMessageIsCompleteWithApprovalResponses),\n/* harmony export */   lastAssistantMessageIsCompleteWithToolCalls: () => (/* binding */ lastAssistantMessageIsCompleteWithToolCalls),\n/* harmony export */   modelMessageSchema: () => (/* binding */ modelMessageSchema),\n/* harmony export */   parseJsonEventStream: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   pipeAgentUIStreamToResponse: () => (/* binding */ pipeAgentUIStreamToResponse),\n/* harmony export */   pipeTextStreamToResponse: () => (/* binding */ pipeTextStreamToResponse),\n/* harmony export */   pipeUIMessageStreamToResponse: () => (/* binding */ pipeUIMessageStreamToResponse),\n/* harmony export */   pruneMessages: () => (/* binding */ pruneMessages),\n/* harmony export */   readUIMessageStream: () => (/* binding */ readUIMessageStream),\n/* harmony export */   rerank: () => (/* binding */ rerank),\n/* harmony export */   safeValidateUIMessages: () => (/* binding */ safeValidateUIMessages),\n/* harmony export */   simulateReadableStream: () => (/* binding */ simulateReadableStream),\n/* harmony export */   simulateStreamingMiddleware: () => (/* binding */ simulateStreamingMiddleware),\n/* harmony export */   smoothStream: () => (/* binding */ smoothStream),\n/* harmony export */   stepCountIs: () => (/* binding */ stepCountIs),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   systemModelMessageSchema: () => (/* binding */ systemModelMessageSchema),\n/* harmony export */   tool: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.tool),\n/* harmony export */   toolModelMessageSchema: () => (/* binding */ toolModelMessageSchema),\n/* harmony export */   uiMessageChunkSchema: () => (/* binding */ uiMessageChunkSchema),\n/* harmony export */   userModelMessageSchema: () => (/* binding */ userModelMessageSchema),\n/* harmony export */   validateUIMessages: () => (/* binding */ validateUIMessages),\n/* harmony export */   wrapEmbeddingModel: () => (/* binding */ wrapEmbeddingModel),\n/* harmony export */   wrapImageModel: () => (/* binding */ wrapImageModel),\n/* harmony export */   wrapLanguageModel: () => (/* binding */ wrapLanguageModel),\n/* harmony export */   wrapProvider: () => (/* binding */ wrapProvider),\n/* harmony export */   zodSchema: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/gateway */ \"(ssr)/./node_modules/@ai-sdk/gateway/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod_v4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod/v4 */ \"(ssr)/./node_modules/zod/v4/index.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/trace-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/context-api.js\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @opentelemetry/api */ \"(ssr)/./node_modules/@opentelemetry/api/build/esm/trace/status.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name21 in all)\n    __defProp(target, name21, { get: all[name21], enumerable: true });\n};\n\n// src/index.ts\n\n\n\n// src/generate-text/generate-text.ts\n\n\n// src/error/index.ts\n\n\n// src/error/invalid-argument-error.ts\n\nvar name = \"AI_InvalidArgumentError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    parameter,\n    value,\n    message\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`\n    });\n    this[_a] = true;\n    this.parameter = parameter;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n  }\n};\n_a = symbol;\n\n// src/error/invalid-stream-part-error.ts\n\nvar name2 = \"AI_InvalidStreamPartError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidStreamPartError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunk,\n    message\n  }) {\n    super({ name: name2, message });\n    this[_a2] = true;\n    this.chunk = chunk;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n  }\n};\n_a2 = symbol2;\n\n// src/error/invalid-tool-approval-error.ts\n\nvar name3 = \"AI_InvalidToolApprovalError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidToolApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({ approvalId }) {\n    super({\n      name: name3,\n      message: `Tool approval response references unknown approvalId: \"${approvalId}\". No matching tool-approval-request found in message history.`\n    });\n    this[_a3] = true;\n    this.approvalId = approvalId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n  }\n};\n_a3 = symbol3;\n\n// src/error/invalid-tool-input-error.ts\n\nvar name4 = \"AI_InvalidToolInputError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidToolInputError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name4, message, cause });\n    this[_a4] = true;\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/error/tool-call-not-found-for-approval-error.ts\n\nvar name5 = \"AI_ToolCallNotFoundForApprovalError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar ToolCallNotFoundForApprovalError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolCallId,\n    approvalId\n  }) {\n    super({\n      name: name5,\n      message: `Tool call \"${toolCallId}\" not found for approval request \"${approvalId}\".`\n    });\n    this[_a5] = true;\n    this.toolCallId = toolCallId;\n    this.approvalId = approvalId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n  }\n};\n_a5 = symbol5;\n\n// src/error/missing-tool-result-error.ts\n\nvar name6 = \"AI_MissingToolResultsError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar MissingToolResultsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({ toolCallIds }) {\n    super({\n      name: name6,\n      message: `Tool result${toolCallIds.length > 1 ? \"s are\" : \" is\"} missing for tool call${toolCallIds.length > 1 ? \"s\" : \"\"} ${toolCallIds.join(\n        \", \"\n      )}.`\n    });\n    this[_a6] = true;\n    this.toolCallIds = toolCallIds;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n  }\n};\n_a6 = symbol6;\n\n// src/error/no-image-generated-error.ts\n\nvar name7 = \"AI_NoImageGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoImageGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No image generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name7, message, cause });\n    this[_a7] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n  }\n};\n_a7 = symbol7;\n\n// src/error/no-object-generated-error.ts\n\nvar name8 = \"AI_NoObjectGeneratedError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No object generated.\",\n    cause,\n    text: text2,\n    response,\n    usage,\n    finishReason\n  }) {\n    super({ name: name8, message, cause });\n    this[_a8] = true;\n    this.text = text2;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n  }\n};\n_a8 = symbol8;\n\n// src/error/no-output-generated-error.ts\n\nvar name9 = \"AI_NoOutputGeneratedError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoOutputGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No output generated.\",\n    cause\n  } = {}) {\n    super({ name: name9, message, cause });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n  }\n};\n_a9 = symbol9;\n\n// src/error/no-speech-generated-error.ts\n\nvar name10 = \"AI_NoSpeechGeneratedError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSpeechGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: name10,\n      message: \"No speech audio generated.\"\n    });\n    this[_a10] = true;\n    this.responses = options.responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n  }\n};\n_a10 = symbol10;\n\n// src/error/no-transcript-generated-error.ts\n\nvar name11 = \"AI_NoTranscriptGeneratedError\";\nvar marker11 = `vercel.ai.error.${name11}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoTranscriptGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: \"No transcript generated.\"\n    });\n    this[_a11] = true;\n    this.responses = options.responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker11);\n  }\n};\n_a11 = symbol11;\n\n// src/error/no-video-generated-error.ts\n\nvar name12 = \"AI_NoVideoGeneratedError\";\nvar marker12 = `vercel.ai.error.${name12}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar NoVideoGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message = \"No video generated.\",\n    cause,\n    responses\n  }) {\n    super({ name: name12, message, cause });\n    this[_a12] = true;\n    this.responses = responses;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoVideoGeneratedError(error) {\n    return error instanceof Error && error.name === name12 && typeof error.responses !== \"undefined\" ? true : false;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      cause: this.cause,\n      responses: this.responses\n    };\n  }\n};\n_a12 = symbol12;\n\n// src/error/no-such-tool-error.ts\n\nvar name13 = \"AI_NoSuchToolError\";\nvar marker13 = `vercel.ai.error.${name13}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    toolName,\n    availableTools = void 0,\n    message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}`\n  }) {\n    super({ name: name13, message });\n    this[_a13] = true;\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker13);\n  }\n};\n_a13 = symbol13;\n\n// src/error/tool-call-repair-error.ts\n\nvar name14 = \"AI_ToolCallRepairError\";\nvar marker14 = `vercel.ai.error.${name14}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar ToolCallRepairError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}`\n  }) {\n    super({ name: name14, message, cause });\n    this[_a14] = true;\n    this.originalError = originalError;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker14);\n  }\n};\n_a14 = symbol14;\n\n// src/error/unsupported-model-version-error.ts\n\nvar UnsupportedModelVersionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor(options) {\n    super({\n      name: \"AI_UnsupportedModelVersionError\",\n      message: `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". AI SDK 5 only supports models that implement specification version \"v2\".`\n    });\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n};\n\n// src/error/ui-message-stream-error.ts\n\nvar name15 = \"AI_UIMessageStreamError\";\nvar marker15 = `vercel.ai.error.${name15}`;\nvar symbol15 = Symbol.for(marker15);\nvar _a15;\nvar UIMessageStreamError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    chunkType,\n    chunkId,\n    message\n  }) {\n    super({ name: name15, message });\n    this[_a15] = true;\n    this.chunkType = chunkType;\n    this.chunkId = chunkId;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker15);\n  }\n};\n_a15 = symbol15;\n\n// src/prompt/invalid-data-content-error.ts\n\nvar name16 = \"AI_InvalidDataContentError\";\nvar marker16 = `vercel.ai.error.${name16}`;\nvar symbol16 = Symbol.for(marker16);\nvar _a16;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`\n  }) {\n    super({ name: name16, message, cause });\n    this[_a16] = true;\n    this.content = content;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker16);\n  }\n};\n_a16 = symbol16;\n\n// src/prompt/invalid-message-role-error.ts\n\nvar name17 = \"AI_InvalidMessageRoleError\";\nvar marker17 = `vercel.ai.error.${name17}`;\nvar symbol17 = Symbol.for(marker17);\nvar _a17;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`\n  }) {\n    super({ name: name17, message });\n    this[_a17] = true;\n    this.role = role;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker17);\n  }\n};\n_a17 = symbol17;\n\n// src/prompt/message-conversion-error.ts\n\nvar name18 = \"AI_MessageConversionError\";\nvar marker18 = `vercel.ai.error.${name18}`;\nvar symbol18 = Symbol.for(marker18);\nvar _a18;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    originalMessage,\n    message\n  }) {\n    super({ name: name18, message });\n    this[_a18] = true;\n    this.originalMessage = originalMessage;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker18);\n  }\n};\n_a18 = symbol18;\n\n// src/error/index.ts\n\n\n// src/util/retry-error.ts\n\nvar name19 = \"AI_RetryError\";\nvar marker19 = `vercel.ai.error.${name19}`;\nvar symbol19 = Symbol.for(marker19);\nvar _a19;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n  constructor({\n    message,\n    reason,\n    errors\n  }) {\n    super({ name: name19, message });\n    this[_a19] = true;\n    this.reason = reason;\n    this.errors = errors;\n    this.lastError = errors[errors.length - 1];\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker19);\n  }\n};\n_a19 = symbol19;\n\n// src/logger/log-warnings.ts\nfunction formatWarning({\n  warning,\n  provider,\n  model\n}) {\n  const prefix = `AI SDK Warning (${provider} / ${model}):`;\n  switch (warning.type) {\n    case \"unsupported\": {\n      let message = `${prefix} The feature \"${warning.feature}\" is not supported.`;\n      if (warning.details) {\n        message += ` ${warning.details}`;\n      }\n      return message;\n    }\n    case \"compatibility\": {\n      let message = `${prefix} The feature \"${warning.feature}\" is used in a compatibility mode.`;\n      if (warning.details) {\n        message += ` ${warning.details}`;\n      }\n      return message;\n    }\n    case \"other\": {\n      return `${prefix} ${warning.message}`;\n    }\n    default: {\n      return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n    }\n  }\n}\nvar FIRST_WARNING_INFO_MESSAGE = \"AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.\";\nvar hasLoggedBefore = false;\nvar logWarnings = (options) => {\n  if (options.warnings.length === 0) {\n    return;\n  }\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n  if (logger === false) {\n    return;\n  }\n  if (typeof logger === \"function\") {\n    logger(options);\n    return;\n  }\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n  for (const warning of options.warnings) {\n    console.warn(\n      formatWarning({\n        warning,\n        provider: options.provider,\n        model: options.model\n      })\n    );\n  }\n};\n\n// src/model/resolve-model.ts\n\n\n// src/util/log-v2-compatibility-warning.ts\nfunction logV2CompatibilityWarning({\n  provider,\n  modelId\n}) {\n  logWarnings({\n    warnings: [\n      {\n        type: \"compatibility\",\n        feature: \"specificationVersion\",\n        details: `Using v2 specification compatibility mode. Some features may not be available.`\n      }\n    ],\n    provider,\n    model: modelId\n  });\n}\n\n// src/model/as-embedding-model-v3.ts\nfunction asEmbeddingModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/as-image-model-v3.ts\nfunction asImageModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/as-language-model-v3.ts\nfunction asLanguageModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      switch (prop) {\n        case \"specificationVersion\":\n          return \"v3\";\n        case \"doGenerate\":\n          return async (...args) => {\n            const result = await target.doGenerate(...args);\n            return {\n              ...result,\n              finishReason: convertV2FinishReasonToV3(result.finishReason),\n              usage: convertV2UsageToV3(result.usage)\n            };\n          };\n        case \"doStream\":\n          return async (...args) => {\n            const result = await target.doStream(...args);\n            return {\n              ...result,\n              stream: convertV2StreamToV3(result.stream)\n            };\n          };\n        default:\n          return target[prop];\n      }\n    }\n  });\n}\nfunction convertV2StreamToV3(stream) {\n  return stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case \"finish\":\n            controller.enqueue({\n              ...chunk,\n              finishReason: convertV2FinishReasonToV3(chunk.finishReason),\n              usage: convertV2UsageToV3(chunk.usage)\n            });\n            break;\n          default:\n            controller.enqueue(chunk);\n            break;\n        }\n      }\n    })\n  );\n}\nfunction convertV2FinishReasonToV3(finishReason) {\n  return {\n    unified: finishReason === \"unknown\" ? \"other\" : finishReason,\n    raw: void 0\n  };\n}\nfunction convertV2UsageToV3(usage) {\n  return {\n    inputTokens: {\n      total: usage.inputTokens,\n      noCache: void 0,\n      cacheRead: usage.cachedInputTokens,\n      cacheWrite: void 0\n    },\n    outputTokens: {\n      total: usage.outputTokens,\n      text: void 0,\n      reasoning: usage.reasoningTokens\n    }\n  };\n}\n\n// src/model/as-speech-model-v3.ts\nfunction asSpeechModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/as-transcription-model-v3.ts\nfunction asTranscriptionModelV3(model) {\n  if (model.specificationVersion === \"v3\") {\n    return model;\n  }\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId\n  });\n  return new Proxy(model, {\n    get(target, prop) {\n      if (prop === \"specificationVersion\")\n        return \"v3\";\n      return target[prop];\n    }\n  });\n}\n\n// src/model/resolve-model.ts\nfunction resolveLanguageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asLanguageModelV3(model);\n  }\n  return getGlobalProvider().languageModel(model);\n}\nfunction resolveEmbeddingModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asEmbeddingModelV3(model);\n  }\n  return getGlobalProvider().embeddingModel(model);\n}\nfunction resolveTranscriptionModel(model) {\n  var _a21, _b;\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asTranscriptionModelV3(model);\n  }\n  return (_b = (_a21 = getGlobalProvider()).transcriptionModel) == null ? void 0 : _b.call(_a21, model);\n}\nfunction resolveSpeechModel(model) {\n  var _a21, _b;\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asSpeechModelV3(model);\n  }\n  return (_b = (_a21 = getGlobalProvider()).speechModel) == null ? void 0 : _b.call(_a21, model);\n}\nfunction resolveImageModel(model) {\n  if (typeof model !== \"string\") {\n    if (model.specificationVersion !== \"v3\" && model.specificationVersion !== \"v2\") {\n      const unsupportedModel = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId\n      });\n    }\n    return asImageModelV3(model);\n  }\n  return getGlobalProvider().imageModel(model);\n}\nfunction resolveVideoModel(model) {\n  if (typeof model === \"string\") {\n    throw new Error(\n      'Video models cannot be resolved from strings. Please use a Experimental_VideoModelV3 object from a provider (e.g., fal.video(\"model-id\")).'\n    );\n  }\n  if (model.specificationVersion !== \"v3\") {\n    const unsupportedModel = model;\n    throw new UnsupportedModelVersionError({\n      version: unsupportedModel.specificationVersion,\n      provider: unsupportedModel.provider,\n      modelId: unsupportedModel.modelId\n    });\n  }\n  return model;\n}\nfunction getGlobalProvider() {\n  var _a21;\n  return (_a21 = globalThis.AI_SDK_DEFAULT_PROVIDER) != null ? _a21 : _ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.gateway;\n}\n\n// src/prompt/call-settings.ts\nfunction getTotalTimeoutMs(timeout) {\n  if (timeout == null) {\n    return void 0;\n  }\n  if (typeof timeout === \"number\") {\n    return timeout;\n  }\n  return timeout.totalMs;\n}\nfunction getStepTimeoutMs(timeout) {\n  if (timeout == null || typeof timeout === \"number\") {\n    return void 0;\n  }\n  return timeout.stepMs;\n}\nfunction getChunkTimeoutMs(timeout) {\n  if (timeout == null || typeof timeout === \"number\") {\n    return void 0;\n  }\n  return timeout.chunkMs;\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\n\n\n// src/util/detect-media-type.ts\n\nvar imageMediaTypeSignatures = [\n  {\n    mediaType: \"image/gif\",\n    bytesPrefix: [71, 73, 70]\n    // GIF\n  },\n  {\n    mediaType: \"image/png\",\n    bytesPrefix: [137, 80, 78, 71]\n    // PNG\n  },\n  {\n    mediaType: \"image/jpeg\",\n    bytesPrefix: [255, 216]\n    // JPEG\n  },\n  {\n    mediaType: \"image/webp\",\n    bytesPrefix: [\n      82,\n      73,\n      70,\n      70,\n      // \"RIFF\"\n      null,\n      null,\n      null,\n      null,\n      // file size (variable)\n      87,\n      69,\n      66,\n      80\n      // \"WEBP\"\n    ]\n  },\n  {\n    mediaType: \"image/bmp\",\n    bytesPrefix: [66, 77]\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [73, 73, 42, 0]\n  },\n  {\n    mediaType: \"image/tiff\",\n    bytesPrefix: [77, 77, 0, 42]\n  },\n  {\n    mediaType: \"image/avif\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      97,\n      118,\n      105,\n      102\n    ]\n  },\n  {\n    mediaType: \"image/heic\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      32,\n      102,\n      116,\n      121,\n      112,\n      104,\n      101,\n      105,\n      99\n    ]\n  }\n];\nvar audioMediaTypeSignatures = [\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 251]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 250]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 243]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 242]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 227]\n  },\n  {\n    mediaType: \"audio/mpeg\",\n    bytesPrefix: [255, 226]\n  },\n  {\n    mediaType: \"audio/wav\",\n    bytesPrefix: [\n      82,\n      // R\n      73,\n      // I\n      70,\n      // F\n      70,\n      // F\n      null,\n      null,\n      null,\n      null,\n      87,\n      // W\n      65,\n      // A\n      86,\n      // V\n      69\n      // E\n    ]\n  },\n  {\n    mediaType: \"audio/ogg\",\n    bytesPrefix: [79, 103, 103, 83]\n  },\n  {\n    mediaType: \"audio/flac\",\n    bytesPrefix: [102, 76, 97, 67]\n  },\n  {\n    mediaType: \"audio/aac\",\n    bytesPrefix: [64, 21, 0, 0]\n  },\n  {\n    mediaType: \"audio/mp4\",\n    bytesPrefix: [102, 116, 121, 112]\n  },\n  {\n    mediaType: \"audio/webm\",\n    bytesPrefix: [26, 69, 223, 163]\n  }\n];\nvar videoMediaTypeSignatures = [\n  {\n    mediaType: \"video/mp4\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      null,\n      102,\n      116,\n      121,\n      112\n      // ftyp\n    ]\n  },\n  {\n    mediaType: \"video/webm\",\n    bytesPrefix: [26, 69, 223, 163]\n    // EBML\n  },\n  {\n    mediaType: \"video/quicktime\",\n    bytesPrefix: [\n      0,\n      0,\n      0,\n      20,\n      102,\n      116,\n      121,\n      112,\n      113,\n      116\n      // ftypqt\n    ]\n  },\n  {\n    mediaType: \"video/x-msvideo\",\n    bytesPrefix: [82, 73, 70, 70]\n    // RIFF (AVI)\n  }\n];\nvar stripID3 = (data) => {\n  const bytes = typeof data === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(data) : data;\n  const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;\n  return bytes.slice(id3Size + 10);\n};\nfunction stripID3TagsIfPresent(data) {\n  const hasId3 = typeof data === \"string\" && data.startsWith(\"SUQz\") || typeof data !== \"string\" && data.length > 10 && data[0] === 73 && // 'I'\n  data[1] === 68 && // 'D'\n  data[2] === 51;\n  return hasId3 ? stripID3(data) : data;\n}\nfunction detectMediaType({\n  data,\n  signatures\n}) {\n  const processedData = stripID3TagsIfPresent(data);\n  const bytes = typeof processedData === \"string\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(\n    processedData.substring(0, Math.min(processedData.length, 24))\n  ) : processedData;\n  for (const signature of signatures) {\n    if (bytes.length >= signature.bytesPrefix.length && signature.bytesPrefix.every(\n      (byte, index) => byte === null || bytes[index] === byte\n    )) {\n      return signature.mediaType;\n    }\n  }\n  return void 0;\n}\n\n// src/util/download/download.ts\n\n\n\n// src/version.ts\nvar VERSION =  true ? \"6.0.68\" : 0;\n\n// src/util/download/download.ts\nvar download = async ({ url }) => {\n  var _a21;\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText, {\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        {},\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      )\n    });\n    if (!response.ok) {\n      throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText\n      });\n    }\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: (_a21 = response.headers.get(\"content-type\")) != null ? _a21 : void 0\n    };\n  } catch (error) {\n    if (_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError.isInstance(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DownloadError({ url: urlText, cause: error });\n  }\n};\n\n// src/util/download/download-function.ts\nvar createDefaultDownloadFunction = (download2 = download) => (requestedDownloads) => Promise.all(\n  requestedDownloads.map(\n    async (requestedDownload) => requestedDownload.isUrlSupportedByModel ? null : download2(requestedDownload)\n  )\n);\n\n// src/prompt/data-content.ts\n\n\n\n\n// src/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n  try {\n    const [header, base64Content] = dataUrl.split(\",\");\n    return {\n      mediaType: header.split(\";\")[0].split(\":\")[1],\n      base64Content\n    };\n  } catch (error) {\n    return {\n      mediaType: void 0,\n      base64Content: void 0\n    };\n  }\n}\n\n// src/prompt/data-content.ts\nvar dataContentSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"instanceof\"](Uint8Array),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"instanceof\"](ArrayBuffer),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.custom(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value) => {\n      var _a21, _b;\n      return (_b = (_a21 = globalThis.Buffer) == null ? void 0 : _a21.isBuffer(value)) != null ? _b : false;\n    },\n    { message: \"Must be a Buffer\" }\n  )\n]);\nfunction convertToLanguageModelV3DataContent(content) {\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: void 0 };\n  }\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: void 0 };\n  }\n  if (typeof content === \"string\") {\n    try {\n      content = new URL(content);\n    } catch (error) {\n    }\n  }\n  if (content instanceof URL && content.protocol === \"data:\") {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString()\n    );\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n        name: \"InvalidDataContentError\",\n        message: `Invalid data URL format in content ${content.toString()}`\n      });\n    }\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n  return { data: content, mediaType: void 0 };\n}\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    try {\n      return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message: \"Invalid data content. Content string is not a base64-encoded media.\",\n        content,\n        cause: error\n      });\n    }\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new InvalidDataContentError({ content });\n}\n\n// src/util/as-array.ts\nfunction asArray(value) {\n  return value === void 0 ? [] : Array.isArray(value) ? value : [value];\n}\n\n// src/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download: download2 = createDefaultDownloadFunction()\n}) {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download2,\n    supportedUrls\n  );\n  const approvalIdToToolCallId = /* @__PURE__ */ new Map();\n  for (const message of prompt.messages) {\n    if (message.role === \"assistant\" && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        if (part.type === \"tool-approval-request\" && \"approvalId\" in part && \"toolCallId\" in part) {\n          approvalIdToToolCallId.set(\n            part.approvalId,\n            part.toolCallId\n          );\n        }\n      }\n    }\n  }\n  const approvedToolCallIds = /* @__PURE__ */ new Set();\n  for (const message of prompt.messages) {\n    if (message.role === \"tool\") {\n      for (const part of message.content) {\n        if (part.type === \"tool-approval-response\") {\n          const toolCallId = approvalIdToToolCallId.get(part.approvalId);\n          if (toolCallId) {\n            approvedToolCallIds.add(toolCallId);\n          }\n        }\n      }\n    }\n  }\n  const messages = [\n    ...prompt.system != null ? typeof prompt.system === \"string\" ? [{ role: \"system\", content: prompt.system }] : asArray(prompt.system).map((message) => ({\n      role: \"system\",\n      content: message.content,\n      providerOptions: message.providerOptions\n    })) : [],\n    ...prompt.messages.map(\n      (message) => convertToLanguageModelMessage({ message, downloadedAssets })\n    )\n  ];\n  const combinedMessages = [];\n  for (const message of messages) {\n    if (message.role !== \"tool\") {\n      combinedMessages.push(message);\n      continue;\n    }\n    const lastCombinedMessage = combinedMessages.at(-1);\n    if ((lastCombinedMessage == null ? void 0 : lastCombinedMessage.role) === \"tool\") {\n      lastCombinedMessage.content.push(...message.content);\n    } else {\n      combinedMessages.push(message);\n    }\n  }\n  const toolCallIds = /* @__PURE__ */ new Set();\n  for (const message of combinedMessages) {\n    switch (message.role) {\n      case \"assistant\": {\n        for (const content of message.content) {\n          if (content.type === \"tool-call\" && !content.providerExecuted) {\n            toolCallIds.add(content.toolCallId);\n          }\n        }\n        break;\n      }\n      case \"tool\": {\n        for (const content of message.content) {\n          if (content.type === \"tool-result\") {\n            toolCallIds.delete(content.toolCallId);\n          }\n        }\n        break;\n      }\n      case \"user\":\n      case \"system\":\n        for (const id of approvedToolCallIds) {\n          toolCallIds.delete(id);\n        }\n        if (toolCallIds.size > 0) {\n          throw new MissingToolResultsError({\n            toolCallIds: Array.from(toolCallIds)\n          });\n        }\n        break;\n    }\n  }\n  for (const id of approvedToolCallIds) {\n    toolCallIds.delete(id);\n  }\n  if (toolCallIds.size > 0) {\n    throw new MissingToolResultsError({ toolCallIds: Array.from(toolCallIds) });\n  }\n  return combinedMessages.filter(\n    // Filter out empty tool messages (e.g. if they only contained\n    // tool-approval-response parts that were removed).\n    // This prevents sending invalid empty messages to the provider.\n    // Note: provider-executed tool-approval-response parts are preserved.\n    (message) => message.role !== \"tool\" || message.content.length > 0\n  );\n}\nfunction convertToLanguageModelMessage({\n  message,\n  downloadedAssets\n}) {\n  const role = message.role;\n  switch (role) {\n    case \"system\": {\n      return {\n        role: \"system\",\n        content: message.content,\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"user\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"user\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"user\",\n        content: message.content.map((part) => convertPartToLanguageModelPart(part, downloadedAssets)).filter((part) => part.type !== \"text\" || part.text !== \"\"),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"assistant\": {\n      if (typeof message.content === \"string\") {\n        return {\n          role: \"assistant\",\n          content: [{ type: \"text\", text: message.content }],\n          providerOptions: message.providerOptions\n        };\n      }\n      return {\n        role: \"assistant\",\n        content: message.content.filter(\n          // remove empty text parts (no text, and no provider options):\n          (part) => part.type !== \"text\" || part.text !== \"\" || part.providerOptions != null\n        ).filter(\n          (part) => part.type !== \"tool-approval-request\"\n        ).map((part) => {\n          const providerOptions = part.providerOptions;\n          switch (part.type) {\n            case \"file\": {\n              const { data, mediaType } = convertToLanguageModelV3DataContent(\n                part.data\n              );\n              return {\n                type: \"file\",\n                data,\n                filename: part.filename,\n                mediaType: mediaType != null ? mediaType : part.mediaType,\n                providerOptions\n              };\n            }\n            case \"reasoning\": {\n              return {\n                type: \"reasoning\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"text\": {\n              return {\n                type: \"text\",\n                text: part.text,\n                providerOptions\n              };\n            }\n            case \"tool-call\": {\n              return {\n                type: \"tool-call\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                input: part.input,\n                providerExecuted: part.providerExecuted,\n                providerOptions\n              };\n            }\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: mapToolResultOutput(part.output),\n                providerOptions\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    case \"tool\": {\n      return {\n        role: \"tool\",\n        content: message.content.filter(\n          // Only include tool-approval-response for provider-executed tools\n          (part) => part.type !== \"tool-approval-response\" || part.providerExecuted\n        ).map((part) => {\n          switch (part.type) {\n            case \"tool-result\": {\n              return {\n                type: \"tool-result\",\n                toolCallId: part.toolCallId,\n                toolName: part.toolName,\n                output: mapToolResultOutput(part.output),\n                providerOptions: part.providerOptions\n              };\n            }\n            case \"tool-approval-response\": {\n              return {\n                type: \"tool-approval-response\",\n                approvalId: part.approvalId,\n                approved: part.approved,\n                reason: part.reason\n              };\n            }\n          }\n        }),\n        providerOptions: message.providerOptions\n      };\n    }\n    default: {\n      const _exhaustiveCheck = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\nasync function downloadAssets(messages, download2, supportedUrls) {\n  const plannedDownloads = messages.filter((message) => message.role === \"user\").map((message) => message.content).filter(\n    (content) => Array.isArray(content)\n  ).flat().filter(\n    (part) => part.type === \"image\" || part.type === \"file\"\n  ).map((part) => {\n    var _a21;\n    const mediaType = (_a21 = part.mediaType) != null ? _a21 : part.type === \"image\" ? \"image/*\" : void 0;\n    let data = part.type === \"image\" ? part.image : part.data;\n    if (typeof data === \"string\") {\n      try {\n        data = new URL(data);\n      } catch (ignored) {\n      }\n    }\n    return { mediaType, data };\n  }).filter(\n    (part) => part.data instanceof URL\n  ).map((part) => ({\n    url: part.data,\n    isUrlSupportedByModel: part.mediaType != null && (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isUrlSupported)({\n      url: part.data.toString(),\n      mediaType: part.mediaType,\n      supportedUrls\n    })\n  }));\n  const downloadedFiles = await download2(plannedDownloads);\n  return Object.fromEntries(\n    downloadedFiles.map(\n      (file, index) => file == null ? null : [\n        plannedDownloads[index].url.toString(),\n        { data: file.data, mediaType: file.mediaType }\n      ]\n    ).filter((file) => file != null)\n  );\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n  var _a21;\n  if (part.type === \"text\") {\n    return {\n      type: \"text\",\n      text: part.text,\n      providerOptions: part.providerOptions\n    };\n  }\n  let originalData;\n  const type = part.type;\n  switch (type) {\n    case \"image\":\n      originalData = part.image;\n      break;\n    case \"file\":\n      originalData = part.data;\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n  const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV3DataContent(originalData);\n  let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;\n  let data = convertedData;\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType != null ? mediaType : mediaType = downloadedFile.mediaType;\n    }\n  }\n  switch (type) {\n    case \"image\": {\n      if (data instanceof Uint8Array || typeof data === \"string\") {\n        mediaType = (_a21 = detectMediaType({ data, signatures: imageMediaTypeSignatures })) != null ? _a21 : mediaType;\n      }\n      return {\n        type: \"file\",\n        mediaType: mediaType != null ? mediaType : \"image/*\",\n        // any image\n        filename: void 0,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n    case \"file\": {\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n      return {\n        type: \"file\",\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions\n      };\n    }\n  }\n}\nfunction mapToolResultOutput(output) {\n  if (output.type !== \"content\") {\n    return output;\n  }\n  return {\n    type: \"content\",\n    value: output.value.map((item) => {\n      if (item.type !== \"media\") {\n        return item;\n      }\n      if (item.mediaType.startsWith(\"image/\")) {\n        return {\n          type: \"image-data\",\n          data: item.data,\n          mediaType: item.mediaType\n        };\n      }\n      return {\n        type: \"file-data\",\n        data: item.data,\n        mediaType: item.mediaType\n      };\n    })\n  };\n}\n\n// src/prompt/create-tool-model-output.ts\n\nasync function createToolModelOutput({\n  toolCallId,\n  input,\n  output,\n  tool: tool2,\n  errorMode\n}) {\n  if (errorMode === \"text\") {\n    return { type: \"error-text\", value: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(output) };\n  } else if (errorMode === \"json\") {\n    return { type: \"error-json\", value: toJSONValue(output) };\n  }\n  if (tool2 == null ? void 0 : tool2.toModelOutput) {\n    return await tool2.toModelOutput({ toolCallId, input, output });\n  }\n  return typeof output === \"string\" ? { type: \"text\", value: output } : { type: \"json\", value: toJSONValue(output) };\n}\nfunction toJSONValue(value) {\n  return value === void 0 ? null : value;\n}\n\n// src/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences\n}) {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be an integer\"\n      });\n    }\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: \"maxOutputTokens\",\n        value: maxOutputTokens,\n        message: \"maxOutputTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (topK != null) {\n    if (typeof topK !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"topK\",\n        value: topK,\n        message: \"topK must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed\n  };\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\n\n\n// src/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object2) {\n  return object2 != null && Object.keys(object2).length > 0;\n}\n\n// src/prompt/prepare-tools-and-tool-choice.ts\nasync function prepareToolsAndToolChoice({\n  tools,\n  toolChoice,\n  activeTools\n}) {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: void 0,\n      toolChoice: void 0\n    };\n  }\n  const filteredTools = activeTools != null ? Object.entries(tools).filter(\n    ([name21]) => activeTools.includes(name21)\n  ) : Object.entries(tools);\n  const languageModelTools = [];\n  for (const [name21, tool2] of filteredTools) {\n    const toolType = tool2.type;\n    switch (toolType) {\n      case void 0:\n      case \"dynamic\":\n      case \"function\":\n        languageModelTools.push({\n          type: \"function\",\n          name: name21,\n          description: tool2.description,\n          inputSchema: await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema).jsonSchema,\n          ...tool2.inputExamples != null ? { inputExamples: tool2.inputExamples } : {},\n          providerOptions: tool2.providerOptions,\n          ...tool2.strict != null ? { strict: tool2.strict } : {}\n        });\n        break;\n      case \"provider\":\n        languageModelTools.push({\n          type: \"provider\",\n          name: name21,\n          id: tool2.id,\n          args: tool2.args\n        });\n        break;\n      default: {\n        const exhaustiveCheck = toolType;\n        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n      }\n    }\n  }\n  return {\n    tools: languageModelTools,\n    toolChoice: toolChoice == null ? { type: \"auto\" } : typeof toolChoice === \"string\" ? { type: toolChoice } : { type: \"tool\", toolName: toolChoice.toolName }\n  };\n}\n\n// src/prompt/standardize-prompt.ts\n\n\n\n\n// src/prompt/message.ts\n\n\n// src/types/provider-metadata.ts\n\n\n// src/types/json-value.ts\n\nvar jsonValueSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.lazy(\n  () => zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"null\"](),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.number(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema.optional()),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(jsonValueSchema)\n  ])\n);\n\n// src/types/provider-metadata.ts\nvar providerMetadataSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema.optional())\n);\n\n// src/prompt/content-part.ts\n\nvar textPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image\"),\n  image: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"instanceof\"](URL)]),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n  data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([dataContentSchema, zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"instanceof\"](URL)]),\n  filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n  mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar reasoningPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning\"),\n  text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-call\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n});\nvar outputSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.discriminatedUnion(\n  \"type\",\n  [\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n      value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"json\"),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"execution-denied\"),\n      reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"error-text\"),\n      value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"error-json\"),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional()\n    }),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n      type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"content\"),\n      value: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(\n        zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n            text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"media\"),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file-data\"),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file-url\"),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file-id\"),\n            fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string())]),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image-data\"),\n            data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image-url\"),\n            url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image-file-id\"),\n            fileId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.record(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string())]),\n            providerOptions: providerMetadataSchema.optional()\n          }),\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n            type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"custom\"),\n            providerOptions: providerMetadataSchema.optional()\n          })\n        ])\n      )\n    })\n  ]\n);\nvar toolResultPartSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-result\"),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolApprovalRequestSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-approval-request\"),\n  approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n});\nvar toolApprovalResponseSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-approval-response\"),\n  approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n  approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n  reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n});\n\n// src/prompt/message.ts\nvar systemModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object(\n  {\n    role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"system\"),\n    content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    providerOptions: providerMetadataSchema.optional()\n  }\n);\nvar userModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"user\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([textPartSchema, imagePartSchema, filePartSchema]))\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar assistantModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"assistant\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        textPartSchema,\n        filePartSchema,\n        reasoningPartSchema,\n        toolCallPartSchema,\n        toolResultPartSchema,\n        toolApprovalRequestSchema\n      ])\n    )\n  ]),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar toolModelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n  role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool\"),\n  content: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([toolResultPartSchema, toolApprovalResponseSchema])),\n  providerOptions: providerMetadataSchema.optional()\n});\nvar modelMessageSchema = zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema\n]);\n\n// src/prompt/standardize-prompt.ts\nasync function standardizePrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  if (prompt.system != null && typeof prompt.system !== \"string\" && !asArray(prompt.system).every(\n    (message) => typeof message === \"object\" && message !== null && \"role\" in message && message.role === \"system\"\n  )) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"system must be a string, SystemModelMessage, or array of SystemModelMessage\"\n    });\n  }\n  let messages;\n  if (prompt.prompt != null && typeof prompt.prompt === \"string\") {\n    messages = [{ role: \"user\", content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (messages.length === 0) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"messages must not be empty\"\n    });\n  }\n  const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n    value: messages,\n    schema: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(modelMessageSchema)\n  });\n  if (!validationResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n      prompt,\n      message: \"The messages do not match the ModelMessage[] schema.\",\n      cause: validationResult.error\n    });\n  }\n  return {\n    messages,\n    system: prompt.system\n  };\n}\n\n// src/prompt/wrap-gateway-error.ts\n\n\nfunction wrapGatewayError(error) {\n  if (!_ai_sdk_gateway__WEBPACK_IMPORTED_MODULE_1__.GatewayAuthenticationError.isInstance(error))\n    return error;\n  const isProductionEnv = (process == null ? void 0 : \"development\") === \"production\";\n  const moreInfoURL = \"https://ai-sdk.dev/unauthenticated-ai-gateway\";\n  if (isProductionEnv) {\n    return new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError({\n      name: \"GatewayError\",\n      message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`\n    });\n  }\n  return Object.assign(\n    new Error(`\\x1B[1m\\x1B[31mUnauthenticated request to AI Gateway.\\x1B[0m\n\nTo authenticate, set the \\x1B[33mAI_GATEWAY_API_KEY\\x1B[0m environment variable with your API key.\n\nAlternatively, you can use a provider module instead of the AI Gateway.\n\nLearn more: \\x1B[34m${moreInfoURL}\\x1B[0m\n\n`),\n    { name: \"GatewayAuthenticationError\" }\n  );\n}\n\n// src/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({\n  operationId,\n  telemetry\n}) {\n  return {\n    // standardized operation and resource name:\n    \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n    \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n    // detailed, AI SDK specific data:\n    \"ai.operationId\": operationId,\n    \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n  };\n}\n\n// src/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers\n}) {\n  var _a21;\n  return {\n    \"ai.model.provider\": model.provider,\n    \"ai.model.id\": model.modelId,\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      if (key === \"timeout\") {\n        const totalTimeoutMs = getTotalTimeoutMs(\n          value\n        );\n        if (totalTimeoutMs != null) {\n          attributes[`ai.settings.${key}`] = totalTimeoutMs;\n        }\n      } else {\n        attributes[`ai.settings.${key}`] = value;\n      }\n      return attributes;\n    }, {}),\n    // add metadata as attributes:\n    ...Object.entries((_a21 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a21 : {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {}\n    ),\n    // request headers\n    ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value]) => {\n      if (value !== void 0) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {})\n  };\n}\n\n// src/telemetry/get-tracer.ts\n\n\n// src/telemetry/noop-tracer.ts\nvar noopTracer = {\n  startSpan() {\n    return noopSpan;\n  },\n  startActiveSpan(name21, arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === \"function\") {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === \"function\") {\n      return arg3(noopSpan);\n    }\n  }\n};\nvar noopSpan = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  }\n};\nvar noopSpanContext = {\n  traceId: \"\",\n  spanId: \"\",\n  traceFlags: 0\n};\n\n// src/telemetry/get-tracer.ts\nfunction getTracer({\n  isEnabled = false,\n  tracer\n} = {}) {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n  if (tracer) {\n    return tracer;\n  }\n  return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_4__.trace.getTracer(\"ai\");\n}\n\n// src/telemetry/record-span.ts\n\nasync function recordSpan({\n  name: name21,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true\n}) {\n  return tracer.startActiveSpan(\n    name21,\n    { attributes: await attributes },\n    async (span) => {\n      const ctx = _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.context.active();\n      try {\n        const result = await _opentelemetry_api__WEBPACK_IMPORTED_MODULE_5__.context.with(ctx, () => fn(span));\n        if (endWhenDone) {\n          span.end();\n        }\n        return result;\n      } catch (error) {\n        try {\n          recordErrorOnSpan(span, error);\n        } finally {\n          span.end();\n        }\n        throw error;\n      }\n    }\n  );\n}\nfunction recordErrorOnSpan(span, error) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack\n    });\n    span.setStatus({\n      code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_6__.SpanStatusCode.ERROR,\n      message: error.message\n    });\n  } else {\n    span.setStatus({ code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_6__.SpanStatusCode.ERROR });\n  }\n}\n\n// src/telemetry/select-telemetry-attributes.ts\nasync function selectTelemetryAttributes({\n  telemetry,\n  attributes\n}) {\n  if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n    return {};\n  }\n  const resultAttributes = {};\n  for (const [key, value] of Object.entries(attributes)) {\n    if (value == null) {\n      continue;\n    }\n    if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n        continue;\n      }\n      const result = await value.input();\n      if (result != null) {\n        resultAttributes[key] = result;\n      }\n      continue;\n    }\n    if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n      if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n        continue;\n      }\n      const result = await value.output();\n      if (result != null) {\n        resultAttributes[key] = result;\n      }\n      continue;\n    }\n    resultAttributes[key] = value;\n  }\n  return resultAttributes;\n}\n\n// src/telemetry/stringify-for-telemetry.ts\nfunction stringifyForTelemetry(prompt) {\n  return JSON.stringify(\n    prompt.map((message) => ({\n      ...message,\n      content: typeof message.content === \"string\" ? message.content : message.content.map(\n        (part) => part.type === \"file\" ? {\n          ...part,\n          data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data\n        } : part\n      )\n    }))\n  );\n}\n\n// src/types/usage.ts\nfunction asLanguageModelUsage(usage) {\n  return {\n    inputTokens: usage.inputTokens.total,\n    inputTokenDetails: {\n      noCacheTokens: usage.inputTokens.noCache,\n      cacheReadTokens: usage.inputTokens.cacheRead,\n      cacheWriteTokens: usage.inputTokens.cacheWrite\n    },\n    outputTokens: usage.outputTokens.total,\n    outputTokenDetails: {\n      textTokens: usage.outputTokens.text,\n      reasoningTokens: usage.outputTokens.reasoning\n    },\n    totalTokens: addTokenCounts(\n      usage.inputTokens.total,\n      usage.outputTokens.total\n    ),\n    raw: usage.raw,\n    reasoningTokens: usage.outputTokens.reasoning,\n    cachedInputTokens: usage.inputTokens.cacheRead\n  };\n}\nfunction createNullLanguageModelUsage() {\n  return {\n    inputTokens: void 0,\n    inputTokenDetails: {\n      noCacheTokens: void 0,\n      cacheReadTokens: void 0,\n      cacheWriteTokens: void 0\n    },\n    outputTokens: void 0,\n    outputTokenDetails: {\n      textTokens: void 0,\n      reasoningTokens: void 0\n    },\n    totalTokens: void 0,\n    raw: void 0\n  };\n}\nfunction addLanguageModelUsage(usage1, usage2) {\n  var _a21, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    inputTokenDetails: {\n      noCacheTokens: addTokenCounts(\n        (_a21 = usage1.inputTokenDetails) == null ? void 0 : _a21.noCacheTokens,\n        (_b = usage2.inputTokenDetails) == null ? void 0 : _b.noCacheTokens\n      ),\n      cacheReadTokens: addTokenCounts(\n        (_c = usage1.inputTokenDetails) == null ? void 0 : _c.cacheReadTokens,\n        (_d = usage2.inputTokenDetails) == null ? void 0 : _d.cacheReadTokens\n      ),\n      cacheWriteTokens: addTokenCounts(\n        (_e = usage1.inputTokenDetails) == null ? void 0 : _e.cacheWriteTokens,\n        (_f = usage2.inputTokenDetails) == null ? void 0 : _f.cacheWriteTokens\n      )\n    },\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    outputTokenDetails: {\n      textTokens: addTokenCounts(\n        (_g = usage1.outputTokenDetails) == null ? void 0 : _g.textTokens,\n        (_h = usage2.outputTokenDetails) == null ? void 0 : _h.textTokens\n      ),\n      reasoningTokens: addTokenCounts(\n        (_i = usage1.outputTokenDetails) == null ? void 0 : _i.reasoningTokens,\n        (_j = usage2.outputTokenDetails) == null ? void 0 : _j.reasoningTokens\n      )\n    },\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens\n    )\n  };\n}\nfunction addTokenCounts(tokenCount1, tokenCount2) {\n  return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);\n}\nfunction addImageModelUsage(usage1, usage2) {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens)\n  };\n}\n\n// src/util/merge-objects.ts\nfunction mergeObjects(base, overrides) {\n  if (base === void 0 && overrides === void 0) {\n    return void 0;\n  }\n  if (base === void 0) {\n    return overrides;\n  }\n  if (overrides === void 0) {\n    return base;\n  }\n  const result = { ...base };\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n      if (overridesValue === void 0)\n        continue;\n      const baseValue = key in base ? base[key] : void 0;\n      const isSourceObject = overridesValue !== null && typeof overridesValue === \"object\" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);\n      const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === \"object\" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);\n      if (isSourceObject && isTargetObject) {\n        result[key] = mergeObjects(\n          baseValue,\n          overridesValue\n        );\n      } else {\n        result[key] = overridesValue;\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/retry-with-exponential-backoff.ts\n\n\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay\n}) {\n  const headers = error.responseHeaders;\n  if (!headers)\n    return exponentialBackoffDelay;\n  let ms;\n  const retryAfterMs = headers[\"retry-after-ms\"];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n  const retryAfter = headers[\"retry-after\"];\n  if (retryAfter && ms === void 0) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1e3;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n  if (ms != null && !Number.isNaN(ms) && 0 <= ms && (ms < 60 * 1e3 || ms < exponentialBackoffDelay)) {\n    return ms;\n  }\n  return exponentialBackoffDelay;\n}\nvar retryWithExponentialBackoffRespectingRetryHeaders = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2,\n  abortSignal\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor,\n  abortSignal\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor,\n  abortSignal\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay)(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs\n        }),\n        { abortSignal }\n      );\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal\n        },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// src/util/prepare-retries.ts\nfunction prepareRetries({\n  maxRetries,\n  abortSignal\n}) {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  const maxRetriesResult = maxRetries != null ? maxRetries : 2;\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal\n    })\n  };\n}\n\n// src/generate-text/collect-tool-approvals.ts\nfunction collectToolApprovals({\n  messages\n}) {\n  const lastMessage = messages.at(-1);\n  if ((lastMessage == null ? void 0 : lastMessage.role) != \"tool\") {\n    return {\n      approvedToolApprovals: [],\n      deniedToolApprovals: []\n    };\n  }\n  const toolCallsByToolCallId = {};\n  for (const message of messages) {\n    if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n      const content = message.content;\n      for (const part of content) {\n        if (part.type === \"tool-call\") {\n          toolCallsByToolCallId[part.toolCallId] = part;\n        }\n      }\n    }\n  }\n  const toolApprovalRequestsByApprovalId = {};\n  for (const message of messages) {\n    if (message.role === \"assistant\" && typeof message.content !== \"string\") {\n      const content = message.content;\n      for (const part of content) {\n        if (part.type === \"tool-approval-request\") {\n          toolApprovalRequestsByApprovalId[part.approvalId] = part;\n        }\n      }\n    }\n  }\n  const toolResults = {};\n  for (const part of lastMessage.content) {\n    if (part.type === \"tool-result\") {\n      toolResults[part.toolCallId] = part;\n    }\n  }\n  const approvedToolApprovals = [];\n  const deniedToolApprovals = [];\n  const approvalResponses = lastMessage.content.filter(\n    (part) => part.type === \"tool-approval-response\"\n  );\n  for (const approvalResponse of approvalResponses) {\n    const approvalRequest = toolApprovalRequestsByApprovalId[approvalResponse.approvalId];\n    if (approvalRequest == null) {\n      throw new InvalidToolApprovalError({\n        approvalId: approvalResponse.approvalId\n      });\n    }\n    if (toolResults[approvalRequest.toolCallId] != null) {\n      continue;\n    }\n    const toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];\n    if (toolCall == null) {\n      throw new ToolCallNotFoundForApprovalError({\n        toolCallId: approvalRequest.toolCallId,\n        approvalId: approvalRequest.approvalId\n      });\n    }\n    const approval = {\n      approvalRequest,\n      approvalResponse,\n      toolCall\n    };\n    if (approvalResponse.approved) {\n      approvedToolApprovals.push(approval);\n    } else {\n      deniedToolApprovals.push(approval);\n    }\n  }\n  return { approvedToolApprovals, deniedToolApprovals };\n}\n\n// src/generate-text/execute-tool-call.ts\n\nasync function executeToolCall({\n  toolCall,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context,\n  onPreliminaryToolResult\n}) {\n  const { toolName, toolCallId, input } = toolCall;\n  const tool2 = tools == null ? void 0 : tools[toolName];\n  if ((tool2 == null ? void 0 : tool2.execute) == null) {\n    return void 0;\n  }\n  return recordSpan({\n    name: \"ai.toolCall\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: \"ai.toolCall\",\n          telemetry\n        }),\n        \"ai.toolCall.name\": toolName,\n        \"ai.toolCall.id\": toolCallId,\n        \"ai.toolCall.args\": {\n          output: () => JSON.stringify(input)\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      let output;\n      try {\n        const stream = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.executeTool)({\n          execute: tool2.execute.bind(tool2),\n          input,\n          options: {\n            toolCallId,\n            messages,\n            abortSignal,\n            experimental_context\n          }\n        });\n        for await (const part of stream) {\n          if (part.type === \"preliminary\") {\n            onPreliminaryToolResult == null ? void 0 : onPreliminaryToolResult({\n              ...toolCall,\n              type: \"tool-result\",\n              output: part.output,\n              preliminary: true\n            });\n          } else {\n            output = part.output;\n          }\n        }\n      } catch (error) {\n        recordErrorOnSpan(span, error);\n        return {\n          type: \"tool-error\",\n          toolCallId,\n          toolName,\n          input,\n          error,\n          dynamic: tool2.type === \"dynamic\",\n          ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}\n        };\n      }\n      try {\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.toolCall.result\": {\n                output: () => JSON.stringify(output)\n              }\n            }\n          })\n        );\n      } catch (ignored) {\n      }\n      return {\n        type: \"tool-result\",\n        toolCallId,\n        toolName,\n        input,\n        output,\n        dynamic: tool2.type === \"dynamic\",\n        ...toolCall.providerMetadata != null ? { providerMetadata: toolCall.providerMetadata } : {}\n      };\n    }\n  });\n}\n\n// src/generate-text/extract-text-content.ts\nfunction extractTextContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"text\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((content2) => content2.text).join(\"\");\n}\n\n// src/generate-text/generated-file.ts\n\nvar DefaultGeneratedFile = class {\n  constructor({\n    data,\n    mediaType\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? void 0 : data;\n    this.uint8ArrayData = isUint8Array ? data : void 0;\n    this.mediaType = mediaType;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertUint8ArrayToBase64)(this.uint8ArrayData);\n    }\n    return this.base64Data;\n  }\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(this.base64Data);\n    }\n    return this.uint8ArrayData;\n  }\n};\nvar DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {\n  constructor(options) {\n    super(options);\n    this.type = \"file\";\n  }\n};\n\n// src/generate-text/is-approval-needed.ts\nasync function isApprovalNeeded({\n  tool: tool2,\n  toolCall,\n  messages,\n  experimental_context\n}) {\n  if (tool2.needsApproval == null) {\n    return false;\n  }\n  if (typeof tool2.needsApproval === \"boolean\") {\n    return tool2.needsApproval;\n  }\n  return await tool2.needsApproval(toolCall.input, {\n    toolCallId: toolCall.toolCallId,\n    messages,\n    experimental_context\n  });\n}\n\n// src/generate-text/output.ts\nvar output_exports = {};\n__export(output_exports, {\n  array: () => array,\n  choice: () => choice,\n  json: () => json,\n  object: () => object,\n  text: () => text\n});\n\n\n\n// src/util/parse-partial-json.ts\n\n\n// src/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/util/parse-partial-json.ts\nasync function parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  let result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: jsonText });\n  if (result.success) {\n    return { value: result.value, state: \"successful-parse\" };\n  }\n  result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: fixJson(jsonText) });\n  if (result.success) {\n    return { value: result.value, state: \"repaired-parse\" };\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/generate-text/output.ts\nvar text = () => ({\n  name: \"text\",\n  responseFormat: Promise.resolve({ type: \"text\" }),\n  async parseCompleteOutput({ text: text2 }) {\n    return text2;\n  },\n  async parsePartialOutput({ text: text2 }) {\n    return { partial: text2 };\n  },\n  createElementStreamTransform() {\n    return void 0;\n  }\n});\nvar object = ({\n  schema: inputSchema,\n  name: name21,\n  description\n}) => {\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema);\n  return {\n    name: \"object\",\n    responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(schema.jsonSchema).then((jsonSchema2) => ({\n      type: \"json\",\n      schema: jsonSchema2,\n      ...name21 != null && { name: name21 },\n      ...description != null && { description }\n    })),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n        value: parseResult.value,\n        schema\n      });\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: validationResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      return validationResult.value;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value\n          };\n        }\n      }\n    },\n    createElementStreamTransform() {\n      return void 0;\n    }\n  };\n};\nvar array = ({\n  element: inputElementSchema,\n  name: name21,\n  description\n}) => {\n  const elementSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputElementSchema);\n  return {\n    name: \"array\",\n    // JSON schema that describes an array of elements:\n    responseFormat: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(elementSchema.jsonSchema).then((jsonSchema2) => {\n      const { $schema, ...itemSchema } = jsonSchema2;\n      return {\n        type: \"json\",\n        schema: {\n          $schema: \"http://json-schema.org/draft-07/schema#\",\n          type: \"object\",\n          properties: {\n            elements: { type: \"array\", items: itemSchema }\n          },\n          required: [\"elements\"],\n          additionalProperties: false\n        },\n        ...name21 != null && { name: name21 },\n        ...description != null && { description }\n      };\n    }),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      const outerValue = parseResult.value;\n      if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: outerValue,\n            cause: \"response must be an object with an elements array\"\n          }),\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      for (const element of outerValue.elements) {\n        const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n          value: element,\n          schema: elementSchema\n        });\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: \"No object generated: response did not match schema.\",\n            cause: validationResult.error,\n            text: text2,\n            response: context2.response,\n            usage: context2.usage,\n            finishReason: context2.finishReason\n          });\n        }\n      }\n      return outerValue.elements;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          const outerValue = result.value;\n          if (outerValue == null || typeof outerValue !== \"object\" || !(\"elements\" in outerValue) || !Array.isArray(outerValue.elements)) {\n            return void 0;\n          }\n          const rawElements = result.state === \"repaired-parse\" && outerValue.elements.length > 0 ? outerValue.elements.slice(0, -1) : outerValue.elements;\n          const parsedElements = [];\n          for (const rawElement of rawElements) {\n            const validationResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({\n              value: rawElement,\n              schema: elementSchema\n            });\n            if (validationResult.success) {\n              parsedElements.push(validationResult.value);\n            }\n          }\n          return { partial: parsedElements };\n        }\n      }\n    },\n    createElementStreamTransform() {\n      let publishedElements = 0;\n      return new TransformStream({\n        transform({ partialOutput }, controller) {\n          if (partialOutput != null) {\n            for (; publishedElements < partialOutput.length; publishedElements++) {\n              controller.enqueue(partialOutput[publishedElements]);\n            }\n          }\n        }\n      });\n    }\n  };\n};\nvar choice = ({\n  options: choiceOptions,\n  name: name21,\n  description\n}) => {\n  return {\n    name: \"choice\",\n    // JSON schema that describes an enumeration:\n    responseFormat: Promise.resolve({\n      type: \"json\",\n      schema: {\n        $schema: \"http://json-schema.org/draft-07/schema#\",\n        type: \"object\",\n        properties: {\n          result: { type: \"string\", enum: choiceOptions }\n        },\n        required: [\"result\"],\n        additionalProperties: false\n      },\n      ...name21 != null && { name: name21 },\n      ...description != null && { description }\n    }),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      const outerValue = parseResult.value;\n      if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\" || !choiceOptions.includes(outerValue.result)) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: response did not match schema.\",\n          cause: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value: outerValue,\n            cause: \"response must be an object that contains a choice value.\"\n          }),\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      return outerValue.result;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          const outerValue = result.value;\n          if (outerValue == null || typeof outerValue !== \"object\" || !(\"result\" in outerValue) || typeof outerValue.result !== \"string\") {\n            return void 0;\n          }\n          const potentialMatches = choiceOptions.filter(\n            (choiceOption) => choiceOption.startsWith(outerValue.result)\n          );\n          if (result.state === \"successful-parse\") {\n            return potentialMatches.includes(outerValue.result) ? { partial: outerValue.result } : void 0;\n          } else {\n            return potentialMatches.length === 1 ? { partial: potentialMatches[0] } : void 0;\n          }\n        }\n      }\n    },\n    createElementStreamTransform() {\n      return void 0;\n    }\n  };\n};\nvar json = ({\n  name: name21,\n  description\n} = {}) => {\n  return {\n    name: \"json\",\n    responseFormat: Promise.resolve({\n      type: \"json\",\n      ...name21 != null && { name: name21 },\n      ...description != null && { description }\n    }),\n    async parseCompleteOutput({ text: text2 }, context2) {\n      const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: text2 });\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: \"No object generated: could not parse the response.\",\n          cause: parseResult.error,\n          text: text2,\n          response: context2.response,\n          usage: context2.usage,\n          finishReason: context2.finishReason\n        });\n      }\n      return parseResult.value;\n    },\n    async parsePartialOutput({ text: text2 }) {\n      const result = await parsePartialJson(text2);\n      switch (result.state) {\n        case \"failed-parse\":\n        case \"undefined-input\": {\n          return void 0;\n        }\n        case \"repaired-parse\":\n        case \"successful-parse\": {\n          return result.value === void 0 ? void 0 : { partial: result.value };\n        }\n      }\n    },\n    createElementStreamTransform() {\n      return void 0;\n    }\n  };\n};\n\n// src/generate-text/parse-tool-call.ts\n\nasync function parseToolCall({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages\n}) {\n  var _a21;\n  try {\n    if (tools == null) {\n      if (toolCall.providerExecuted && toolCall.dynamic) {\n        return await parseProviderExecutedDynamicToolCall(toolCall);\n      }\n      throw new NoSuchToolError({ toolName: toolCall.toolName });\n    }\n    try {\n      return await doParseToolCall({ toolCall, tools });\n    } catch (error) {\n      if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolInputError.isInstance(error))) {\n        throw error;\n      }\n      let repairedToolCall = null;\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: async ({ toolName }) => {\n            const { inputSchema } = tools[toolName];\n            return await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error\n        });\n      }\n      if (repairedToolCall == null) {\n        throw error;\n      }\n      return await doParseToolCall({ toolCall: repairedToolCall, tools });\n    }\n  } catch (error) {\n    const parsedInput = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n    return {\n      type: \"tool-call\",\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error,\n      title: (_a21 = tools == null ? void 0 : tools[toolCall.toolName]) == null ? void 0 : _a21.title,\n      providerExecuted: toolCall.providerExecuted,\n      providerMetadata: toolCall.providerMetadata\n    };\n  }\n}\nasync function parseProviderExecutedDynamicToolCall(toolCall) {\n  const parseResult = toolCall.input.trim() === \"\" ? { success: true, value: {} } : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName: toolCall.toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: true,\n    dynamic: true,\n    providerMetadata: toolCall.providerMetadata\n  };\n}\nasync function doParseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    if (toolCall.providerExecuted && toolCall.dynamic) {\n      return await parseProviderExecutedDynamicToolCall(toolCall);\n    }\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const schema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(tool2.inputSchema);\n  const parseResult = toolCall.input.trim() === \"\" ? await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: {}, schema }) : await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: toolCall.input, schema });\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error\n    });\n  }\n  return tool2.type === \"dynamic\" ? {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    dynamic: true,\n    title: tool2.title\n  } : {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    input: parseResult.value,\n    providerExecuted: toolCall.providerExecuted,\n    providerMetadata: toolCall.providerMetadata,\n    title: tool2.title\n  };\n}\n\n// src/generate-text/step-result.ts\nvar DefaultStepResult = class {\n  constructor({\n    content,\n    finishReason,\n    rawFinishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.rawFinishReason = rawFinishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n  get text() {\n    return this.content.filter((part) => part.type === \"text\").map((part) => part.text).join(\"\");\n  }\n  get reasoning() {\n    return this.content.filter((part) => part.type === \"reasoning\");\n  }\n  get reasoningText() {\n    return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part) => part.text).join(\"\");\n  }\n  get files() {\n    return this.content.filter((part) => part.type === \"file\").map((part) => part.file);\n  }\n  get sources() {\n    return this.content.filter((part) => part.type === \"source\");\n  }\n  get toolCalls() {\n    return this.content.filter((part) => part.type === \"tool-call\");\n  }\n  get staticToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic !== true\n    );\n  }\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall) => toolCall.dynamic === true\n    );\n  }\n  get toolResults() {\n    return this.content.filter((part) => part.type === \"tool-result\");\n  }\n  get staticToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic !== true\n    );\n  }\n  get dynamicToolResults() {\n    return this.toolResults.filter(\n      (toolResult) => toolResult.dynamic === true\n    );\n  }\n};\n\n// src/generate-text/stop-condition.ts\nfunction stepCountIs(stepCount) {\n  return ({ steps }) => steps.length === stepCount;\n}\nfunction hasToolCall(toolName) {\n  return ({ steps }) => {\n    var _a21, _b, _c;\n    return (_c = (_b = (_a21 = steps[steps.length - 1]) == null ? void 0 : _a21.toolCalls) == null ? void 0 : _b.some(\n      (toolCall) => toolCall.toolName === toolName\n    )) != null ? _c : false;\n  };\n}\nasync function isStopConditionMet({\n  stopConditions,\n  steps\n}) {\n  return (await Promise.all(stopConditions.map((condition) => condition({ steps })))).some((result) => result);\n}\n\n// src/generate-text/to-response-messages.ts\nasync function toResponseMessages({\n  content: inputContent,\n  tools\n}) {\n  const responseMessages = [];\n  const content = [];\n  for (const part of inputContent) {\n    if (part.type === \"source\") {\n      continue;\n    }\n    if ((part.type === \"tool-result\" || part.type === \"tool-error\") && !part.providerExecuted) {\n      continue;\n    }\n    if (part.type === \"text\" && part.text.length === 0) {\n      continue;\n    }\n    switch (part.type) {\n      case \"text\":\n        content.push({\n          type: \"text\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"reasoning\":\n        content.push({\n          type: \"reasoning\",\n          text: part.text,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"file\":\n        content.push({\n          type: \"file\",\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"tool-call\":\n        content.push({\n          type: \"tool-call\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      case \"tool-result\": {\n        const output = await createToolModelOutput({\n          toolCallId: part.toolCallId,\n          input: part.input,\n          tool: tools == null ? void 0 : tools[part.toolName],\n          output: part.output,\n          errorMode: \"none\"\n        });\n        content.push({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      }\n      case \"tool-error\": {\n        const output = await createToolModelOutput({\n          toolCallId: part.toolCallId,\n          input: part.input,\n          tool: tools == null ? void 0 : tools[part.toolName],\n          output: part.error,\n          errorMode: \"json\"\n        });\n        content.push({\n          type: \"tool-result\",\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output,\n          providerOptions: part.providerMetadata\n        });\n        break;\n      }\n      case \"tool-approval-request\":\n        content.push({\n          type: \"tool-approval-request\",\n          approvalId: part.approvalId,\n          toolCallId: part.toolCall.toolCallId\n        });\n        break;\n    }\n  }\n  if (content.length > 0) {\n    responseMessages.push({\n      role: \"assistant\",\n      content\n    });\n  }\n  const toolResultContent = [];\n  for (const part of inputContent) {\n    if (!(part.type === \"tool-result\" || part.type === \"tool-error\") || part.providerExecuted) {\n      continue;\n    }\n    const output = await createToolModelOutput({\n      toolCallId: part.toolCallId,\n      input: part.input,\n      tool: tools == null ? void 0 : tools[part.toolName],\n      output: part.type === \"tool-result\" ? part.output : part.error,\n      errorMode: part.type === \"tool-error\" ? \"text\" : \"none\"\n    });\n    toolResultContent.push({\n      type: \"tool-result\",\n      toolCallId: part.toolCallId,\n      toolName: part.toolName,\n      output,\n      ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n    });\n  }\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: \"tool\",\n      content: toolResultContent\n    });\n  }\n  return responseMessages;\n}\n\n// src/util/merge-abort-signals.ts\nfunction mergeAbortSignals(...signals) {\n  const validSignals = signals.filter(\n    (signal) => signal != null\n  );\n  if (validSignals.length === 0) {\n    return void 0;\n  }\n  if (validSignals.length === 1) {\n    return validSignals[0];\n  }\n  const controller = new AbortController();\n  for (const signal of validSignals) {\n    if (signal.aborted) {\n      controller.abort(signal.reason);\n      return controller.signal;\n    }\n    signal.addEventListener(\n      \"abort\",\n      () => {\n        controller.abort(signal.reason);\n      },\n      { once: true }\n    );\n  }\n  return controller.signal;\n}\n\n// src/generate-text/generate-text.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nasync function generateText({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  timeout,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output,\n  output = experimental_output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download2,\n  experimental_context,\n  experimental_include: include,\n  _internal: { generateId: generateId2 = originalGenerateId } = {},\n  onStepFinish,\n  onFinish,\n  ...settings\n}) {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const totalTimeoutMs = getTotalTimeoutMs(timeout);\n  const stepTimeoutMs = getStepTimeoutMs(timeout);\n  const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n  const mergedAbortSignal = mergeAbortSignals(\n    abortSignal,\n    totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0,\n    stepAbortController == null ? void 0 : stepAbortController.signal\n  );\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal: mergedAbortSignal\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries }\n  });\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages\n  });\n  const tracer = getTracer(telemetry);\n  try {\n    return await recordSpan({\n      name: \"ai.generateText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateText\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          \"ai.model.provider\": model.provider,\n          \"ai.model.id\": model.modelId,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a21, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n        const initialMessages = initialPrompt.messages;\n        const responseMessages = [];\n        const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });\n        const localApprovedToolApprovals = approvedToolApprovals.filter(\n          (toolApproval) => !toolApproval.toolCall.providerExecuted\n        );\n        if (deniedToolApprovals.length > 0 || localApprovedToolApprovals.length > 0) {\n          const toolOutputs = await executeTools({\n            toolCalls: localApprovedToolApprovals.map(\n              (toolApproval) => toolApproval.toolCall\n            ),\n            tools,\n            tracer,\n            telemetry,\n            messages: initialMessages,\n            abortSignal: mergedAbortSignal,\n            experimental_context\n          });\n          const toolContent = [];\n          for (const output2 of toolOutputs) {\n            const modelOutput = await createToolModelOutput({\n              toolCallId: output2.toolCallId,\n              input: output2.input,\n              tool: tools == null ? void 0 : tools[output2.toolName],\n              output: output2.type === \"tool-result\" ? output2.output : output2.error,\n              errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n            });\n            toolContent.push({\n              type: \"tool-result\",\n              toolCallId: output2.toolCallId,\n              toolName: output2.toolName,\n              output: modelOutput\n            });\n          }\n          for (const toolApproval of deniedToolApprovals) {\n            toolContent.push({\n              type: \"tool-result\",\n              toolCallId: toolApproval.toolCall.toolCallId,\n              toolName: toolApproval.toolCall.toolName,\n              output: {\n                type: \"execution-denied\",\n                reason: toolApproval.approvalResponse.reason,\n                // For provider-executed tools, include approvalId so provider can correlate\n                ...toolApproval.toolCall.providerExecuted && {\n                  providerOptions: {\n                    openai: {\n                      approvalId: toolApproval.approvalResponse.approvalId\n                    }\n                  }\n                }\n              }\n            });\n          }\n          responseMessages.push({\n            role: \"tool\",\n            content: toolContent\n          });\n        }\n        const providerExecutedToolApprovals = [\n          ...approvedToolApprovals,\n          ...deniedToolApprovals\n        ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);\n        if (providerExecutedToolApprovals.length > 0) {\n          responseMessages.push({\n            role: \"tool\",\n            content: providerExecutedToolApprovals.map(\n              (toolApproval) => ({\n                type: \"tool-approval-response\",\n                approvalId: toolApproval.approvalResponse.approvalId,\n                approved: toolApproval.approvalResponse.approved,\n                reason: toolApproval.approvalResponse.reason,\n                providerExecuted: true\n              })\n            )\n          });\n        }\n        const callSettings2 = prepareCallSettings(settings);\n        let currentModelResponse;\n        let clientToolCalls = [];\n        let clientToolOutputs = [];\n        const steps = [];\n        const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n        do {\n          const stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;\n          try {\n            const stepInputMessages = [...initialMessages, ...responseMessages];\n            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n              model,\n              steps,\n              stepNumber: steps.length,\n              messages: stepInputMessages,\n              experimental_context\n            }));\n            const stepModel = resolveLanguageModel(\n              (_a21 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a21 : model\n            );\n            const promptMessages = await convertToLanguageModelPrompt({\n              prompt: {\n                system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n              },\n              supportedUrls: await stepModel.supportedUrls,\n              download: download2\n            });\n            experimental_context = (_d = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _d : experimental_context;\n            const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n              tools,\n              toolChoice: (_e = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _e : toolChoice,\n              activeTools: (_f = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _f : activeTools\n            });\n            currentModelResponse = await retry(\n              () => {\n                var _a22;\n                return recordSpan({\n                  name: \"ai.generateText.doGenerate\",\n                  attributes: selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      ...assembleOperationName({\n                        operationId: \"ai.generateText.doGenerate\",\n                        telemetry\n                      }),\n                      ...baseTelemetryAttributes,\n                      // model:\n                      \"ai.model.provider\": stepModel.provider,\n                      \"ai.model.id\": stepModel.modelId,\n                      // prompt:\n                      \"ai.prompt.messages\": {\n                        input: () => stringifyForTelemetry(promptMessages)\n                      },\n                      \"ai.prompt.tools\": {\n                        // convert the language model level tools:\n                        input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                      },\n                      \"ai.prompt.toolChoice\": {\n                        input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                      },\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.system\": stepModel.provider,\n                      \"gen_ai.request.model\": stepModel.modelId,\n                      \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                      \"gen_ai.request.max_tokens\": settings.maxOutputTokens,\n                      \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                      \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                      \"gen_ai.request.temperature\": (_a22 = settings.temperature) != null ? _a22 : void 0,\n                      \"gen_ai.request.top_k\": settings.topK,\n                      \"gen_ai.request.top_p\": settings.topP\n                    }\n                  }),\n                  tracer,\n                  fn: async (span2) => {\n                    var _a23, _b2, _c2, _d2, _e2, _f2, _g2, _h2;\n                    const stepProviderOptions = mergeObjects(\n                      providerOptions,\n                      prepareStepResult == null ? void 0 : prepareStepResult.providerOptions\n                    );\n                    const result = await stepModel.doGenerate({\n                      ...callSettings2,\n                      tools: stepTools,\n                      toolChoice: stepToolChoice,\n                      responseFormat: await (output == null ? void 0 : output.responseFormat),\n                      prompt: promptMessages,\n                      providerOptions: stepProviderOptions,\n                      abortSignal: mergedAbortSignal,\n                      headers: headersWithUserAgent\n                    });\n                    const responseData = {\n                      id: (_b2 = (_a23 = result.response) == null ? void 0 : _a23.id) != null ? _b2 : generateId2(),\n                      timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : /* @__PURE__ */ new Date(),\n                      modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : stepModel.modelId,\n                      headers: (_g2 = result.response) == null ? void 0 : _g2.headers,\n                      body: (_h2 = result.response) == null ? void 0 : _h2.body\n                    };\n                    span2.setAttributes(\n                      await selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          \"ai.response.finishReason\": result.finishReason.unified,\n                          \"ai.response.text\": {\n                            output: () => extractTextContent(result.content)\n                          },\n                          \"ai.response.toolCalls\": {\n                            output: () => {\n                              const toolCalls = asToolCalls(result.content);\n                              return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                            }\n                          },\n                          \"ai.response.id\": responseData.id,\n                          \"ai.response.model\": responseData.modelId,\n                          \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                          \"ai.response.providerMetadata\": JSON.stringify(\n                            result.providerMetadata\n                          ),\n                          // TODO rename telemetry attributes to inputTokens and outputTokens\n                          \"ai.usage.promptTokens\": result.usage.inputTokens.total,\n                          \"ai.usage.completionTokens\": result.usage.outputTokens.total,\n                          // standardized gen-ai llm span attributes:\n                          \"gen_ai.response.finish_reasons\": [\n                            result.finishReason.unified\n                          ],\n                          \"gen_ai.response.id\": responseData.id,\n                          \"gen_ai.response.model\": responseData.modelId,\n                          \"gen_ai.usage.input_tokens\": result.usage.inputTokens.total,\n                          \"gen_ai.usage.output_tokens\": result.usage.outputTokens.total\n                        }\n                      })\n                    );\n                    return { ...result, response: responseData };\n                  }\n                });\n              }\n            );\n            const stepToolCalls = await Promise.all(\n              currentModelResponse.content.filter(\n                (part) => part.type === \"tool-call\"\n              ).map(\n                (toolCall) => parseToolCall({\n                  toolCall,\n                  tools,\n                  repairToolCall,\n                  system,\n                  messages: stepInputMessages\n                })\n              )\n            );\n            const toolApprovalRequests = {};\n            for (const toolCall of stepToolCalls) {\n              if (toolCall.invalid) {\n                continue;\n              }\n              const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n              if (tool2 == null) {\n                continue;\n              }\n              if ((tool2 == null ? void 0 : tool2.onInputAvailable) != null) {\n                await tool2.onInputAvailable({\n                  input: toolCall.input,\n                  toolCallId: toolCall.toolCallId,\n                  messages: stepInputMessages,\n                  abortSignal: mergedAbortSignal,\n                  experimental_context\n                });\n              }\n              if (await isApprovalNeeded({\n                tool: tool2,\n                toolCall,\n                messages: stepInputMessages,\n                experimental_context\n              })) {\n                toolApprovalRequests[toolCall.toolCallId] = {\n                  type: \"tool-approval-request\",\n                  approvalId: generateId2(),\n                  toolCall\n                };\n              }\n            }\n            const invalidToolCalls = stepToolCalls.filter(\n              (toolCall) => toolCall.invalid && toolCall.dynamic\n            );\n            clientToolOutputs = [];\n            for (const toolCall of invalidToolCalls) {\n              clientToolOutputs.push({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                dynamic: true\n              });\n            }\n            clientToolCalls = stepToolCalls.filter(\n              (toolCall) => !toolCall.providerExecuted\n            );\n            if (tools != null) {\n              clientToolOutputs.push(\n                ...await executeTools({\n                  toolCalls: clientToolCalls.filter(\n                    (toolCall) => !toolCall.invalid && toolApprovalRequests[toolCall.toolCallId] == null\n                  ),\n                  tools,\n                  tracer,\n                  telemetry,\n                  messages: stepInputMessages,\n                  abortSignal: mergedAbortSignal,\n                  experimental_context\n                })\n              );\n            }\n            for (const toolCall of stepToolCalls) {\n              if (!toolCall.providerExecuted)\n                continue;\n              const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n              if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                const hasResultInResponse = currentModelResponse.content.some(\n                  (part) => part.type === \"tool-result\" && part.toolCallId === toolCall.toolCallId\n                );\n                if (!hasResultInResponse) {\n                  pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                    toolName: toolCall.toolName\n                  });\n                }\n              }\n            }\n            for (const part of currentModelResponse.content) {\n              if (part.type === \"tool-result\") {\n                pendingDeferredToolCalls.delete(part.toolCallId);\n              }\n            }\n            const stepContent = asContent({\n              content: currentModelResponse.content,\n              toolCalls: stepToolCalls,\n              toolOutputs: clientToolOutputs,\n              toolApprovalRequests: Object.values(toolApprovalRequests),\n              tools\n            });\n            responseMessages.push(\n              ...await toResponseMessages({\n                content: stepContent,\n                tools\n              })\n            );\n            const stepRequest = ((_g = include == null ? void 0 : include.requestBody) != null ? _g : true) ? (_h = currentModelResponse.request) != null ? _h : {} : { ...currentModelResponse.request, body: void 0 };\n            const stepResponse = {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages),\n              // Conditionally include response body:\n              body: ((_i = include == null ? void 0 : include.responseBody) != null ? _i : true) ? (_j = currentModelResponse.response) == null ? void 0 : _j.body : void 0\n            };\n            const currentStepResult = new DefaultStepResult({\n              content: stepContent,\n              finishReason: currentModelResponse.finishReason.unified,\n              rawFinishReason: currentModelResponse.finishReason.raw,\n              usage: asLanguageModelUsage(currentModelResponse.usage),\n              warnings: currentModelResponse.warnings,\n              providerMetadata: currentModelResponse.providerMetadata,\n              request: stepRequest,\n              response: stepResponse\n            });\n            logWarnings({\n              warnings: (_k = currentModelResponse.warnings) != null ? _k : [],\n              provider: stepModel.provider,\n              model: stepModel.modelId\n            });\n            steps.push(currentStepResult);\n            await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          } finally {\n            if (stepTimeoutId != null) {\n              clearTimeout(stepTimeoutId);\n            }\n          }\n        } while (\n          // Continue if:\n          // 1. There are client tool calls that have all been executed, OR\n          // 2. There are pending deferred results from provider-executed tools\n          (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n          !await isStopConditionMet({ stopConditions, steps })\n        );\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": currentModelResponse.finishReason.unified,\n              \"ai.response.text\": {\n                output: () => extractTextContent(currentModelResponse.content)\n              },\n              \"ai.response.toolCalls\": {\n                output: () => {\n                  const toolCalls = asToolCalls(currentModelResponse.content);\n                  return toolCalls == null ? void 0 : JSON.stringify(toolCalls);\n                }\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                currentModelResponse.providerMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": currentModelResponse.usage.inputTokens.total,\n              \"ai.usage.completionTokens\": currentModelResponse.usage.outputTokens.total\n            }\n          })\n        );\n        const lastStep = steps[steps.length - 1];\n        const totalUsage = steps.reduce(\n          (totalUsage2, step) => {\n            return addLanguageModelUsage(totalUsage2, step.usage);\n          },\n          {\n            inputTokens: void 0,\n            outputTokens: void 0,\n            totalTokens: void 0,\n            reasoningTokens: void 0,\n            cachedInputTokens: void 0\n          }\n        );\n        await (onFinish == null ? void 0 : onFinish({\n          finishReason: lastStep.finishReason,\n          rawFinishReason: lastStep.rawFinishReason,\n          usage: lastStep.usage,\n          content: lastStep.content,\n          text: lastStep.text,\n          reasoningText: lastStep.reasoningText,\n          reasoning: lastStep.reasoning,\n          files: lastStep.files,\n          sources: lastStep.sources,\n          toolCalls: lastStep.toolCalls,\n          staticToolCalls: lastStep.staticToolCalls,\n          dynamicToolCalls: lastStep.dynamicToolCalls,\n          toolResults: lastStep.toolResults,\n          staticToolResults: lastStep.staticToolResults,\n          dynamicToolResults: lastStep.dynamicToolResults,\n          request: lastStep.request,\n          response: lastStep.response,\n          warnings: lastStep.warnings,\n          providerMetadata: lastStep.providerMetadata,\n          steps,\n          totalUsage,\n          experimental_context\n        }));\n        let resolvedOutput;\n        if (lastStep.finishReason === \"stop\") {\n          const outputSpecification = output != null ? output : text();\n          resolvedOutput = await outputSpecification.parseCompleteOutput(\n            { text: lastStep.text },\n            {\n              response: lastStep.response,\n              usage: lastStep.usage,\n              finishReason: lastStep.finishReason\n            }\n          );\n        }\n        return new DefaultGenerateTextResult({\n          steps,\n          totalUsage,\n          output: resolvedOutput\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nasync function executeTools({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context\n}) {\n  const toolOutputs = await Promise.all(\n    toolCalls.map(\n      async (toolCall) => executeToolCall({\n        toolCall,\n        tools,\n        tracer,\n        telemetry,\n        messages,\n        abortSignal,\n        experimental_context\n      })\n    )\n  );\n  return toolOutputs.filter(\n    (output) => output != null\n  );\n}\nvar DefaultGenerateTextResult = class {\n  constructor(options) {\n    this.steps = options.steps;\n    this._output = options.output;\n    this.totalUsage = options.totalUsage;\n  }\n  get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n  get content() {\n    return this.finalStep.content;\n  }\n  get text() {\n    return this.finalStep.text;\n  }\n  get files() {\n    return this.finalStep.files;\n  }\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n  get sources() {\n    return this.finalStep.sources;\n  }\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n  get rawFinishReason() {\n    return this.finalStep.rawFinishReason;\n  }\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n  get response() {\n    return this.finalStep.response;\n  }\n  get request() {\n    return this.finalStep.request;\n  }\n  get usage() {\n    return this.finalStep.usage;\n  }\n  get experimental_output() {\n    return this.output;\n  }\n  get output() {\n    if (this._output == null) {\n      throw new NoOutputGeneratedError();\n    }\n    return this._output;\n  }\n};\nfunction asToolCalls(content) {\n  const parts = content.filter(\n    (part) => part.type === \"tool-call\"\n  );\n  if (parts.length === 0) {\n    return void 0;\n  }\n  return parts.map((toolCall) => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input\n  }));\n}\nfunction asContent({\n  content,\n  toolCalls,\n  toolOutputs,\n  toolApprovalRequests,\n  tools\n}) {\n  const contentParts = [];\n  for (const part of content) {\n    switch (part.type) {\n      case \"text\":\n      case \"reasoning\":\n      case \"source\":\n        contentParts.push(part);\n        break;\n      case \"file\": {\n        contentParts.push({\n          type: \"file\",\n          file: new DefaultGeneratedFile(part),\n          ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n        });\n        break;\n      }\n      case \"tool-call\": {\n        contentParts.push(\n          toolCalls.find((toolCall) => toolCall.toolCallId === part.toolCallId)\n        );\n        break;\n      }\n      case \"tool-result\": {\n        const toolCall = toolCalls.find(\n          (toolCall2) => toolCall2.toolCallId === part.toolCallId\n        );\n        if (toolCall == null) {\n          const tool2 = tools == null ? void 0 : tools[part.toolName];\n          const supportsDeferredResults = (tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults;\n          if (!supportsDeferredResults) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n          if (part.isError) {\n            contentParts.push({\n              type: \"tool-error\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: void 0,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: part.dynamic\n            });\n          } else {\n            contentParts.push({\n              type: \"tool-result\",\n              toolCallId: part.toolCallId,\n              toolName: part.toolName,\n              input: void 0,\n              output: part.result,\n              providerExecuted: true,\n              dynamic: part.dynamic\n            });\n          }\n          break;\n        }\n        if (part.isError) {\n          contentParts.push({\n            type: \"tool-error\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            error: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          });\n        } else {\n          contentParts.push({\n            type: \"tool-result\",\n            toolCallId: part.toolCallId,\n            toolName: part.toolName,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic\n          });\n        }\n        break;\n      }\n      case \"tool-approval-request\": {\n        const toolCall = toolCalls.find(\n          (toolCall2) => toolCall2.toolCallId === part.toolCallId\n        );\n        if (toolCall == null) {\n          throw new ToolCallNotFoundForApprovalError({\n            toolCallId: part.toolCallId,\n            approvalId: part.approvalId\n          });\n        }\n        contentParts.push({\n          type: \"tool-approval-request\",\n          approvalId: part.approvalId,\n          toolCall\n        });\n        break;\n      }\n    }\n  }\n  return [...contentParts, ...toolOutputs, ...toolApprovalRequests];\n}\n\n// src/generate-text/stream-text.ts\n\n\n\n// src/util/prepare-headers.ts\nfunction prepareHeaders(headers, defaultHeaders) {\n  const responseHeaders = new Headers(headers != null ? headers : {});\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n  return responseHeaders;\n}\n\n// src/text-stream/create-text-stream-response.ts\nfunction createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status != null ? status : 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      \"content-type\": \"text/plain; charset=utf-8\"\n    })\n  });\n}\n\n// src/util/write-to-server-response.ts\nfunction writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream\n}) {\n  const statusCode = status != null ? status : 200;\n  if (statusText !== void 0) {\n    response.writeHead(statusCode, statusText, headers);\n  } else {\n    response.writeHead(statusCode, headers);\n  }\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done)\n          break;\n        const canContinue = response.write(value);\n        if (!canContinue) {\n          await new Promise((resolve3) => {\n            response.once(\"drain\", resolve3);\n          });\n        }\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n  read();\n}\n\n// src/text-stream/pipe-text-stream-to-response.ts\nfunction pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream\n}) {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        \"content-type\": \"text/plain; charset=utf-8\"\n      }).entries()\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/ui-message-stream/json-to-sse-transform-stream.ts\nvar JsonToSseTransformStream = class extends TransformStream {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\n\n`);\n      },\n      flush(controller) {\n        controller.enqueue(\"data: [DONE]\\n\\n\");\n      }\n    });\n  }\n};\n\n// src/ui-message-stream/ui-message-stream-headers.ts\nvar UI_MESSAGE_STREAM_HEADERS = {\n  \"content-type\": \"text/event-stream\",\n  \"cache-control\": \"no-cache\",\n  connection: \"keep-alive\",\n  \"x-vercel-ai-ui-message-stream\": \"v1\",\n  \"x-accel-buffering\": \"no\"\n  // disable nginx buffering\n};\n\n// src/ui-message-stream/create-ui-message-stream-response.ts\nfunction createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS)\n  });\n}\n\n// src/ui-message-stream/get-response-ui-message-id.ts\nfunction getResponseUIMessageId({\n  originalMessages,\n  responseMessageId\n}) {\n  if (originalMessages == null) {\n    return void 0;\n  }\n  const lastMessage = originalMessages[originalMessages.length - 1];\n  return (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage.id : typeof responseMessageId === \"function\" ? responseMessageId() : responseMessageId;\n}\n\n// src/ui/process-ui-message-stream.ts\n\n\n// src/ui-message-stream/ui-message-chunks.ts\n\n\nvar uiMessageChunkSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text-start\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text-delta\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text-end\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"error\"),\n        errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-start\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-delta\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        inputTextDelta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-available\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-input-error\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-approval-request\"),\n        approvalId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-output-available\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-output-error\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n        dynamic: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-output-denied\"),\n        toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning-start\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning-delta\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        delta: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning-end\"),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-url\"),\n        sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-document\"),\n        sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n        url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        providerMetadata: providerMetadataSchema.optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.custom(\n          (value) => typeof value === \"string\" && value.startsWith(\"data-\"),\n          { message: 'Type must start with \"data-\"' }\n        ),\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n        data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n        transient: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"start-step\")\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"finish-step\")\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"start\"),\n        messageId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n        messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"finish\"),\n        finishReason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"enum\"]([\n          \"stop\",\n          \"length\",\n          \"content-filter\",\n          \"tool-calls\",\n          \"error\",\n          \"other\"\n        ]).optional(),\n        messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"abort\"),\n        reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n      }),\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.strictObject({\n        type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"message-metadata\"),\n        messageMetadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown()\n      })\n    ])\n  )\n);\nfunction isDataUIMessageChunk(chunk) {\n  return chunk.type.startsWith(\"data-\");\n}\n\n// src/ui/ui-messages.ts\nfunction isDataUIPart(part) {\n  return part.type.startsWith(\"data-\");\n}\nfunction isTextUIPart(part) {\n  return part.type === \"text\";\n}\nfunction isFileUIPart(part) {\n  return part.type === \"file\";\n}\nfunction isReasoningUIPart(part) {\n  return part.type === \"reasoning\";\n}\nfunction isStaticToolUIPart(part) {\n  return part.type.startsWith(\"tool-\");\n}\nfunction isDynamicToolUIPart(part) {\n  return part.type === \"dynamic-tool\";\n}\nfunction isToolUIPart(part) {\n  return isStaticToolUIPart(part) || isDynamicToolUIPart(part);\n}\nvar isToolOrDynamicToolUIPart = isToolUIPart;\nfunction getStaticToolName(part) {\n  return part.type.split(\"-\").slice(1).join(\"-\");\n}\nfunction getToolName(part) {\n  return isDynamicToolUIPart(part) ? part.toolName : getStaticToolName(part);\n}\nvar getToolOrDynamicToolName = getToolName;\n\n// src/ui/process-ui-message-stream.ts\nfunction createStreamingUIMessageState({\n  lastMessage,\n  messageId\n}) {\n  return {\n    message: (lastMessage == null ? void 0 : lastMessage.role) === \"assistant\" ? lastMessage : {\n      id: messageId,\n      metadata: void 0,\n      role: \"assistant\",\n      parts: []\n    },\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {}\n  };\n}\nfunction processUIMessageStream({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      async transform(chunk, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          var _a21, _b, _c, _d;\n          function getToolInvocation(toolCallId) {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n            const toolInvocation = toolInvocations.find(\n              (invocation) => invocation.toolCallId === toolCallId\n            );\n            if (toolInvocation == null) {\n              throw new UIMessageStreamError({\n                chunkType: \"tool-invocation\",\n                chunkId: toolCallId,\n                message: `No tool invocation found for tool call ID \"${toolCallId}\".`\n              });\n            }\n            return toolInvocation;\n          }\n          function updateToolPart(options) {\n            var _a22;\n            const part = state.message.parts.find(\n              (part2) => isStaticToolUIPart(part2) && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (options.title !== void 0) {\n                anyPart.title = options.title;\n              }\n              anyPart.providerExecuted = (_a22 = anyOptions.providerExecuted) != null ? _a22 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null) {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: `tool-${options.toolName}`,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                title: options.title,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                rawInput: anyOptions.rawInput,\n                errorText: anyOptions.errorText,\n                providerExecuted: anyOptions.providerExecuted,\n                preliminary: anyOptions.preliminary,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          function updateDynamicToolPart(options) {\n            var _a22, _b2;\n            const part = state.message.parts.find(\n              (part2) => part2.type === \"dynamic-tool\" && part2.toolCallId === options.toolCallId\n            );\n            const anyOptions = options;\n            const anyPart = part;\n            if (part != null) {\n              part.state = options.state;\n              anyPart.toolName = options.toolName;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = (_a22 = anyOptions.rawInput) != null ? _a22 : anyPart.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (options.title !== void 0) {\n                anyPart.title = options.title;\n              }\n              anyPart.providerExecuted = (_b2 = anyOptions.providerExecuted) != null ? _b2 : part.providerExecuted;\n              if (anyOptions.providerMetadata != null) {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: \"dynamic-tool\",\n                toolName: options.toolName,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                errorText: anyOptions.errorText,\n                preliminary: anyOptions.preliminary,\n                providerExecuted: anyOptions.providerExecuted,\n                title: options.title,\n                ...anyOptions.providerMetadata != null ? { callProviderMetadata: anyOptions.providerMetadata } : {}\n              });\n            }\n          }\n          async function updateMessageMetadata(metadata) {\n            if (metadata != null) {\n              const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;\n              if (messageMetadataSchema != null) {\n                await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema,\n                  context: {\n                    field: \"message.metadata\",\n                    entityId: state.message.id\n                  }\n                });\n              }\n              state.message.metadata = mergedMetadata;\n            }\n          }\n          switch (chunk.type) {\n            case \"text-start\": {\n              const textPart = {\n                type: \"text\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n            case \"text-delta\": {\n              const textPart = state.activeTextParts[chunk.id];\n              if (textPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"text-delta\",\n                  chunkId: chunk.id,\n                  message: `Received text-delta for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-delta\" chunks.`\n                });\n              }\n              textPart.text += chunk.delta;\n              textPart.providerMetadata = (_a21 = chunk.providerMetadata) != null ? _a21 : textPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"text-end\": {\n              const textPart = state.activeTextParts[chunk.id];\n              if (textPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"text-end\",\n                  chunkId: chunk.id,\n                  message: `Received text-end for missing text part with ID \"${chunk.id}\". Ensure a \"text-start\" chunk is sent before any \"text-end\" chunks.`\n                });\n              }\n              textPart.state = \"done\";\n              textPart.providerMetadata = (_b = chunk.providerMetadata) != null ? _b : textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n            case \"reasoning-start\": {\n              const reasoningPart = {\n                type: \"reasoning\",\n                text: \"\",\n                providerMetadata: chunk.providerMetadata,\n                state: \"streaming\"\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n            case \"reasoning-delta\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              if (reasoningPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"reasoning-delta\",\n                  chunkId: chunk.id,\n                  message: `Received reasoning-delta for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-delta\" chunks.`\n                });\n              }\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata = (_c = chunk.providerMetadata) != null ? _c : reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n            case \"reasoning-end\": {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              if (reasoningPart == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"reasoning-end\",\n                  chunkId: chunk.id,\n                  message: `Received reasoning-end for missing reasoning part with ID \"${chunk.id}\". Ensure a \"reasoning-start\" chunk is sent before any \"reasoning-end\" chunks.`\n                });\n              }\n              reasoningPart.providerMetadata = (_d = chunk.providerMetadata) != null ? _d : reasoningPart.providerMetadata;\n              reasoningPart.state = \"done\";\n              delete state.activeReasoningParts[chunk.id];\n              write();\n              break;\n            }\n            case \"file\": {\n              state.message.parts.push({\n                type: \"file\",\n                mediaType: chunk.mediaType,\n                url: chunk.url\n              });\n              write();\n              break;\n            }\n            case \"source-url\": {\n              state.message.parts.push({\n                type: \"source-url\",\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"source-document\": {\n              state.message.parts.push({\n                type: \"source-document\",\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata\n              });\n              write();\n              break;\n            }\n            case \"tool-input-start\": {\n              const toolInvocations = state.message.parts.filter(isStaticToolUIPart);\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: \"\",\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic,\n                title: chunk.title\n              };\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted,\n                  title: chunk.title,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-streaming\",\n                  input: void 0,\n                  providerExecuted: chunk.providerExecuted,\n                  title: chunk.title,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-delta\": {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n              if (partialToolCall == null) {\n                throw new UIMessageStreamError({\n                  chunkType: \"tool-input-delta\",\n                  chunkId: chunk.toolCallId,\n                  message: `Received tool-input-delta for missing tool call with ID \"${chunk.toolCallId}\". Ensure a \"tool-input-start\" chunk is sent before any \"tool-input-delta\" chunks.`\n                });\n              }\n              partialToolCall.text += chunk.inputTextDelta;\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text\n              );\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs,\n                  title: partialToolCall.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: \"input-streaming\",\n                  input: partialArgs,\n                  title: partialToolCall.title\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-input-available\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                  title: chunk.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"input-available\",\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                  title: chunk.title\n                });\n              }\n              write();\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk\n                });\n              }\n              break;\n            }\n            case \"tool-input-error\": {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: \"output-error\",\n                  input: void 0,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-approval-request\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              toolInvocation.state = \"approval-requested\";\n              toolInvocation.approval = { id: chunk.approvalId };\n              write();\n              break;\n            }\n            case \"tool-output-denied\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              toolInvocation.state = \"output-denied\";\n              write();\n              break;\n            }\n            case \"tool-output-available\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              if (toolInvocation.type === \"dynamic-tool\") {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getStaticToolName(toolInvocation),\n                  state: \"output-available\",\n                  input: toolInvocation.input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary,\n                  title: toolInvocation.title\n                });\n              }\n              write();\n              break;\n            }\n            case \"tool-output-error\": {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              if (toolInvocation.type === \"dynamic-tool\") {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getStaticToolName(toolInvocation),\n                  state: \"output-error\",\n                  input: toolInvocation.input,\n                  rawInput: toolInvocation.rawInput,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title\n                });\n              }\n              write();\n              break;\n            }\n            case \"start-step\": {\n              state.message.parts.push({ type: \"step-start\" });\n              break;\n            }\n            case \"finish-step\": {\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n            case \"start\": {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"finish\": {\n              if (chunk.finishReason != null) {\n                state.finishReason = chunk.finishReason;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"message-metadata\": {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n            case \"error\": {\n              onError == null ? void 0 : onError(new Error(chunk.errorText));\n              break;\n            }\n            default: {\n              if (isDataUIMessageChunk(chunk)) {\n                if ((dataPartSchemas == null ? void 0 : dataPartSchemas[chunk.type]) != null) {\n                  const partIdx = state.message.parts.findIndex(\n                    (p) => \"id\" in p && \"data\" in p && p.id === chunk.id && p.type === chunk.type\n                  );\n                  const actualPartIdx = partIdx >= 0 ? partIdx : state.message.parts.length;\n                  await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type],\n                    context: {\n                      field: `message.parts[${actualPartIdx}].data`,\n                      entityName: chunk.type,\n                      entityId: chunk.id\n                    }\n                  });\n                }\n                const dataChunk = chunk;\n                if (dataChunk.transient) {\n                  onData == null ? void 0 : onData(dataChunk);\n                  break;\n                }\n                const existingUIPart = dataChunk.id != null ? state.message.parts.find(\n                  (chunkArg) => dataChunk.type === chunkArg.type && dataChunk.id === chunkArg.id\n                ) : void 0;\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n                onData == null ? void 0 : onData(dataChunk);\n                write();\n              }\n            }\n          }\n          controller.enqueue(chunk);\n        });\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/handle-ui-message-stream-finish.ts\nfunction handleUIMessageStreamFinish({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream\n}) {\n  let lastMessage = originalMessages == null ? void 0 : originalMessages[originalMessages.length - 1];\n  if ((lastMessage == null ? void 0 : lastMessage.role) !== \"assistant\") {\n    lastMessage = void 0;\n  } else {\n    messageId = lastMessage.id;\n  }\n  let isAborted = false;\n  const idInjectedStream = stream.pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        if (chunk.type === \"start\") {\n          const startChunk = chunk;\n          if (startChunk.messageId == null && messageId != null) {\n            startChunk.messageId = messageId;\n          }\n        }\n        if (chunk.type === \"abort\") {\n          isAborted = true;\n        }\n        controller.enqueue(chunk);\n      }\n    })\n  );\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n  const state = createStreamingUIMessageState({\n    lastMessage: lastMessage ? structuredClone(lastMessage) : void 0,\n    messageId: messageId != null ? messageId : \"\"\n    // will be overridden by the stream\n  });\n  const runUpdateMessageJob = async (job) => {\n    await job({ state, write: () => {\n    } });\n  };\n  let finishCalled = false;\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n    const isContinuation = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);\n    await onFinish({\n      isAborted,\n      isContinuation,\n      responseMessage: state.message,\n      messages: [\n        ...isContinuation ? originalMessages.slice(0, -1) : originalMessages,\n        state.message\n      ],\n      finishReason: state.finishReason\n    });\n  };\n  return processUIMessageStream({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError\n  }).pipeThrough(\n    new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n      async cancel() {\n        await callOnFinish();\n      },\n      async flush() {\n        await callOnFinish();\n      }\n    })\n  );\n}\n\n// src/ui-message-stream/pipe-ui-message-stream-to-response.ts\nfunction pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream\n}) {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 });\n  }\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries()\n    ),\n    stream: sseStream.pipeThrough(new TextEncoderStream())\n  });\n}\n\n// src/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source) {\n  const stream = source.pipeThrough(new TransformStream());\n  stream[Symbol.asyncIterator] = function() {\n    const reader = this.getReader();\n    let finished = false;\n    async function cleanup(cancelStream) {\n      var _a21;\n      if (finished)\n        return;\n      finished = true;\n      try {\n        if (cancelStream) {\n          await ((_a21 = reader.cancel) == null ? void 0 : _a21.call(reader));\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch (e) {\n        }\n      }\n    }\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next() {\n        if (finished) {\n          return { done: true, value: void 0 };\n        }\n        const { done, value } = await reader.read();\n        if (done) {\n          await cleanup(true);\n          return { done: true, value: void 0 };\n        }\n        return { done: false, value };\n      },\n      /**\n       * May be called on early exit (e.g., break from for-await) or after completion.\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return() {\n        await cleanup(true);\n        return { done: true, value: void 0 };\n      },\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err) {\n        await cleanup(true);\n        throw err;\n      }\n    };\n  };\n  return stream;\n}\n\n// src/util/consume-stream.ts\nasync function consumeStream({\n  stream,\n  onError\n}) {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done)\n        break;\n    }\n  } catch (error) {\n    onError == null ? void 0 : onError(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n\n// src/util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n  let resolve3;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve3 = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve: resolve3,\n    reject\n  };\n}\n\n// src/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n  let innerStreamReaders = [];\n  let controller = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise();\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n    innerStreamReaders.forEach((reader) => reader.cancel());\n    innerStreamReaders = [];\n    controller == null ? void 0 : controller.close();\n  };\n  const processPull = async () => {\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller == null ? void 0 : controller.close();\n      return;\n    }\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n      if (done) {\n        innerStreamReaders.shift();\n        if (innerStreamReaders.length === 0 && isClosed) {\n          controller == null ? void 0 : controller.close();\n        } else {\n          await processPull();\n        }\n      } else {\n        controller == null ? void 0 : controller.enqueue(value);\n      }\n    } catch (error) {\n      controller == null ? void 0 : controller.error(error);\n      innerStreamReaders.shift();\n      terminate();\n    }\n  };\n  return {\n    stream: new ReadableStream({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      }\n    }),\n    addStream: (innerStream) => {\n      if (isClosed) {\n        throw new Error(\"Cannot add inner stream: outer stream is closed\");\n      }\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n      if (innerStreamReaders.length === 0) {\n        controller == null ? void 0 : controller.close();\n      }\n    },\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate\n  };\n}\n\n// src/util/now.ts\nfunction now() {\n  var _a21, _b;\n  return (_b = (_a21 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a21.now()) != null ? _b : Date.now();\n}\n\n// src/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context,\n  generateId: generateId2\n}) {\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const outstandingToolResults = /* @__PURE__ */ new Set();\n  const toolInputs = /* @__PURE__ */ new Map();\n  const toolCallsByToolCallId = /* @__PURE__ */ new Map();\n  let canClose = false;\n  let finishChunk = void 0;\n  function attemptClose() {\n    if (canClose && outstandingToolResults.size === 0) {\n      if (finishChunk != null) {\n        toolResultsStreamController.enqueue(finishChunk);\n      }\n      toolResultsStreamController.close();\n    }\n  }\n  const forwardStream = new TransformStream({\n    async transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"stream-start\":\n        case \"text-start\":\n        case \"text-delta\":\n        case \"text-end\":\n        case \"reasoning-start\":\n        case \"reasoning-delta\":\n        case \"reasoning-end\":\n        case \"tool-input-start\":\n        case \"tool-input-delta\":\n        case \"tool-input-end\":\n        case \"source\":\n        case \"response-metadata\":\n        case \"error\":\n        case \"raw\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"file\": {\n          controller.enqueue({\n            type: \"file\",\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType\n            })\n          });\n          break;\n        }\n        case \"finish\": {\n          finishChunk = {\n            type: \"finish\",\n            finishReason: chunk.finishReason.unified,\n            rawFinishReason: chunk.finishReason.raw,\n            usage: asLanguageModelUsage(chunk.usage),\n            providerMetadata: chunk.providerMetadata\n          };\n          break;\n        }\n        case \"tool-approval-request\": {\n          const toolCall = toolCallsByToolCallId.get(chunk.toolCallId);\n          if (toolCall == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new ToolCallNotFoundForApprovalError({\n                toolCallId: chunk.toolCallId,\n                approvalId: chunk.approvalId\n              })\n            });\n            break;\n          }\n          controller.enqueue({\n            type: \"tool-approval-request\",\n            approvalId: chunk.approvalId,\n            toolCall\n          });\n          break;\n        }\n        case \"tool-call\": {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages\n            });\n            toolCallsByToolCallId.set(toolCall.toolCallId, toolCall);\n            controller.enqueue(toolCall);\n            if (toolCall.invalid) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-error\",\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage)(toolCall.error),\n                dynamic: true,\n                title: toolCall.title\n              });\n              break;\n            }\n            const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n            if (tool2 == null) {\n              break;\n            }\n            if (tool2.onInputAvailable != null) {\n              await tool2.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages,\n                abortSignal,\n                experimental_context\n              });\n            }\n            if (await isApprovalNeeded({\n              tool: tool2,\n              toolCall,\n              messages,\n              experimental_context\n            })) {\n              toolResultsStreamController.enqueue({\n                type: \"tool-approval-request\",\n                approvalId: generateId2(),\n                toolCall\n              });\n              break;\n            }\n            toolInputs.set(toolCall.toolCallId, toolCall.input);\n            if (tool2.execute != null && toolCall.providerExecuted !== true) {\n              const toolExecutionId = generateId2();\n              outstandingToolResults.add(toolExecutionId);\n              executeToolCall({\n                toolCall,\n                tools,\n                tracer,\n                telemetry,\n                messages,\n                abortSignal,\n                experimental_context,\n                onPreliminaryToolResult: (result) => {\n                  toolResultsStreamController.enqueue(result);\n                }\n              }).then((result) => {\n                toolResultsStreamController.enqueue(result);\n              }).catch((error) => {\n                toolResultsStreamController.enqueue({\n                  type: \"error\",\n                  error\n                });\n              }).finally(() => {\n                outstandingToolResults.delete(toolExecutionId);\n                attemptClose();\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({ type: \"error\", error });\n          }\n          break;\n        }\n        case \"tool-result\": {\n          const toolName = chunk.toolName;\n          if (chunk.isError) {\n            toolResultsStreamController.enqueue({\n              type: \"tool-error\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              providerExecuted: true,\n              error: chunk.result,\n              dynamic: chunk.dynamic\n            });\n          } else {\n            controller.enqueue({\n              type: \"tool-result\",\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              output: chunk.result,\n              providerExecuted: true,\n              dynamic: chunk.dynamic\n            });\n          }\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      attemptClose();\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// src/generate-text/stream-text.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({\n  prefix: \"aitxt\",\n  size: 24\n});\nfunction streamText({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  timeout,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output,\n  output = experimental_output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  experimental_download: download2,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({ error }) => {\n    console.error(error);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_context,\n  experimental_include: include,\n  _internal: { now: now2 = now, generateId: generateId2 = originalGenerateId2 } = {},\n  ...settings\n}) {\n  const totalTimeoutMs = getTotalTimeoutMs(timeout);\n  const stepTimeoutMs = getStepTimeoutMs(timeout);\n  const chunkTimeoutMs = getChunkTimeoutMs(timeout);\n  const stepAbortController = stepTimeoutMs != null ? new AbortController() : void 0;\n  const chunkAbortController = chunkTimeoutMs != null ? new AbortController() : void 0;\n  return new DefaultStreamTextResult({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal: mergeAbortSignals(\n      abortSignal,\n      totalTimeoutMs != null ? AbortSignal.timeout(totalTimeoutMs) : void 0,\n      stepAbortController == null ? void 0 : stepAbortController.signal,\n      chunkAbortController == null ? void 0 : chunkAbortController.signal\n    ),\n    stepTimeoutMs,\n    stepAbortController,\n    chunkTimeoutMs,\n    chunkAbortController,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    now: now2,\n    generateId: generateId2,\n    experimental_context,\n    download: download2,\n    include\n  });\n}\nfunction createOutputTransformStream(output) {\n  let firstTextChunkId = void 0;\n  let text2 = \"\";\n  let textChunk = \"\";\n  let textProviderMetadata = void 0;\n  let lastPublishedJson = \"\";\n  function publishTextChunk({\n    controller,\n    partialOutput = void 0\n  }) {\n    controller.enqueue({\n      part: {\n        type: \"text-delta\",\n        id: firstTextChunkId,\n        text: textChunk,\n        providerMetadata: textProviderMetadata\n      },\n      partialOutput\n    });\n    textChunk = \"\";\n  }\n  return new TransformStream({\n    async transform(chunk, controller) {\n      var _a21;\n      if (chunk.type === \"finish-step\" && textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n      if (chunk.type !== \"text-delta\" && chunk.type !== \"text-start\" && chunk.type !== \"text-end\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-start\") {\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      if (chunk.type === \"text-end\") {\n        if (textChunk.length > 0) {\n          publishTextChunk({ controller });\n        }\n        controller.enqueue({ part: chunk, partialOutput: void 0 });\n        return;\n      }\n      text2 += chunk.text;\n      textChunk += chunk.text;\n      textProviderMetadata = (_a21 = chunk.providerMetadata) != null ? _a21 : textProviderMetadata;\n      const result = await output.parsePartialOutput({ text: text2 });\n      if (result !== void 0) {\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    }\n  });\n}\nvar DefaultStreamTextResult = class {\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    stepTimeoutMs,\n    stepAbortController,\n    chunkTimeoutMs,\n    chunkAbortController,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now: now2,\n    generateId: generateId2,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    experimental_context,\n    download: download2,\n    include\n  }) {\n    this._totalUsage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._rawFinishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._steps = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this.outputSpecification = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n    let stepFinish;\n    let recordedContent = [];\n    const recordedResponseMessages = [];\n    let recordedFinishReason = void 0;\n    let recordedRawFinishReason = void 0;\n    let recordedTotalUsage = void 0;\n    let recordedRequest = {};\n    let recordedWarnings = [];\n    const recordedSteps = [];\n    const pendingDeferredToolCalls = /* @__PURE__ */ new Map();\n    let rootSpan;\n    let activeTextContent = {};\n    let activeReasoningContent = {};\n    const eventProcessor = new TransformStream({\n      async transform(chunk, controller) {\n        var _a21, _b, _c, _d;\n        controller.enqueue(chunk);\n        const { part } = chunk;\n        if (part.type === \"text-delta\" || part.type === \"reasoning-delta\" || part.type === \"source\" || part.type === \"tool-call\" || part.type === \"tool-result\" || part.type === \"tool-input-start\" || part.type === \"tool-input-delta\" || part.type === \"raw\") {\n          await (onChunk == null ? void 0 : onChunk({ chunk: part }));\n        }\n        if (part.type === \"error\") {\n          await onError({ error: wrapGatewayError(part.error) });\n        }\n        if (part.type === \"text-start\") {\n          activeTextContent[part.id] = {\n            type: \"text\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeTextContent[part.id]);\n        }\n        if (part.type === \"text-delta\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.text += part.text;\n          activeText.providerMetadata = (_a21 = part.providerMetadata) != null ? _a21 : activeText.providerMetadata;\n        }\n        if (part.type === \"text-end\") {\n          const activeText = activeTextContent[part.id];\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `text part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeText.providerMetadata = (_b = part.providerMetadata) != null ? _b : activeText.providerMetadata;\n          delete activeTextContent[part.id];\n        }\n        if (part.type === \"reasoning-start\") {\n          activeReasoningContent[part.id] = {\n            type: \"reasoning\",\n            text: \"\",\n            providerMetadata: part.providerMetadata\n          };\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n        if (part.type === \"reasoning-delta\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata = (_c = part.providerMetadata) != null ? _c : activeReasoning.providerMetadata;\n        }\n        if (part.type === \"reasoning-end\") {\n          const activeReasoning = activeReasoningContent[part.id];\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: \"error\",\n                error: `reasoning part ${part.id} not found`\n              },\n              partialOutput: void 0\n            });\n            return;\n          }\n          activeReasoning.providerMetadata = (_d = part.providerMetadata) != null ? _d : activeReasoning.providerMetadata;\n          delete activeReasoningContent[part.id];\n        }\n        if (part.type === \"file\") {\n          recordedContent.push({ type: \"file\", file: part.file });\n        }\n        if (part.type === \"source\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-call\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-result\" && !part.preliminary) {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-approval-request\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"tool-error\") {\n          recordedContent.push(part);\n        }\n        if (part.type === \"start-step\") {\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n        if (part.type === \"finish-step\") {\n          const stepMessages = await toResponseMessages({\n            content: recordedContent,\n            tools\n          });\n          const currentStepResult = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            rawFinishReason: part.rawFinishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages]\n            },\n            providerMetadata: part.providerMetadata\n          });\n          await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n          logWarnings({\n            warnings: recordedWarnings,\n            provider: model.provider,\n            model: model.modelId\n          });\n          recordedSteps.push(currentStepResult);\n          recordedResponseMessages.push(...stepMessages);\n          stepFinish.resolve();\n        }\n        if (part.type === \"finish\") {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n          recordedRawFinishReason = part.rawFinishReason;\n        }\n      },\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error = (abortSignal == null ? void 0 : abortSignal.aborted) ? abortSignal.reason : new NoOutputGeneratedError({\n              message: \"No output generated. Check the stream for errors.\"\n            });\n            self._finishReason.reject(error);\n            self._rawFinishReason.reject(error);\n            self._totalUsage.reject(error);\n            self._steps.reject(error);\n            return;\n          }\n          const finishReason = recordedFinishReason != null ? recordedFinishReason : \"other\";\n          const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : createNullLanguageModelUsage();\n          self._finishReason.resolve(finishReason);\n          self._rawFinishReason.resolve(recordedRawFinishReason);\n          self._totalUsage.resolve(totalUsage);\n          self._steps.resolve(recordedSteps);\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await (onFinish == null ? void 0 : onFinish({\n            finishReason: finalStep.finishReason,\n            rawFinishReason: finalStep.rawFinishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps,\n            experimental_context\n          }));\n          rootSpan.setAttributes(\n            await selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                \"ai.response.finishReason\": finishReason,\n                \"ai.response.text\": { output: () => finalStep.text },\n                \"ai.response.toolCalls\": {\n                  output: () => {\n                    var _a21;\n                    return ((_a21 = finalStep.toolCalls) == null ? void 0 : _a21.length) ? JSON.stringify(finalStep.toolCalls) : void 0;\n                  }\n                },\n                \"ai.response.providerMetadata\": JSON.stringify(\n                  finalStep.providerMetadata\n                ),\n                \"ai.usage.inputTokens\": totalUsage.inputTokens,\n                \"ai.usage.outputTokens\": totalUsage.outputTokens,\n                \"ai.usage.totalTokens\": totalUsage.totalTokens,\n                \"ai.usage.reasoningTokens\": totalUsage.reasoningTokens,\n                \"ai.usage.cachedInputTokens\": totalUsage.cachedInputTokens\n              }\n            })\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      }\n    });\n    const stitchableStream = createStitchableStream();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream({\n      async start(controller) {\n        controller.enqueue({ type: \"start\" });\n      },\n      async pull(controller) {\n        function abort() {\n          onAbort == null ? void 0 : onAbort({ steps: recordedSteps });\n          controller.enqueue({\n            type: \"abort\",\n            // The `reason` is usually of type DOMException, but it can also be of any type,\n            // so we use getErrorMessage for serialization because it is already designed to accept values of the unknown type.\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/reason\n            ...(abortSignal == null ? void 0 : abortSignal.reason) !== void 0 ? { reason: (0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(abortSignal.reason) } : {}\n          });\n          controller.close();\n        }\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            controller.close();\n            return;\n          }\n          if (abortSignal == null ? void 0 : abortSignal.aborted) {\n            abort();\n            return;\n          }\n          controller.enqueue(value);\n        } catch (error) {\n          if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isAbortError)(error) && (abortSignal == null ? void 0 : abortSignal.aborted)) {\n            abort();\n          } else {\n            controller.error(error);\n          }\n        }\n      },\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      }\n    });\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools,\n          stopStream() {\n            stitchableStream.terminate();\n          }\n        })\n      );\n    }\n    this.baseStream = stream.pipeThrough(createOutputTransformStream(output != null ? output : text())).pipeThrough(eventProcessor);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const tracer = getTracer(telemetry);\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const self = this;\n    recordSpan({\n      name: \"ai.streamText\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: \"ai.streamText\", telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          }\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpanArg) => {\n        rootSpan = rootSpanArg;\n        const initialPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const initialMessages = initialPrompt.messages;\n        const initialResponseMessages = [];\n        const { approvedToolApprovals, deniedToolApprovals } = collectToolApprovals({ messages: initialMessages });\n        if (deniedToolApprovals.length > 0 || approvedToolApprovals.length > 0) {\n          const providerExecutedToolApprovals = [\n            ...approvedToolApprovals,\n            ...deniedToolApprovals\n          ].filter((toolApproval) => toolApproval.toolCall.providerExecuted);\n          const localApprovedToolApprovals = approvedToolApprovals.filter(\n            (toolApproval) => !toolApproval.toolCall.providerExecuted\n          );\n          const localDeniedToolApprovals = deniedToolApprovals.filter(\n            (toolApproval) => !toolApproval.toolCall.providerExecuted\n          );\n          const deniedProviderExecutedToolApprovals = deniedToolApprovals.filter(\n            (toolApproval) => toolApproval.toolCall.providerExecuted\n          );\n          let toolExecutionStepStreamController;\n          const toolExecutionStepStream = new ReadableStream({\n            start(controller) {\n              toolExecutionStepStreamController = controller;\n            }\n          });\n          self.addStream(toolExecutionStepStream);\n          try {\n            for (const toolApproval of [\n              ...localDeniedToolApprovals,\n              ...deniedProviderExecutedToolApprovals\n            ]) {\n              toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue({\n                type: \"tool-output-denied\",\n                toolCallId: toolApproval.toolCall.toolCallId,\n                toolName: toolApproval.toolCall.toolName\n              });\n            }\n            const toolOutputs = [];\n            await Promise.all(\n              localApprovedToolApprovals.map(async (toolApproval) => {\n                const result = await executeToolCall({\n                  toolCall: toolApproval.toolCall,\n                  tools,\n                  tracer,\n                  telemetry,\n                  messages: initialMessages,\n                  abortSignal,\n                  experimental_context,\n                  onPreliminaryToolResult: (result2) => {\n                    toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result2);\n                  }\n                });\n                if (result != null) {\n                  toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.enqueue(result);\n                  toolOutputs.push(result);\n                }\n              })\n            );\n            if (providerExecutedToolApprovals.length > 0) {\n              initialResponseMessages.push({\n                role: \"tool\",\n                content: providerExecutedToolApprovals.map(\n                  (toolApproval) => ({\n                    type: \"tool-approval-response\",\n                    approvalId: toolApproval.approvalResponse.approvalId,\n                    approved: toolApproval.approvalResponse.approved,\n                    reason: toolApproval.approvalResponse.reason,\n                    providerExecuted: true\n                  })\n                )\n              });\n            }\n            if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {\n              const localToolContent = [];\n              for (const output2 of toolOutputs) {\n                localToolContent.push({\n                  type: \"tool-result\",\n                  toolCallId: output2.toolCallId,\n                  toolName: output2.toolName,\n                  output: await createToolModelOutput({\n                    toolCallId: output2.toolCallId,\n                    input: output2.input,\n                    tool: tools == null ? void 0 : tools[output2.toolName],\n                    output: output2.type === \"tool-result\" ? output2.output : output2.error,\n                    errorMode: output2.type === \"tool-error\" ? \"json\" : \"none\"\n                  })\n                });\n              }\n              for (const toolApproval of localDeniedToolApprovals) {\n                localToolContent.push({\n                  type: \"tool-result\",\n                  toolCallId: toolApproval.toolCall.toolCallId,\n                  toolName: toolApproval.toolCall.toolName,\n                  output: {\n                    type: \"execution-denied\",\n                    reason: toolApproval.approvalResponse.reason\n                  }\n                });\n              }\n              initialResponseMessages.push({\n                role: \"tool\",\n                content: localToolContent\n              });\n            }\n          } finally {\n            toolExecutionStepStreamController == null ? void 0 : toolExecutionStepStreamController.close();\n          }\n        }\n        recordedResponseMessages.push(...initialResponseMessages);\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage\n        }) {\n          var _a21, _b, _c, _d, _e, _f, _g;\n          const includeRawChunks2 = self.includeRawChunks;\n          const stepTimeoutId = stepTimeoutMs != null ? setTimeout(() => stepAbortController.abort(), stepTimeoutMs) : void 0;\n          let chunkTimeoutId = void 0;\n          function resetChunkTimeout() {\n            if (chunkTimeoutMs != null) {\n              if (chunkTimeoutId != null) {\n                clearTimeout(chunkTimeoutId);\n              }\n              chunkTimeoutId = setTimeout(\n                () => chunkAbortController.abort(),\n                chunkTimeoutMs\n              );\n            }\n          }\n          function clearChunkTimeout() {\n            if (chunkTimeoutId != null) {\n              clearTimeout(chunkTimeoutId);\n              chunkTimeoutId = void 0;\n            }\n          }\n          function clearStepTimeout() {\n            if (stepTimeoutId != null) {\n              clearTimeout(stepTimeoutId);\n            }\n          }\n          try {\n            stepFinish = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n            const stepInputMessages = [...initialMessages, ...responseMessages];\n            const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({\n              model,\n              steps: recordedSteps,\n              stepNumber: recordedSteps.length,\n              messages: stepInputMessages,\n              experimental_context\n            }));\n            const stepModel = resolveLanguageModel(\n              (_a21 = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _a21 : model\n            );\n            const promptMessages = await convertToLanguageModelPrompt({\n              prompt: {\n                system: (_b = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _b : initialPrompt.system,\n                messages: (_c = prepareStepResult == null ? void 0 : prepareStepResult.messages) != null ? _c : stepInputMessages\n              },\n              supportedUrls: await stepModel.supportedUrls,\n              download: download2\n            });\n            const { toolChoice: stepToolChoice, tools: stepTools } = await prepareToolsAndToolChoice({\n              tools,\n              toolChoice: (_d = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _d : toolChoice,\n              activeTools: (_e = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _e : activeTools\n            });\n            experimental_context = (_f = prepareStepResult == null ? void 0 : prepareStepResult.experimental_context) != null ? _f : experimental_context;\n            const stepProviderOptions = mergeObjects(\n              providerOptions,\n              prepareStepResult == null ? void 0 : prepareStepResult.providerOptions\n            );\n            const {\n              result: { stream: stream2, response, request },\n              doStreamSpan,\n              startTimestampMs\n            } = await retry(\n              () => recordSpan({\n                name: \"ai.streamText.doStream\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.streamText.doStream\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // model:\n                    \"ai.model.provider\": stepModel.provider,\n                    \"ai.model.id\": stepModel.modelId,\n                    // prompt:\n                    \"ai.prompt.messages\": {\n                      input: () => stringifyForTelemetry(promptMessages)\n                    },\n                    \"ai.prompt.tools\": {\n                      // convert the language model level tools:\n                      input: () => stepTools == null ? void 0 : stepTools.map((tool2) => JSON.stringify(tool2))\n                    },\n                    \"ai.prompt.toolChoice\": {\n                      input: () => stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0\n                    },\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.system\": stepModel.provider,\n                    \"gen_ai.request.model\": stepModel.modelId,\n                    \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                    \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                    \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                    \"gen_ai.request.stop_sequences\": callSettings.stopSequences,\n                    \"gen_ai.request.temperature\": callSettings.temperature,\n                    \"gen_ai.request.top_k\": callSettings.topK,\n                    \"gen_ai.request.top_p\": callSettings.topP\n                  }\n                }),\n                tracer,\n                endWhenDone: false,\n                fn: async (doStreamSpan2) => ({\n                  startTimestampMs: now2(),\n                  // get before the call\n                  doStreamSpan: doStreamSpan2,\n                  result: await stepModel.doStream({\n                    ...callSettings,\n                    tools: stepTools,\n                    toolChoice: stepToolChoice,\n                    responseFormat: await (output == null ? void 0 : output.responseFormat),\n                    prompt: promptMessages,\n                    providerOptions: stepProviderOptions,\n                    abortSignal,\n                    headers,\n                    includeRawChunks: includeRawChunks2\n                  })\n                })\n              })\n            );\n            const streamWithToolResults = runToolsTransformation({\n              tools,\n              generatorStream: stream2,\n              tracer,\n              telemetry,\n              system,\n              messages: stepInputMessages,\n              repairToolCall,\n              abortSignal,\n              experimental_context,\n              generateId: generateId2\n            });\n            const stepRequest = ((_g = include == null ? void 0 : include.requestBody) != null ? _g : true) ? request != null ? request : {} : { ...request, body: void 0 };\n            const stepToolCalls = [];\n            const stepToolOutputs = [];\n            let warnings;\n            const activeToolCallToolNames = {};\n            let stepFinishReason = \"other\";\n            let stepRawFinishReason = void 0;\n            let stepUsage = createNullLanguageModelUsage();\n            let stepProviderMetadata;\n            let stepFirstChunk = true;\n            let stepResponse = {\n              id: generateId2(),\n              timestamp: /* @__PURE__ */ new Date(),\n              modelId: model.modelId\n            };\n            let activeText = \"\";\n            self.addStream(\n              streamWithToolResults.pipeThrough(\n                new TransformStream({\n                  async transform(chunk, controller) {\n                    var _a22, _b2, _c2, _d2, _e2;\n                    resetChunkTimeout();\n                    if (chunk.type === \"stream-start\") {\n                      warnings = chunk.warnings;\n                      return;\n                    }\n                    if (stepFirstChunk) {\n                      const msToFirstChunk = now2() - startTimestampMs;\n                      stepFirstChunk = false;\n                      doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                        \"ai.response.msToFirstChunk\": msToFirstChunk\n                      });\n                      doStreamSpan.setAttributes({\n                        \"ai.response.msToFirstChunk\": msToFirstChunk\n                      });\n                      controller.enqueue({\n                        type: \"start-step\",\n                        request: stepRequest,\n                        warnings: warnings != null ? warnings : []\n                      });\n                    }\n                    const chunkType = chunk.type;\n                    switch (chunkType) {\n                      case \"tool-approval-request\":\n                      case \"text-start\":\n                      case \"text-end\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"text-delta\": {\n                        if (chunk.delta.length > 0) {\n                          controller.enqueue({\n                            type: \"text-delta\",\n                            id: chunk.id,\n                            text: chunk.delta,\n                            providerMetadata: chunk.providerMetadata\n                          });\n                          activeText += chunk.delta;\n                        }\n                        break;\n                      }\n                      case \"reasoning-start\":\n                      case \"reasoning-end\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"reasoning-delta\": {\n                        controller.enqueue({\n                          type: \"reasoning-delta\",\n                          id: chunk.id,\n                          text: chunk.delta,\n                          providerMetadata: chunk.providerMetadata\n                        });\n                        break;\n                      }\n                      case \"tool-call\": {\n                        controller.enqueue(chunk);\n                        stepToolCalls.push(chunk);\n                        break;\n                      }\n                      case \"tool-result\": {\n                        controller.enqueue(chunk);\n                        if (!chunk.preliminary) {\n                          stepToolOutputs.push(chunk);\n                        }\n                        break;\n                      }\n                      case \"tool-error\": {\n                        controller.enqueue(chunk);\n                        stepToolOutputs.push(chunk);\n                        break;\n                      }\n                      case \"response-metadata\": {\n                        stepResponse = {\n                          id: (_a22 = chunk.id) != null ? _a22 : stepResponse.id,\n                          timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,\n                          modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId\n                        };\n                        break;\n                      }\n                      case \"finish\": {\n                        stepUsage = chunk.usage;\n                        stepFinishReason = chunk.finishReason;\n                        stepRawFinishReason = chunk.rawFinishReason;\n                        stepProviderMetadata = chunk.providerMetadata;\n                        const msToFinish = now2() - startTimestampMs;\n                        doStreamSpan.addEvent(\"ai.stream.finish\");\n                        doStreamSpan.setAttributes({\n                          \"ai.response.msToFinish\": msToFinish,\n                          \"ai.response.avgOutputTokensPerSecond\": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish\n                        });\n                        break;\n                      }\n                      case \"file\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"source\": {\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"tool-input-start\": {\n                        activeToolCallToolNames[chunk.id] = chunk.toolName;\n                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];\n                        if ((tool2 == null ? void 0 : tool2.onInputStart) != null) {\n                          await tool2.onInputStart({\n                            toolCallId: chunk.id,\n                            messages: stepInputMessages,\n                            abortSignal,\n                            experimental_context\n                          });\n                        }\n                        controller.enqueue({\n                          ...chunk,\n                          dynamic: (_e2 = chunk.dynamic) != null ? _e2 : (tool2 == null ? void 0 : tool2.type) === \"dynamic\",\n                          title: tool2 == null ? void 0 : tool2.title\n                        });\n                        break;\n                      }\n                      case \"tool-input-end\": {\n                        delete activeToolCallToolNames[chunk.id];\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"tool-input-delta\": {\n                        const toolName = activeToolCallToolNames[chunk.id];\n                        const tool2 = tools == null ? void 0 : tools[toolName];\n                        if ((tool2 == null ? void 0 : tool2.onInputDelta) != null) {\n                          await tool2.onInputDelta({\n                            inputTextDelta: chunk.delta,\n                            toolCallId: chunk.id,\n                            messages: stepInputMessages,\n                            abortSignal,\n                            experimental_context\n                          });\n                        }\n                        controller.enqueue(chunk);\n                        break;\n                      }\n                      case \"error\": {\n                        controller.enqueue(chunk);\n                        stepFinishReason = \"error\";\n                        break;\n                      }\n                      case \"raw\": {\n                        if (includeRawChunks2) {\n                          controller.enqueue(chunk);\n                        }\n                        break;\n                      }\n                      default: {\n                        const exhaustiveCheck = chunkType;\n                        throw new Error(\n                          `Unknown chunk type: ${exhaustiveCheck}`\n                        );\n                      }\n                    }\n                  },\n                  // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                  async flush(controller) {\n                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                    try {\n                      doStreamSpan.setAttributes(\n                        await selectTelemetryAttributes({\n                          telemetry,\n                          attributes: {\n                            \"ai.response.finishReason\": stepFinishReason,\n                            \"ai.response.text\": {\n                              output: () => activeText\n                            },\n                            \"ai.response.toolCalls\": {\n                              output: () => stepToolCallsJson\n                            },\n                            \"ai.response.id\": stepResponse.id,\n                            \"ai.response.model\": stepResponse.modelId,\n                            \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                            \"ai.response.providerMetadata\": JSON.stringify(stepProviderMetadata),\n                            \"ai.usage.inputTokens\": stepUsage.inputTokens,\n                            \"ai.usage.outputTokens\": stepUsage.outputTokens,\n                            \"ai.usage.totalTokens\": stepUsage.totalTokens,\n                            \"ai.usage.reasoningTokens\": stepUsage.reasoningTokens,\n                            \"ai.usage.cachedInputTokens\": stepUsage.cachedInputTokens,\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.response.finish_reasons\": [\n                              stepFinishReason\n                            ],\n                            \"gen_ai.response.id\": stepResponse.id,\n                            \"gen_ai.response.model\": stepResponse.modelId,\n                            \"gen_ai.usage.input_tokens\": stepUsage.inputTokens,\n                            \"gen_ai.usage.output_tokens\": stepUsage.outputTokens\n                          }\n                        })\n                      );\n                    } catch (error) {\n                    } finally {\n                      doStreamSpan.end();\n                    }\n                    controller.enqueue({\n                      type: \"finish-step\",\n                      finishReason: stepFinishReason,\n                      rawFinishReason: stepRawFinishReason,\n                      usage: stepUsage,\n                      providerMetadata: stepProviderMetadata,\n                      response: {\n                        ...stepResponse,\n                        headers: response == null ? void 0 : response.headers\n                      }\n                    });\n                    const combinedUsage = addLanguageModelUsage(\n                      usage,\n                      stepUsage\n                    );\n                    await stepFinish.promise;\n                    const clientToolCalls = stepToolCalls.filter(\n                      (toolCall) => toolCall.providerExecuted !== true\n                    );\n                    const clientToolOutputs = stepToolOutputs.filter(\n                      (toolOutput) => toolOutput.providerExecuted !== true\n                    );\n                    for (const toolCall of stepToolCalls) {\n                      if (toolCall.providerExecuted !== true)\n                        continue;\n                      const tool2 = tools == null ? void 0 : tools[toolCall.toolName];\n                      if ((tool2 == null ? void 0 : tool2.type) === \"provider\" && tool2.supportsDeferredResults) {\n                        const hasResultInStep = stepToolOutputs.some(\n                          (output2) => (output2.type === \"tool-result\" || output2.type === \"tool-error\") && output2.toolCallId === toolCall.toolCallId\n                        );\n                        if (!hasResultInStep) {\n                          pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                            toolName: toolCall.toolName\n                          });\n                        }\n                      }\n                    }\n                    for (const output2 of stepToolOutputs) {\n                      if (output2.type === \"tool-result\" || output2.type === \"tool-error\") {\n                        pendingDeferredToolCalls.delete(output2.toolCallId);\n                      }\n                    }\n                    clearStepTimeout();\n                    clearChunkTimeout();\n                    if (\n                      // Continue if:\n                      // 1. There are client tool calls that have all been executed, OR\n                      // 2. There are pending deferred results from provider-executed tools\n                      (clientToolCalls.length > 0 && clientToolOutputs.length === clientToolCalls.length || pendingDeferredToolCalls.size > 0) && // continue until a stop condition is met:\n                      !await isStopConditionMet({\n                        stopConditions,\n                        steps: recordedSteps\n                      })\n                    ) {\n                      responseMessages.push(\n                        ...await toResponseMessages({\n                          content: (\n                            // use transformed content to create the messages for the next step:\n                            recordedSteps[recordedSteps.length - 1].content\n                          ),\n                          tools\n                        })\n                      );\n                      try {\n                        await streamStep({\n                          currentStep: currentStep + 1,\n                          responseMessages,\n                          usage: combinedUsage\n                        });\n                      } catch (error) {\n                        controller.enqueue({\n                          type: \"error\",\n                          error\n                        });\n                        self.closeStream();\n                      }\n                    } else {\n                      controller.enqueue({\n                        type: \"finish\",\n                        finishReason: stepFinishReason,\n                        rawFinishReason: stepRawFinishReason,\n                        totalUsage: combinedUsage\n                      });\n                      self.closeStream();\n                    }\n                  }\n                })\n              )\n            );\n          } finally {\n            clearStepTimeout();\n            clearChunkTimeout();\n          }\n        }\n        await streamStep({\n          currentStep: 0,\n          responseMessages: initialResponseMessages,\n          usage: createNullLanguageModelUsage()\n        });\n      }\n    }).catch((error) => {\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n      self.closeStream();\n    });\n  }\n  get steps() {\n    this.consumeStream();\n    return this._steps.promise;\n  }\n  get finalStep() {\n    return this.steps.then((steps) => steps[steps.length - 1]);\n  }\n  get content() {\n    return this.finalStep.then((step) => step.content);\n  }\n  get warnings() {\n    return this.finalStep.then((step) => step.warnings);\n  }\n  get providerMetadata() {\n    return this.finalStep.then((step) => step.providerMetadata);\n  }\n  get text() {\n    return this.finalStep.then((step) => step.text);\n  }\n  get reasoningText() {\n    return this.finalStep.then((step) => step.reasoningText);\n  }\n  get reasoning() {\n    return this.finalStep.then((step) => step.reasoning);\n  }\n  get sources() {\n    return this.finalStep.then((step) => step.sources);\n  }\n  get files() {\n    return this.finalStep.then((step) => step.files);\n  }\n  get toolCalls() {\n    return this.finalStep.then((step) => step.toolCalls);\n  }\n  get staticToolCalls() {\n    return this.finalStep.then((step) => step.staticToolCalls);\n  }\n  get dynamicToolCalls() {\n    return this.finalStep.then((step) => step.dynamicToolCalls);\n  }\n  get toolResults() {\n    return this.finalStep.then((step) => step.toolResults);\n  }\n  get staticToolResults() {\n    return this.finalStep.then((step) => step.staticToolResults);\n  }\n  get dynamicToolResults() {\n    return this.finalStep.then((step) => step.dynamicToolResults);\n  }\n  get usage() {\n    return this.finalStep.then((step) => step.usage);\n  }\n  get request() {\n    return this.finalStep.then((step) => step.request);\n  }\n  get response() {\n    return this.finalStep.then((step) => step.response);\n  }\n  get totalUsage() {\n    this.consumeStream();\n    return this._totalUsage.promise;\n  }\n  get finishReason() {\n    this.consumeStream();\n    return this._finishReason.promise;\n  }\n  get rawFinishReason() {\n    this.consumeStream();\n    return this._rawFinishReason.promise;\n  }\n  /**\n   * Split out a new stream from the original stream.\n   * The original stream is replaced to allow for further splitting,\n   * since we do not know how many times the stream will be split.\n   *\n   * Note: this leads to buffering the stream content on the server.\n   * However, the LLM results are expected to be small enough to not cause issues.\n   */\n  teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            if (part.type === \"text-delta\") {\n              controller.enqueue(part.text);\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          }\n        })\n      )\n    );\n  }\n  async consumeStream(options) {\n    var _a21;\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options == null ? void 0 : options.onError\n      });\n    } catch (error) {\n      (_a21 = options == null ? void 0 : options.onError) == null ? void 0 : _a21.call(options, error);\n    }\n  }\n  get experimental_partialOutputStream() {\n    return this.partialOutputStream;\n  }\n  get partialOutputStream() {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    var _a21, _b, _c;\n    const transform = (_a21 = this.outputSpecification) == null ? void 0 : _a21.createElementStreamTransform();\n    if (transform == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: `element streams in ${(_c = (_b = this.outputSpecification) == null ? void 0 : _b.name) != null ? _c : \"text\"} mode`\n      });\n    }\n    return createAsyncIterableStream(this.teeStream().pipeThrough(transform));\n  }\n  get output() {\n    return this.finalStep.then((step) => {\n      var _a21;\n      const output = (_a21 = this.outputSpecification) != null ? _a21 : text();\n      return output.parseCompleteOutput(\n        { text: step.text },\n        {\n          response: step.response,\n          usage: step.usage,\n          finishReason: step.finishReason\n        }\n      );\n    });\n  }\n  toUIMessageStream({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage\n  } = {}) {\n    const responseMessageId = generateMessageId != null ? getResponseUIMessageId({\n      originalMessages,\n      responseMessageId: generateMessageId\n    }) : void 0;\n    const isDynamic = (part) => {\n      var _a21;\n      const tool2 = (_a21 = this.tools) == null ? void 0 : _a21[part.toolName];\n      if (tool2 == null) {\n        return part.dynamic;\n      }\n      return (tool2 == null ? void 0 : tool2.type) === \"dynamic\" ? true : void 0;\n    };\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream({\n        transform: async (part, controller) => {\n          const messageMetadataValue = messageMetadata == null ? void 0 : messageMetadata({ part });\n          const partType = part.type;\n          switch (partType) {\n            case \"text-start\": {\n              controller.enqueue({\n                type: \"text-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-delta\": {\n              controller.enqueue({\n                type: \"text-delta\",\n                id: part.id,\n                delta: part.text,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"text-end\": {\n              controller.enqueue({\n                type: \"text-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-start\": {\n              controller.enqueue({\n                type: \"reasoning-start\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"reasoning-delta\": {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: part.id,\n                  delta: part.text,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"reasoning-end\": {\n              controller.enqueue({\n                type: \"reasoning-end\",\n                id: part.id,\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n              });\n              break;\n            }\n            case \"file\": {\n              controller.enqueue({\n                type: \"file\",\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`\n              });\n              break;\n            }\n            case \"source\": {\n              if (sendSources && part.sourceType === \"url\") {\n                controller.enqueue({\n                  type: \"source-url\",\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              if (sendSources && part.sourceType === \"document\") {\n                controller.enqueue({\n                  type: \"source-document\",\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-input-start\": {\n              const dynamic = isDynamic(part);\n              controller.enqueue({\n                type: \"tool-input-start\",\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                ...dynamic != null ? { dynamic } : {},\n                ...part.title != null ? { title: part.title } : {}\n              });\n              break;\n            }\n            case \"tool-input-delta\": {\n              controller.enqueue({\n                type: \"tool-input-delta\",\n                toolCallId: part.id,\n                inputTextDelta: part.delta\n              });\n              break;\n            }\n            case \"tool-call\": {\n              const dynamic = isDynamic(part);\n              if (part.invalid) {\n                controller.enqueue({\n                  type: \"tool-input-error\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  errorText: onError(part.error),\n                  ...part.title != null ? { title: part.title } : {}\n                });\n              } else {\n                controller.enqueue({\n                  type: \"tool-input-available\",\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                  ...part.providerMetadata != null ? { providerMetadata: part.providerMetadata } : {},\n                  ...dynamic != null ? { dynamic } : {},\n                  ...part.title != null ? { title: part.title } : {}\n                });\n              }\n              break;\n            }\n            case \"tool-approval-request\": {\n              controller.enqueue({\n                type: \"tool-approval-request\",\n                approvalId: part.approvalId,\n                toolCallId: part.toolCall.toolCallId\n              });\n              break;\n            }\n            case \"tool-result\": {\n              const dynamic = isDynamic(part);\n              controller.enqueue({\n                type: \"tool-output-available\",\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...part.preliminary != null ? { preliminary: part.preliminary } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-error\": {\n              const dynamic = isDynamic(part);\n              controller.enqueue({\n                type: \"tool-output-error\",\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...part.providerExecuted != null ? { providerExecuted: part.providerExecuted } : {},\n                ...dynamic != null ? { dynamic } : {}\n              });\n              break;\n            }\n            case \"tool-output-denied\": {\n              controller.enqueue({\n                type: \"tool-output-denied\",\n                toolCallId: part.toolCallId\n              });\n              break;\n            }\n            case \"error\": {\n              controller.enqueue({\n                type: \"error\",\n                errorText: onError(part.error)\n              });\n              break;\n            }\n            case \"start-step\": {\n              controller.enqueue({ type: \"start-step\" });\n              break;\n            }\n            case \"finish-step\": {\n              controller.enqueue({ type: \"finish-step\" });\n              break;\n            }\n            case \"start\": {\n              if (sendStart) {\n                controller.enqueue({\n                  type: \"start\",\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {},\n                  ...responseMessageId != null ? { messageId: responseMessageId } : {}\n                });\n              }\n              break;\n            }\n            case \"finish\": {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: \"finish\",\n                  finishReason: part.finishReason,\n                  ...messageMetadataValue != null ? { messageMetadata: messageMetadataValue } : {}\n                });\n              }\n              break;\n            }\n            case \"abort\": {\n              controller.enqueue(part);\n              break;\n            }\n            case \"tool-input-end\": {\n              break;\n            }\n            case \"raw\": {\n              break;\n            }\n            default: {\n              const exhaustiveCheck = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n          if (messageMetadataValue != null && partType !== \"start\" && partType !== \"finish\") {\n            controller.enqueue({\n              type: \"message-metadata\",\n              messageMetadata: messageMetadataValue\n            });\n          }\n        }\n      })\n    );\n    return createAsyncIterableStream(\n      handleUIMessageStreamFinish({\n        stream: baseStream,\n        messageId: responseMessageId != null ? responseMessageId : generateMessageId == null ? void 0 : generateMessageId(),\n        originalMessages,\n        onFinish,\n        onError\n      })\n    );\n  }\n  pipeUIMessageStreamToResponse(response, {\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toUIMessageStreamResponse({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  } = {}) {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError\n      }),\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/agent/tool-loop-agent.ts\nvar ToolLoopAgent = class {\n  constructor(settings) {\n    this.version = \"agent-v1\";\n    this.settings = settings;\n  }\n  /**\n   * The id of the agent.\n   */\n  get id() {\n    return this.settings.id;\n  }\n  /**\n   * The tools that the agent can use.\n   */\n  get tools() {\n    return this.settings.tools;\n  }\n  async prepareCall(options) {\n    var _a21, _b, _c, _d;\n    const { onStepFinish: _settingsOnStepFinish, ...settingsWithoutCallback } = this.settings;\n    const baseCallArgs = {\n      ...settingsWithoutCallback,\n      stopWhen: (_a21 = this.settings.stopWhen) != null ? _a21 : stepCountIs(20),\n      ...options\n    };\n    const preparedCallArgs = (_d = await ((_c = (_b = this.settings).prepareCall) == null ? void 0 : _c.call(\n      _b,\n      baseCallArgs\n    ))) != null ? _d : baseCallArgs;\n    const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;\n    return {\n      ...callArgs,\n      // restore prompt types\n      ...{ system: instructions, messages, prompt }\n    };\n  }\n  mergeOnStepFinishCallbacks(methodCallback) {\n    const constructorCallback = this.settings.onStepFinish;\n    if (methodCallback && constructorCallback) {\n      return async (stepResult) => {\n        await constructorCallback(stepResult);\n        await methodCallback(stepResult);\n      };\n    }\n    return methodCallback != null ? methodCallback : constructorCallback;\n  }\n  /**\n   * Generates an output from the agent (non-streaming).\n   */\n  async generate({\n    abortSignal,\n    timeout,\n    onStepFinish,\n    ...options\n  }) {\n    return generateText({\n      ...await this.prepareCall(options),\n      abortSignal,\n      timeout,\n      onStepFinish: this.mergeOnStepFinishCallbacks(onStepFinish)\n    });\n  }\n  /**\n   * Streams an output from the agent (streaming).\n   */\n  async stream({\n    abortSignal,\n    timeout,\n    experimental_transform,\n    onStepFinish,\n    ...options\n  }) {\n    return streamText({\n      ...await this.prepareCall(options),\n      abortSignal,\n      timeout,\n      experimental_transform,\n      onStepFinish: this.mergeOnStepFinishCallbacks(onStepFinish)\n    });\n  }\n};\n\n// src/ui-message-stream/create-ui-message-stream.ts\n\nfunction createUIMessageStream({\n  execute,\n  onError = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getErrorMessage,\n  originalMessages,\n  onFinish,\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId\n}) {\n  let controller;\n  const ongoingStreamPromises = [];\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    }\n  });\n  function safeEnqueue(data) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n    }\n  }\n  try {\n    const result = execute({\n      writer: {\n        write(part) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push(\n            (async () => {\n              const reader = streamArg.getReader();\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done)\n                  break;\n                safeEnqueue(value);\n              }\n            })().catch((error) => {\n              safeEnqueue({\n                type: \"error\",\n                errorText: onError(error)\n              });\n            })\n          );\n        },\n        onError\n      }\n    });\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch((error) => {\n          safeEnqueue({\n            type: \"error\",\n            errorText: onError(error)\n          });\n        })\n      );\n    }\n  } catch (error) {\n    safeEnqueue({\n      type: \"error\",\n      errorText: onError(error)\n    });\n  }\n  const waitForStreams = new Promise(async (resolve3) => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve3();\n  });\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n    }\n  });\n  return handleUIMessageStreamFinish({\n    stream,\n    messageId: generateId2(),\n    originalMessages,\n    onFinish,\n    onError\n  });\n}\n\n// src/ui-message-stream/read-ui-message-stream.ts\nfunction readUIMessageStream({\n  message,\n  stream,\n  onError,\n  terminateOnError = false\n}) {\n  var _a21;\n  let controller;\n  let hasErrored = false;\n  const outputStream = new ReadableStream({\n    start(controllerParam) {\n      controller = controllerParam;\n    }\n  });\n  const state = createStreamingUIMessageState({\n    messageId: (_a21 = message == null ? void 0 : message.id) != null ? _a21 : \"\",\n    lastMessage: message\n  });\n  const handleError = (error) => {\n    onError == null ? void 0 : onError(error);\n    if (!hasErrored && terminateOnError) {\n      hasErrored = true;\n      controller == null ? void 0 : controller.error(error);\n    }\n  };\n  consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      runUpdateMessageJob(job) {\n        return job({\n          state,\n          write: () => {\n            controller == null ? void 0 : controller.enqueue(structuredClone(state.message));\n          }\n        });\n      },\n      onError: handleError\n    }),\n    onError: handleError\n  }).finally(() => {\n    if (!hasErrored) {\n      controller == null ? void 0 : controller.close();\n    }\n  });\n  return createAsyncIterableStream(outputStream);\n}\n\n// src/ui/convert-to-model-messages.ts\n\nasync function convertToModelMessages(messages, options) {\n  const modelMessages = [];\n  if (options == null ? void 0 : options.ignoreIncompleteToolCalls) {\n    messages = messages.map((message) => ({\n      ...message,\n      parts: message.parts.filter(\n        (part) => !isToolUIPart(part) || part.state !== \"input-streaming\" && part.state !== \"input-available\"\n      )\n    }));\n  }\n  for (const message of messages) {\n    switch (message.role) {\n      case \"system\": {\n        const textParts = message.parts.filter(\n          (part) => part.type === \"text\"\n        );\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n        modelMessages.push({\n          role: \"system\",\n          content: textParts.map((part) => part.text).join(\"\"),\n          ...Object.keys(providerMetadata).length > 0 ? { providerOptions: providerMetadata } : {}\n        });\n        break;\n      }\n      case \"user\": {\n        modelMessages.push({\n          role: \"user\",\n          content: message.parts.map((part) => {\n            var _a21;\n            if (isTextUIPart(part)) {\n              return {\n                type: \"text\",\n                text: part.text,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isFileUIPart(part)) {\n              return {\n                type: \"file\",\n                mediaType: part.mediaType,\n                filename: part.filename,\n                data: part.url,\n                ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n              };\n            }\n            if (isDataUIPart(part)) {\n              return (_a21 = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _a21.call(\n                options,\n                part\n              );\n            }\n          }).filter(_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.isNonNullable)\n        });\n        break;\n      }\n      case \"assistant\": {\n        if (message.parts != null) {\n          let block = [];\n          async function processBlock() {\n            var _a21, _b, _c, _d, _e, _f;\n            if (block.length === 0) {\n              return;\n            }\n            const content = [];\n            for (const part of block) {\n              if (isTextUIPart(part)) {\n                content.push({\n                  type: \"text\",\n                  text: part.text,\n                  ...part.providerMetadata != null ? { providerOptions: part.providerMetadata } : {}\n                });\n              } else if (isFileUIPart(part)) {\n                content.push({\n                  type: \"file\",\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url\n                });\n              } else if (isReasoningUIPart(part)) {\n                content.push({\n                  type: \"reasoning\",\n                  text: part.text,\n                  providerOptions: part.providerMetadata\n                });\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n                if (part.state !== \"input-streaming\") {\n                  content.push({\n                    type: \"tool-call\",\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input: part.state === \"output-error\" ? (_a21 = part.input) != null ? _a21 : \"rawInput\" in part ? part.rawInput : void 0 : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                  });\n                  if (part.approval != null) {\n                    content.push({\n                      type: \"tool-approval-request\",\n                      approvalId: part.approval.id,\n                      toolCallId: part.toolCallId\n                    });\n                  }\n                  if (part.providerExecuted === true && part.state !== \"approval-responded\" && (part.state === \"output-available\" || part.state === \"output-error\")) {\n                    content.push({\n                      type: \"tool-result\",\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        output: part.state === \"output-error\" ? part.errorText : part.output,\n                        tool: (_b = options == null ? void 0 : options.tools) == null ? void 0 : _b[toolName],\n                        errorMode: part.state === \"output-error\" ? \"json\" : \"none\"\n                      }),\n                      ...part.callProviderMetadata != null ? { providerOptions: part.callProviderMetadata } : {}\n                    });\n                  }\n                }\n              } else if (isDataUIPart(part)) {\n                const dataPart = (_c = options == null ? void 0 : options.convertDataPart) == null ? void 0 : _c.call(\n                  options,\n                  part\n                );\n                if (dataPart != null) {\n                  content.push(dataPart);\n                }\n              } else {\n                const _exhaustiveCheck = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n            modelMessages.push({\n              role: \"assistant\",\n              content\n            });\n            const toolParts = block.filter(\n              (part) => {\n                var _a22;\n                return isToolUIPart(part) && (part.providerExecuted !== true || ((_a22 = part.approval) == null ? void 0 : _a22.approved) != null);\n              }\n            );\n            if (toolParts.length > 0) {\n              {\n                const content2 = [];\n                for (const toolPart of toolParts) {\n                  if (((_d = toolPart.approval) == null ? void 0 : _d.approved) != null) {\n                    content2.push({\n                      type: \"tool-approval-response\",\n                      approvalId: toolPart.approval.id,\n                      approved: toolPart.approval.approved,\n                      reason: toolPart.approval.reason,\n                      providerExecuted: toolPart.providerExecuted\n                    });\n                  }\n                  if (toolPart.providerExecuted === true) {\n                    continue;\n                  }\n                  switch (toolPart.state) {\n                    case \"output-denied\": {\n                      content2.push({\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName: getToolName(toolPart),\n                        output: {\n                          type: \"error-text\",\n                          value: (_e = toolPart.approval.reason) != null ? _e : \"Tool execution denied.\"\n                        },\n                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}\n                      });\n                      break;\n                    }\n                    case \"output-error\":\n                    case \"output-available\": {\n                      const toolName = getToolName(toolPart);\n                      content2.push({\n                        type: \"tool-result\",\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: await createToolModelOutput({\n                          toolCallId: toolPart.toolCallId,\n                          input: toolPart.input,\n                          output: toolPart.state === \"output-error\" ? toolPart.errorText : toolPart.output,\n                          tool: (_f = options == null ? void 0 : options.tools) == null ? void 0 : _f[toolName],\n                          errorMode: toolPart.state === \"output-error\" ? \"text\" : \"none\"\n                        }),\n                        ...toolPart.callProviderMetadata != null ? { providerOptions: toolPart.callProviderMetadata } : {}\n                      });\n                      break;\n                    }\n                  }\n                }\n                if (content2.length > 0) {\n                  modelMessages.push({\n                    role: \"tool\",\n                    content: content2\n                  });\n                }\n              }\n            }\n            block = [];\n          }\n          for (const part of message.parts) {\n            if (isTextUIPart(part) || isReasoningUIPart(part) || isFileUIPart(part) || isToolUIPart(part) || isDataUIPart(part)) {\n              block.push(part);\n            } else if (part.type === \"step-start\") {\n              await processBlock();\n            }\n          }\n          await processBlock();\n          break;\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`\n        });\n      }\n    }\n  }\n  return modelMessages;\n}\n\n// src/ui/validate-ui-messages.ts\n\n\n\nvar uiMessagesSchema = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.lazySchema)(\n  () => (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.zodSchema)(\n    zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(\n      zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        role: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"enum\"]([\"system\", \"user\", \"assistant\"]),\n        metadata: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n        parts: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.array(\n          zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n              text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"enum\"]([\"streaming\", \"done\"]).optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"reasoning\"),\n              text: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z[\"enum\"]([\"streaming\", \"done\"]).optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-url\"),\n              sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"source-document\"),\n              sourceId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              title: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n              mediaType: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              filename: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n              url: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              providerMetadata: providerMetadataSchema.optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"step-start\")\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"data-\"),\n              id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n              data: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-streaming\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-available\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-requested\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-responded\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-available\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-error\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"dynamic-tool\"),\n              toolName: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-denied\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(false),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-streaming\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"input-available\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-requested\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"approval-responded\"),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              })\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-available\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              preliminary: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-error\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              rawInput: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown().optional(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(true),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              }).optional()\n            }),\n            zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n              type: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().startsWith(\"tool-\"),\n              toolCallId: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n              state: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"output-denied\"),\n              providerExecuted: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n              input: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n              output: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              errorText: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.never().optional(),\n              callProviderMetadata: providerMetadataSchema.optional(),\n              approval: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.object({\n                id: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n                approved: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.literal(false),\n                reason: zod_v4__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n              })\n            })\n          ])\n        ).nonempty(\"Message must contain at least one part\")\n      })\n    ).nonempty(\"Messages array must not be empty\")\n  )\n);\nasync function safeValidateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  try {\n    if (messages == null) {\n      return {\n        success: false,\n        error: new InvalidArgumentError({\n          parameter: \"messages\",\n          value: messages,\n          message: \"messages parameter must be provided\"\n        })\n      };\n    }\n    const validatedMessages = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n      value: messages,\n      schema: uiMessagesSchema\n    });\n    if (metadataSchema) {\n      for (const [msgIdx, message] of validatedMessages.entries()) {\n        await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n          value: message.metadata,\n          schema: metadataSchema,\n          context: {\n            field: `messages[${msgIdx}].metadata`,\n            entityId: message.id\n          }\n        });\n      }\n    }\n    if (dataSchemas || tools) {\n      for (const [msgIdx, message] of validatedMessages.entries()) {\n        for (const [partIdx, part] of message.parts.entries()) {\n          if (dataSchemas && part.type.startsWith(\"data-\")) {\n            const dataPart = part;\n            const dataName = dataPart.type.slice(5);\n            const dataSchema = dataSchemas[dataName];\n            if (!dataSchema) {\n              return {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                  value: dataPart.data,\n                  cause: `No data schema found for data part ${dataName}`,\n                  context: {\n                    field: `messages[${msgIdx}].parts[${partIdx}].data`,\n                    entityName: dataName,\n                    entityId: dataPart.id\n                  }\n                })\n              };\n            }\n            await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n              value: dataPart.data,\n              schema: dataSchema,\n              context: {\n                field: `messages[${msgIdx}].parts[${partIdx}].data`,\n                entityName: dataName,\n                entityId: dataPart.id\n              }\n            });\n          }\n          if (tools && part.type.startsWith(\"tool-\")) {\n            const toolPart = part;\n            const toolName = toolPart.type.slice(5);\n            const tool2 = tools[toolName];\n            if (!tool2) {\n              return {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                  value: toolPart.input,\n                  cause: `No tool schema found for tool part ${toolName}`,\n                  context: {\n                    field: `messages[${msgIdx}].parts[${partIdx}].input`,\n                    entityName: toolName,\n                    entityId: toolPart.toolCallId\n                  }\n                })\n              };\n            }\n            if (toolPart.state === \"input-available\" || toolPart.state === \"output-available\" || toolPart.state === \"output-error\" && toolPart.input !== void 0) {\n              await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                value: toolPart.input,\n                schema: tool2.inputSchema,\n                context: {\n                  field: `messages[${msgIdx}].parts[${partIdx}].input`,\n                  entityName: toolName,\n                  entityId: toolPart.toolCallId\n                }\n              });\n            }\n            if (toolPart.state === \"output-available\" && tool2.outputSchema) {\n              await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.validateTypes)({\n                value: toolPart.output,\n                schema: tool2.outputSchema,\n                context: {\n                  field: `messages[${msgIdx}].parts[${partIdx}].output`,\n                  entityName: toolName,\n                  entityId: toolPart.toolCallId\n                }\n              });\n            }\n          }\n        }\n      }\n    }\n    return {\n      success: true,\n      data: validatedMessages\n    };\n  } catch (error) {\n    const err = error;\n    return {\n      success: false,\n      error: err\n    };\n  }\n}\nasync function validateUIMessages({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools\n}) {\n  const response = await safeValidateUIMessages({\n    messages,\n    metadataSchema,\n    dataSchemas,\n    tools\n  });\n  if (!response.success)\n    throw response.error;\n  return response.data;\n}\n\n// src/agent/create-agent-ui-stream.ts\nasync function createAgentUIStream({\n  agent,\n  uiMessages,\n  options,\n  abortSignal,\n  timeout,\n  experimental_transform,\n  onStepFinish,\n  ...uiMessageStreamOptions\n}) {\n  const validatedMessages = await validateUIMessages({\n    messages: uiMessages,\n    tools: agent.tools\n  });\n  const modelMessages = await convertToModelMessages(validatedMessages, {\n    tools: agent.tools\n  });\n  const result = await agent.stream({\n    prompt: modelMessages,\n    options,\n    abortSignal,\n    timeout,\n    experimental_transform,\n    onStepFinish\n  });\n  return result.toUIMessageStream(uiMessageStreamOptions);\n}\n\n// src/agent/create-agent-ui-stream-response.ts\nasync function createAgentUIStreamResponse({\n  headers,\n  status,\n  statusText,\n  consumeSseStream,\n  ...options\n}) {\n  return createUIMessageStreamResponse({\n    headers,\n    status,\n    statusText,\n    consumeSseStream,\n    stream: await createAgentUIStream(options)\n  });\n}\n\n// src/agent/pipe-agent-ui-stream-to-response.ts\nasync function pipeAgentUIStreamToResponse({\n  response,\n  headers,\n  status,\n  statusText,\n  consumeSseStream,\n  ...options\n}) {\n  pipeUIMessageStreamToResponse({\n    response,\n    headers,\n    status,\n    statusText,\n    consumeSseStream,\n    stream: await createAgentUIStream(options)\n  });\n}\n\n// src/embed/embed.ts\n\nasync function embed({\n  model: modelArg,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embed\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embed\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.value\": { input: () => JSON.stringify(value) }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      const { embedding, usage, warnings, response, providerMetadata } = await retry(\n        () => (\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: \"ai.embed.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embed.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": { input: () => [JSON.stringify(value)] }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a21;\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers: headersWithUserAgent,\n                providerOptions\n              });\n              const embedding2 = modelResponse.embeddings[0];\n              const usage2 = (_a21 = modelResponse.usage) != null ? _a21 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => modelResponse.embeddings.map(\n                        (embedding3) => JSON.stringify(embedding3)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embedding: embedding2,\n                usage: usage2,\n                warnings: modelResponse.warnings,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          })\n        )\n      );\n      span.setAttributes(\n        await selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embedding\": { output: () => JSON.stringify(embedding) },\n            \"ai.usage.tokens\": usage.tokens\n          }\n        })\n      );\n      logWarnings({ warnings, provider: model.provider, model: model.modelId });\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        warnings,\n        providerMetadata,\n        response\n      });\n    }\n  });\n}\nvar DefaultEmbedResult = class {\n  constructor(options) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n  }\n};\n\n// src/embed/embed-many.ts\n\n\n// src/util/split-array.ts\nfunction splitArray(array2, chunkSize) {\n  if (chunkSize <= 0) {\n    throw new Error(\"chunkSize must be greater than 0\");\n  }\n  const result = [];\n  for (let i = 0; i < array2.length; i += chunkSize) {\n    result.push(array2.slice(i, i + chunkSize));\n  }\n  return result;\n}\n\n// src/embed/embed-many.ts\nasync function embedMany({\n  model: modelArg,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  const model = resolveEmbeddingModel(modelArg);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.embedMany\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.embedMany\", telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        \"ai.values\": {\n          input: () => values.map((value) => JSON.stringify(value))\n        }\n      }\n    }),\n    tracer,\n    fn: async (span) => {\n      var _a21;\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls\n      ]);\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings: embeddings2, usage, warnings: warnings2, response, providerMetadata: providerMetadata2 } = await retry(() => {\n          return recordSpan({\n            name: \"ai.embedMany.doEmbed\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.embedMany.doEmbed\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                  input: () => values.map((value) => JSON.stringify(value))\n                }\n              }\n            }),\n            tracer,\n            fn: async (doEmbedSpan) => {\n              var _a22;\n              const modelResponse = await model.doEmbed({\n                values,\n                abortSignal,\n                headers: headersWithUserAgent,\n                providerOptions\n              });\n              const embeddings3 = modelResponse.embeddings;\n              const usage2 = (_a22 = modelResponse.usage) != null ? _a22 : { tokens: NaN };\n              doEmbedSpan.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.embeddings\": {\n                      output: () => embeddings3.map(\n                        (embedding) => JSON.stringify(embedding)\n                      )\n                    },\n                    \"ai.usage.tokens\": usage2.tokens\n                  }\n                })\n              );\n              return {\n                embeddings: embeddings3,\n                usage: usage2,\n                warnings: modelResponse.warnings,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response\n              };\n            }\n          });\n        });\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.embeddings\": {\n                output: () => embeddings2.map((embedding) => JSON.stringify(embedding))\n              },\n              \"ai.usage.tokens\": usage.tokens\n            }\n          })\n        );\n        logWarnings({\n          warnings: warnings2,\n          provider: model.provider,\n          model: model.modelId\n        });\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings: embeddings2,\n          usage,\n          warnings: warnings2,\n          providerMetadata: providerMetadata2,\n          responses: [response]\n        });\n      }\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n      const embeddings = [];\n      const warnings = [];\n      const responses = [];\n      let tokens = 0;\n      let providerMetadata;\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1\n      );\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map((chunk) => {\n            return retry(() => {\n              return recordSpan({\n                name: \"ai.embedMany.doEmbed\",\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: \"ai.embedMany.doEmbed\",\n                      telemetry\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    \"ai.values\": {\n                      input: () => chunk.map((value) => JSON.stringify(value))\n                    }\n                  }\n                }),\n                tracer,\n                fn: async (doEmbedSpan) => {\n                  var _a22;\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers: headersWithUserAgent,\n                    providerOptions\n                  });\n                  const embeddings2 = modelResponse.embeddings;\n                  const usage = (_a22 = modelResponse.usage) != null ? _a22 : { tokens: NaN };\n                  doEmbedSpan.setAttributes(\n                    await selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        \"ai.embeddings\": {\n                          output: () => embeddings2.map(\n                            (embedding) => JSON.stringify(embedding)\n                          )\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                      }\n                    })\n                  );\n                  return {\n                    embeddings: embeddings2,\n                    usage,\n                    warnings: modelResponse.warnings,\n                    providerMetadata: modelResponse.providerMetadata,\n                    response: modelResponse.response\n                  };\n                }\n              });\n            });\n          })\n        );\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          warnings.push(...result.warnings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n          if (result.providerMetadata) {\n            if (!providerMetadata) {\n              providerMetadata = { ...result.providerMetadata };\n            } else {\n              for (const [providerName, metadata] of Object.entries(\n                result.providerMetadata\n              )) {\n                providerMetadata[providerName] = {\n                  ...(_a21 = providerMetadata[providerName]) != null ? _a21 : {},\n                  ...metadata\n                };\n              }\n            }\n          }\n        }\n      }\n      span.setAttributes(\n        await selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            \"ai.embeddings\": {\n              output: () => embeddings.map((embedding) => JSON.stringify(embedding))\n            },\n            \"ai.usage.tokens\": tokens\n          }\n        })\n      );\n      logWarnings({\n        warnings,\n        provider: model.provider,\n        model: model.modelId\n      });\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        warnings,\n        providerMetadata,\n        responses\n      });\n    }\n  });\n}\nvar DefaultEmbedManyResult = class {\n  constructor(options) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.responses = options.responses;\n  }\n};\n\n// src/generate-image/generate-image.ts\n\nasync function generateImage({\n  model: modelArg,\n  prompt: promptArg,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a21, _b;\n  const model = resolveImageModel(modelArg);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const maxImagesPerCallWithDefault = (_a21 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a21 : 1;\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n  const results = await Promise.all(\n    callImageCounts.map(\n      async (callImageCount) => retry(() => {\n        const { prompt, files, mask } = normalizePrompt(promptArg);\n        return model.doGenerate({\n          prompt,\n          files,\n          mask,\n          n: callImageCount,\n          abortSignal,\n          headers: headersWithUserAgent,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions != null ? providerOptions : {}\n        });\n      })\n    )\n  );\n  const images = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  let totalUsage = {\n    inputTokens: void 0,\n    outputTokens: void 0,\n    totalTokens: void 0\n  };\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        (image) => {\n          var _a22;\n          return new DefaultGeneratedFile({\n            data: image,\n            mediaType: (_a22 = detectMediaType({\n              data: image,\n              signatures: imageMediaTypeSignatures\n            })) != null ? _a22 : \"image/png\"\n          });\n        }\n      )\n    );\n    warnings.push(...result.warnings);\n    if (result.usage != null) {\n      totalUsage = addImageModelUsage(totalUsage, result.usage);\n    }\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries(result.providerMetadata)) {\n        if (providerName === \"gateway\") {\n          const currentEntry = providerMetadata[providerName];\n          if (currentEntry != null && typeof currentEntry === \"object\") {\n            providerMetadata[providerName] = {\n              ...currentEntry,\n              ...metadata\n            };\n          } else {\n            providerMetadata[providerName] = metadata;\n          }\n          const imagesValue = providerMetadata[providerName].images;\n          if (Array.isArray(imagesValue) && imagesValue.length === 0) {\n            delete providerMetadata[providerName].images;\n          }\n        } else {\n          (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = { images: [] };\n          providerMetadata[providerName].images.push(\n            ...result.providerMetadata[providerName].images\n          );\n        }\n      }\n    }\n    responses.push(result.response);\n  }\n  logWarnings({ warnings, provider: model.provider, model: model.modelId });\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata,\n    usage: totalUsage\n  });\n}\nvar DefaultGenerateImageResult = class {\n  constructor(options) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n    this.usage = options.usage;\n  }\n  get image() {\n    return this.images[0];\n  }\n};\nasync function invokeModelMaxImagesPerCall(model) {\n  const isFunction = model.maxImagesPerCall instanceof Function;\n  if (!isFunction) {\n    return model.maxImagesPerCall;\n  }\n  return model.maxImagesPerCall({\n    modelId: model.modelId\n  });\n}\nfunction normalizePrompt(prompt) {\n  if (typeof prompt === \"string\") {\n    return { prompt, files: void 0, mask: void 0 };\n  }\n  return {\n    prompt: prompt.text,\n    files: prompt.images.map(toImageModelV3File),\n    mask: prompt.mask ? toImageModelV3File(prompt.mask) : void 0\n  };\n}\nfunction toImageModelV3File(dataContent) {\n  if (typeof dataContent === \"string\" && dataContent.startsWith(\"http\")) {\n    return {\n      type: \"url\",\n      url: dataContent\n    };\n  }\n  if (typeof dataContent === \"string\" && dataContent.startsWith(\"data:\")) {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(dataContent);\n    if (base64Content != null) {\n      const uint8Data2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(base64Content);\n      return {\n        type: \"file\",\n        data: uint8Data2,\n        mediaType: dataUrlMediaType || detectMediaType({\n          data: uint8Data2,\n          signatures: imageMediaTypeSignatures\n        }) || \"image/png\"\n      };\n    }\n  }\n  const uint8Data = convertDataContentToUint8Array(dataContent);\n  return {\n    type: \"file\",\n    data: uint8Data,\n    mediaType: detectMediaType({\n      data: uint8Data,\n      signatures: imageMediaTypeSignatures\n    }) || \"image/png\"\n  };\n}\n\n// src/generate-image/index.ts\nvar experimental_generateImage = generateImage;\n\n// src/generate-object/generate-object.ts\n\n\n// src/generate-text/extract-reasoning-content.ts\nfunction extractReasoningContent(content) {\n  const parts = content.filter(\n    (content2) => content2.type === \"reasoning\"\n  );\n  return parts.length === 0 ? void 0 : parts.map((content2) => content2.text).join(\"\\n\");\n}\n\n// src/generate-object/output-strategy.ts\n\n\nvar noSchemaOutputStrategy = {\n  type: \"no-schema\",\n  jsonSchema: async () => void 0,\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n  async validateFinalResult(value, context2) {\n    return value === void 0 ? {\n      success: false,\n      error: new NoObjectGeneratedError({\n        message: \"No object generated: response did not match schema.\",\n        text: context2.text,\n        response: context2.response,\n        usage: context2.usage,\n        finishReason: context2.finishReason\n      })\n    } : { success: true, value };\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in no-schema mode\"\n    });\n  }\n};\nvar objectOutputStrategy = (schema) => ({\n  type: \"object\",\n  jsonSchema: async () => await schema.jsonSchema,\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value,\n        textDelta\n      }\n    };\n  },\n  async validateFinalResult(value) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value, schema });\n  },\n  createElementStream() {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n      functionality: \"element streams in object mode\"\n    });\n  }\n});\nvar arrayOutputStrategy = (schema) => {\n  return {\n    type: \"array\",\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: async () => {\n      const { $schema, ...itemSchema } = await schema.jsonSchema;\n      return {\n        $schema: \"http://json-schema.org/draft-07/schema#\",\n        type: \"object\",\n        properties: {\n          elements: { type: \"array\", items: itemSchema }\n        },\n        required: [\"elements\"],\n        additionalProperties: false\n      };\n    },\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta\n    }) {\n      var _a21;\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      const resultArray = [];\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n        if (!result.success) {\n          return result;\n        }\n        resultArray.push(result.value);\n      }\n      const publishedElementCount = (_a21 = latestObject == null ? void 0 : latestObject.length) != null ? _a21 : 0;\n      let textDelta = \"\";\n      if (isFirstDelta) {\n        textDelta += \"[\";\n      }\n      if (publishedElementCount > 0) {\n        textDelta += \",\";\n      }\n      textDelta += resultArray.slice(publishedElementCount).map((element) => JSON.stringify(element)).join(\",\");\n      if (isFinalDelta) {\n        textDelta += \"]\";\n      }\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta\n        }\n      };\n    },\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be an object that contains an array of elements\"\n          })\n        };\n      }\n      const inputArray = value.elements;\n      for (const element of inputArray) {\n        const result = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeValidateTypes)({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n      return { success: true, value: inputArray };\n    },\n    createElementStream(originalStream) {\n      let publishedElements = 0;\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case \"object\": {\n                  const array2 = chunk.object;\n                  for (; publishedElements < array2.length; publishedElements++) {\n                    controller.enqueue(array2[publishedElements]);\n                  }\n                  break;\n                }\n                case \"text-delta\":\n                case \"finish\":\n                case \"error\":\n                  break;\n                default: {\n                  const _exhaustiveCheck = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`\n                  );\n                }\n              }\n            }\n          })\n        )\n      );\n    }\n  };\n};\nvar enumOutputStrategy = (enumValues) => {\n  return {\n    type: \"enum\",\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: async () => ({\n      $schema: \"http://json-schema.org/draft-07/schema#\",\n      type: \"object\",\n      properties: {\n        result: { type: \"string\", enum: enumValues }\n      },\n      required: [\"result\"],\n      additionalProperties: false\n    }),\n    async validateFinalResult(value) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      return enumValues.includes(result) ? { success: true, value: result } : {\n        success: false,\n        error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n          value,\n          cause: \"value must be a string in the enum\"\n        })\n      };\n    },\n    async validatePartialResult({ value, textDelta }) {\n      if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: 'value must be an object that contains a string in the \"result\" property.'\n          })\n        };\n      }\n      const result = value.result;\n      const possibleEnumValues = enumValues.filter(\n        (enumValue) => enumValue.startsWith(result)\n      );\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n            value,\n            cause: \"value must be a string in the enum\"\n          })\n        };\n      }\n      return {\n        success: true,\n        value: {\n          partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta\n        }\n      };\n    },\n    createElementStream() {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n        functionality: \"element streams in enum mode\"\n      });\n    }\n  };\n};\nfunction getOutputStrategy({\n  output,\n  schema,\n  enumValues\n}) {\n  switch (output) {\n    case \"object\":\n      return objectOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"array\":\n      return arrayOutputStrategy((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema));\n    case \"enum\":\n      return enumOutputStrategy(enumValues);\n    case \"no-schema\":\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/generate-object/parse-and-validate-object-result.ts\n\n\nasync function parseAndValidateObjectResult(result, outputStrategy, context2) {\n  const parseResult = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.safeParseJSON)({ text: result });\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: could not parse the response.\",\n      cause: parseResult.error,\n      text: result,\n      response: context2.response,\n      usage: context2.usage,\n      finishReason: context2.finishReason\n    });\n  }\n  const validationResult = await outputStrategy.validateFinalResult(\n    parseResult.value,\n    {\n      text: result,\n      response: context2.response,\n      usage: context2.usage\n    }\n  );\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: \"No object generated: response did not match schema.\",\n      cause: validationResult.error,\n      text: result,\n      response: context2.response,\n      usage: context2.usage,\n      finishReason: context2.finishReason\n    });\n  }\n  return validationResult.value;\n}\nasync function parseAndValidateObjectResultWithRepair(result, outputStrategy, repairText, context2) {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context2);\n  } catch (error) {\n    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError.isInstance(error.cause) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError.isInstance(error.cause))) {\n      const repairedText = await repairText({\n        text: result,\n        error: error.cause\n      });\n      if (repairedText === null) {\n        throw error;\n      }\n      return await parseAndValidateObjectResult(\n        repairedText,\n        outputStrategy,\n        context2\n      );\n    }\n    throw error;\n  }\n}\n\n// src/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues\n}) {\n  if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n    throw new InvalidArgumentError({\n      parameter: \"output\",\n      value: output,\n      message: \"Invalid output type.\"\n    });\n  }\n  if (output === \"no-schema\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for no-schema output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for no-schema output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for no-schema output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for no-schema output.\"\n      });\n    }\n  }\n  if (output === \"object\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is required for object output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for object output.\"\n      });\n    }\n  }\n  if (output === \"array\") {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Element schema is required for array output.\"\n      });\n    }\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are not supported for array output.\"\n      });\n    }\n  }\n  if (output === \"enum\") {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schema\",\n        value: schema,\n        message: \"Schema is not supported for enum output.\"\n      });\n    }\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaDescription\",\n        value: schemaDescription,\n        message: \"Schema description is not supported for enum output.\"\n      });\n    }\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: \"schemaName\",\n        value: schemaName,\n        message: \"Schema name is not supported for enum output.\"\n      });\n    }\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: \"enumValues\",\n        value: enumValues,\n        message: \"Enum values are required for enum output.\"\n      });\n    }\n    for (const value of enumValues) {\n      if (typeof value !== \"string\") {\n        throw new InvalidArgumentError({\n          parameter: \"enumValues\",\n          value,\n          message: \"Enum values must be strings.\"\n        });\n      }\n    }\n  }\n}\n\n// src/generate-object/generate-object.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nasync function generateObject(options) {\n  const {\n    model: modelArg,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    _internal: {\n      generateId: generateId2 = originalGenerateId3,\n      currentDate = () => /* @__PURE__ */ new Date()\n    } = {},\n    ...settings\n  } = options;\n  const model = resolveLanguageModel(modelArg);\n  const enumValues = \"enum\" in options ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  const callSettings = prepareCallSettings(settings);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  const jsonSchema2 = await outputStrategy.jsonSchema();\n  try {\n    return await recordSpan({\n      name: \"ai.generateObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.generateObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": jsonSchema2 != null ? { input: () => JSON.stringify(jsonSchema2) } : void 0,\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      fn: async (span) => {\n        var _a21;\n        let result;\n        let finishReason;\n        let usage;\n        let warnings;\n        let response;\n        let request;\n        let resultProviderMetadata;\n        let reasoning;\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download: download2\n        });\n        const generateResult = await retry(\n          () => recordSpan({\n            name: \"ai.generateObject.doGenerate\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.generateObject.doGenerate\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(promptMessages)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            fn: async (span2) => {\n              var _a22, _b, _c, _d, _e, _f, _g, _h;\n              const result2 = await model.doGenerate({\n                responseFormat: {\n                  type: \"json\",\n                  schema: jsonSchema2,\n                  name: schemaName,\n                  description: schemaDescription\n                },\n                ...prepareCallSettings(settings),\n                prompt: promptMessages,\n                providerOptions,\n                abortSignal,\n                headers: headersWithUserAgent\n              });\n              const responseData = {\n                id: (_b = (_a22 = result2.response) == null ? void 0 : _a22.id) != null ? _b : generateId2(),\n                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,\n                headers: (_g = result2.response) == null ? void 0 : _g.headers,\n                body: (_h = result2.response) == null ? void 0 : _h.body\n              };\n              const text2 = extractTextContent(result2.content);\n              const reasoning2 = extractReasoningContent(result2.content);\n              if (text2 === void 0) {\n                throw new NoObjectGeneratedError({\n                  message: \"No object generated: the model did not return a response.\",\n                  response: responseData,\n                  usage: asLanguageModelUsage(result2.usage),\n                  finishReason: result2.finishReason.unified\n                });\n              }\n              span2.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    \"ai.response.finishReason\": result2.finishReason.unified,\n                    \"ai.response.object\": { output: () => text2 },\n                    \"ai.response.id\": responseData.id,\n                    \"ai.response.model\": responseData.modelId,\n                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                    \"ai.response.providerMetadata\": JSON.stringify(\n                      result2.providerMetadata\n                    ),\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    \"ai.usage.promptTokens\": result2.usage.inputTokens.total,\n                    \"ai.usage.completionTokens\": result2.usage.outputTokens.total,\n                    // standardized gen-ai llm span attributes:\n                    \"gen_ai.response.finish_reasons\": [\n                      result2.finishReason.unified\n                    ],\n                    \"gen_ai.response.id\": responseData.id,\n                    \"gen_ai.response.model\": responseData.modelId,\n                    \"gen_ai.usage.input_tokens\": result2.usage.inputTokens.total,\n                    \"gen_ai.usage.output_tokens\": result2.usage.outputTokens.total\n                  }\n                })\n              );\n              return {\n                ...result2,\n                objectText: text2,\n                reasoning: reasoning2,\n                responseData\n              };\n            }\n          })\n        );\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason.unified;\n        usage = asLanguageModelUsage(generateResult.usage);\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = (_a21 = generateResult.request) != null ? _a21 : {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n        logWarnings({\n          warnings,\n          provider: model.provider,\n          model: model.modelId\n        });\n        const object2 = await parseAndValidateObjectResultWithRepair(\n          result,\n          outputStrategy,\n          repairText,\n          {\n            response,\n            usage,\n            finishReason\n          }\n        );\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              \"ai.response.finishReason\": finishReason,\n              \"ai.response.object\": {\n                output: () => JSON.stringify(object2)\n              },\n              \"ai.response.providerMetadata\": JSON.stringify(\n                resultProviderMetadata\n              ),\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              \"ai.usage.promptTokens\": usage.inputTokens,\n              \"ai.usage.completionTokens\": usage.outputTokens\n            }\n          })\n        );\n        return new DefaultGenerateObjectResult({\n          object: object2,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata\n        });\n      }\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\nvar DefaultGenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n  toJsonResponse(init) {\n    var _a21;\n    return new Response(JSON.stringify(this.object), {\n      status: (_a21 = init == null ? void 0 : init.status) != null ? _a21 : 200,\n      headers: prepareHeaders(init == null ? void 0 : init.headers, {\n        \"content-type\": \"application/json; charset=utf-8\"\n      })\n    });\n  }\n};\n\n// src/generate-object/stream-object.ts\n\n\n// src/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: \"vector1,vector2\",\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`\n    });\n  }\n  const n = vector1.length;\n  if (n === 0) {\n    return 0;\n  }\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n\n// src/util/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mediaType = header.split(\";\")[0].split(\":\")[1];\n  if (mediaType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/util/serial-job-executor.ts\nvar SerialJobExecutor = class {\n  constructor() {\n    this.queue = [];\n    this.isProcessing = false;\n  }\n  async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n    this.isProcessing = true;\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n    this.isProcessing = false;\n  }\n  async run(job) {\n    return new Promise((resolve3, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve3();\n        } catch (error) {\n          reject(error);\n        }\n      });\n      void this.processQueue();\n    });\n  }\n};\n\n// src/util/simulate-readable-stream.ts\n\nfunction simulateReadableStream({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal\n}) {\n  var _a21;\n  const delay2 = (_a21 = _internal == null ? void 0 : _internal.delay) != null ? _a21 : _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay;\n  let index = 0;\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    }\n  });\n}\n\n// src/generate-object/stream-object.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.createIdGenerator)({ prefix: \"aiobj\", size: 24 });\nfunction streamObject(options) {\n  const {\n    model,\n    output = \"object\",\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download2,\n    providerOptions,\n    onError = ({ error }) => {\n      console.error(error);\n    },\n    onFinish,\n    _internal: {\n      generateId: generateId2 = originalGenerateId4,\n      currentDate = () => /* @__PURE__ */ new Date(),\n      now: now2 = now\n    } = {},\n    ...settings\n  } = options;\n  const enumValues = \"enum\" in options && options.enum ? options.enum : void 0;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName\n  } = \"schema\" in options ? options : {};\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues\n  });\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues\n  });\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId2,\n    currentDate,\n    now: now2\n  });\n}\nvar DefaultStreamObjectResult = class {\n  constructor({\n    model: modelArg,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download: download2,\n    generateId: generateId2,\n    currentDate,\n    now: now2\n  }) {\n    this._object = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._usage = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._providerMetadata = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._warnings = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._request = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._response = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    this._finishReason = new _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.DelayedPromise();\n    const model = resolveLanguageModel(modelArg);\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal\n    });\n    const callSettings = prepareCallSettings(settings);\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries }\n    });\n    const tracer = getTracer(telemetry);\n    const self = this;\n    const stitchableStream = createStitchableStream();\n    const eventProcessor = new TransformStream({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n        if (chunk.type === \"error\") {\n          onError({ error: wrapGatewayError(chunk.error) });\n        }\n      }\n    });\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n    recordSpan({\n      name: \"ai.streamObject\",\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: \"ai.streamObject\",\n            telemetry\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          \"ai.prompt\": {\n            input: () => JSON.stringify({ system, prompt, messages })\n          },\n          \"ai.schema\": {\n            input: async () => JSON.stringify(await outputStrategy.jsonSchema())\n          },\n          \"ai.schema.name\": schemaName,\n          \"ai.schema.description\": schemaDescription,\n          \"ai.settings.output\": outputStrategy.type\n        }\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async (rootSpan) => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages\n        });\n        const callOptions = {\n          responseFormat: {\n            type: \"json\",\n            schema: await outputStrategy.jsonSchema(),\n            name: schemaName,\n            description: schemaDescription\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls,\n            download: download2\n          }),\n          providerOptions,\n          abortSignal,\n          headers,\n          includeRawChunks: false\n        };\n        const transformer = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.delta);\n                break;\n              case \"response-metadata\":\n              case \"finish\":\n              case \"error\":\n              case \"stream-start\":\n                controller.enqueue(chunk);\n                break;\n            }\n          }\n        };\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs\n        } = await retry(\n          () => recordSpan({\n            name: \"ai.streamObject.doStream\",\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: \"ai.streamObject.doStream\",\n                  telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.prompt.messages\": {\n                  input: () => stringifyForTelemetry(callOptions.prompt)\n                },\n                // standardized gen-ai llm span attributes:\n                \"gen_ai.system\": model.provider,\n                \"gen_ai.request.model\": model.modelId,\n                \"gen_ai.request.frequency_penalty\": callSettings.frequencyPenalty,\n                \"gen_ai.request.max_tokens\": callSettings.maxOutputTokens,\n                \"gen_ai.request.presence_penalty\": callSettings.presencePenalty,\n                \"gen_ai.request.temperature\": callSettings.temperature,\n                \"gen_ai.request.top_k\": callSettings.topK,\n                \"gen_ai.request.top_p\": callSettings.topP\n              }\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async (doStreamSpan2) => ({\n              startTimestampMs: now2(),\n              doStreamSpan: doStreamSpan2,\n              result: await model.doStream(callOptions)\n            })\n          })\n        );\n        self._request.resolve(request != null ? request : {});\n        let warnings;\n        let usage = createNullLanguageModelUsage();\n        let finishReason;\n        let providerMetadata;\n        let object2;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let fullResponse = {\n          id: generateId2(),\n          timestamp: currentDate(),\n          modelId: model.modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(\n          new TransformStream({\n            async transform(chunk, controller) {\n              var _a21, _b, _c;\n              if (typeof chunk === \"object\" && chunk.type === \"stream-start\") {\n                warnings = chunk.warnings;\n                return;\n              }\n              if (isFirstChunk) {\n                const msToFirstChunk = now2() - startTimestampMs;\n                isFirstChunk = false;\n                doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n                doStreamSpan.setAttributes({\n                  \"ai.stream.msToFirstChunk\": msToFirstChunk\n                });\n              }\n              if (typeof chunk === \"string\") {\n                accumulatedText += chunk;\n                textDelta += chunk;\n                const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);\n                if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {\n                  const validationResult = await outputStrategy.validatePartialResult({\n                    value: currentObjectJson,\n                    textDelta,\n                    latestObject,\n                    isFirstDelta,\n                    isFinalDelta: parseState === \"successful-parse\"\n                  });\n                  if (validationResult.success && !isDeepEqualData(\n                    latestObject,\n                    validationResult.value.partial\n                  )) {\n                    latestObjectJson = currentObjectJson;\n                    latestObject = validationResult.value.partial;\n                    controller.enqueue({\n                      type: \"object\",\n                      object: latestObject\n                    });\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      textDelta: validationResult.value.textDelta\n                    });\n                    textDelta = \"\";\n                    isFirstDelta = false;\n                  }\n                }\n                return;\n              }\n              switch (chunk.type) {\n                case \"response-metadata\": {\n                  fullResponse = {\n                    id: (_a21 = chunk.id) != null ? _a21 : fullResponse.id,\n                    timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,\n                    modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId\n                  };\n                  break;\n                }\n                case \"finish\": {\n                  if (textDelta !== \"\") {\n                    controller.enqueue({ type: \"text-delta\", textDelta });\n                  }\n                  finishReason = chunk.finishReason.unified;\n                  usage = asLanguageModelUsage(chunk.usage);\n                  providerMetadata = chunk.providerMetadata;\n                  controller.enqueue({\n                    ...chunk,\n                    finishReason: chunk.finishReason.unified,\n                    usage,\n                    response: fullResponse\n                  });\n                  logWarnings({\n                    warnings: warnings != null ? warnings : [],\n                    provider: model.provider,\n                    model: model.modelId\n                  });\n                  self._usage.resolve(usage);\n                  self._providerMetadata.resolve(providerMetadata);\n                  self._warnings.resolve(warnings);\n                  self._response.resolve({\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  });\n                  self._finishReason.resolve(finishReason != null ? finishReason : \"other\");\n                  try {\n                    object2 = await parseAndValidateObjectResultWithRepair(\n                      accumulatedText,\n                      outputStrategy,\n                      repairText,\n                      {\n                        response: fullResponse,\n                        usage,\n                        finishReason\n                      }\n                    );\n                    self._object.resolve(object2);\n                  } catch (e) {\n                    error = e;\n                    self._object.reject(e);\n                  }\n                  break;\n                }\n                default: {\n                  controller.enqueue(chunk);\n                  break;\n                }\n              }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush(controller) {\n              try {\n                const finalUsage = usage != null ? usage : {\n                  promptTokens: NaN,\n                  completionTokens: NaN,\n                  totalTokens: NaN\n                };\n                doStreamSpan.setAttributes(\n                  await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.response.finishReason\": finishReason,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.id\": fullResponse.id,\n                      \"ai.response.model\": fullResponse.modelId,\n                      \"ai.response.timestamp\": fullResponse.timestamp.toISOString(),\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata),\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      // standardized gen-ai llm span attributes:\n                      \"gen_ai.response.finish_reasons\": [finishReason],\n                      \"gen_ai.response.id\": fullResponse.id,\n                      \"gen_ai.response.model\": fullResponse.modelId,\n                      \"gen_ai.usage.input_tokens\": finalUsage.inputTokens,\n                      \"gen_ai.usage.output_tokens\": finalUsage.outputTokens\n                    }\n                  })\n                );\n                doStreamSpan.end();\n                rootSpan.setAttributes(\n                  await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      \"ai.usage.inputTokens\": finalUsage.inputTokens,\n                      \"ai.usage.outputTokens\": finalUsage.outputTokens,\n                      \"ai.usage.totalTokens\": finalUsage.totalTokens,\n                      \"ai.usage.reasoningTokens\": finalUsage.reasoningTokens,\n                      \"ai.usage.cachedInputTokens\": finalUsage.cachedInputTokens,\n                      \"ai.response.object\": {\n                        output: () => JSON.stringify(object2)\n                      },\n                      \"ai.response.providerMetadata\": JSON.stringify(providerMetadata)\n                    }\n                  })\n                );\n                await (onFinish == null ? void 0 : onFinish({\n                  usage: finalUsage,\n                  object: object2,\n                  error,\n                  response: {\n                    ...fullResponse,\n                    headers: response == null ? void 0 : response.headers\n                  },\n                  warnings,\n                  providerMetadata\n                }));\n              } catch (error2) {\n                controller.enqueue({ type: \"error\", error: error2 });\n              } finally {\n                rootSpan.end();\n              }\n            }\n          })\n        );\n        stitchableStream.addStream(transformedStream);\n      }\n    }).catch((error) => {\n      stitchableStream.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: \"error\", error });\n            controller.close();\n          }\n        })\n      );\n    }).finally(() => {\n      stitchableStream.close();\n    });\n    this.outputStrategy = outputStrategy;\n  }\n  get object() {\n    return this._object.promise;\n  }\n  get usage() {\n    return this._usage.promise;\n  }\n  get providerMetadata() {\n    return this._providerMetadata.promise;\n  }\n  get warnings() {\n    return this._warnings.promise;\n  }\n  get request() {\n    return this._request.promise;\n  }\n  get response() {\n    return this._response.promise;\n  }\n  get finishReason() {\n    return this._finishReason.promise;\n  }\n  get partialObjectStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"object\":\n                controller.enqueue(chunk.object);\n                break;\n              case \"text-delta\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get elementStream() {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n  get textStream() {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case \"text-delta\":\n                controller.enqueue(chunk.textDelta);\n                break;\n              case \"object\":\n              case \"finish\":\n              case \"error\":\n                break;\n              default: {\n                const _exhaustiveCheck = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          }\n        })\n      )\n    );\n  }\n  get fullStream() {\n    return createAsyncIterableStream(this.baseStream);\n  }\n  pipeTextStreamToResponse(response, init) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init\n    });\n  }\n  toTextStreamResponse(init) {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init\n    });\n  }\n};\n\n// src/generate-speech/generate-speech.ts\n\n\n// src/generate-speech/generated-audio-file.ts\nvar DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {\n  constructor({\n    data,\n    mediaType\n  }) {\n    super({ data, mediaType });\n    let format = \"mp3\";\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split(\"/\");\n      if (mediaTypeParts.length === 2) {\n        if (mediaType !== \"audio/mpeg\") {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n    if (!format) {\n      throw new Error(\n        \"Audio format must be provided or determinable from media type\"\n      );\n    }\n    this.format = format;\n  }\n};\n\n// src/generate-speech/generate-speech.ts\nasync function generateSpeech({\n  model,\n  text: text2,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a21;\n  const resolvedModel = resolveSpeechModel(model);\n  if (!resolvedModel) {\n    throw new Error(\"Model could not be resolved\");\n  }\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const result = await retry(\n    () => resolvedModel.doGenerate({\n      text: text2,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      language,\n      abortSignal,\n      headers: headersWithUserAgent,\n      providerOptions\n    })\n  );\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n  logWarnings({\n    warnings: result.warnings,\n    provider: resolvedModel.provider,\n    model: resolvedModel.modelId\n  });\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType: (_a21 = detectMediaType({\n        data: result.audio,\n        signatures: audioMediaTypeSignatures\n      })) != null ? _a21 : \"audio/mp3\"\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultSpeechResult = class {\n  constructor(options) {\n    var _a21;\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a21 = options.providerMetadata) != null ? _a21 : {};\n  }\n};\n\n// src/generate-text/prune-messages.ts\nfunction pruneMessages({\n  messages,\n  reasoning = \"none\",\n  toolCalls = [],\n  emptyMessages = \"remove\"\n}) {\n  if (reasoning === \"all\" || reasoning === \"before-last-message\") {\n    messages = messages.map((message, messageIndex) => {\n      if (message.role !== \"assistant\" || typeof message.content === \"string\" || reasoning === \"before-last-message\" && messageIndex === messages.length - 1) {\n        return message;\n      }\n      return {\n        ...message,\n        content: message.content.filter((part) => part.type !== \"reasoning\")\n      };\n    });\n  }\n  if (toolCalls === \"none\") {\n    toolCalls = [];\n  } else if (toolCalls === \"all\") {\n    toolCalls = [{ type: \"all\" }];\n  } else if (toolCalls === \"before-last-message\") {\n    toolCalls = [{ type: \"before-last-message\" }];\n  } else if (typeof toolCalls === \"string\") {\n    toolCalls = [{ type: toolCalls }];\n  }\n  for (const toolCall of toolCalls) {\n    const keepLastMessagesCount = toolCall.type === \"all\" ? void 0 : toolCall.type === \"before-last-message\" ? 1 : Number(\n      toolCall.type.slice(\"before-last-\".length).slice(0, -\"-messages\".length)\n    );\n    const keptToolCallIds = /* @__PURE__ */ new Set();\n    const keptApprovalIds = /* @__PURE__ */ new Set();\n    if (keepLastMessagesCount != null) {\n      for (const message of messages.slice(-keepLastMessagesCount)) {\n        if ((message.role === \"assistant\" || message.role === \"tool\") && typeof message.content !== \"string\") {\n          for (const part of message.content) {\n            if (part.type === \"tool-call\" || part.type === \"tool-result\") {\n              keptToolCallIds.add(part.toolCallId);\n            } else if (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") {\n              keptApprovalIds.add(part.approvalId);\n            }\n          }\n        }\n      }\n    }\n    messages = messages.map((message, messageIndex) => {\n      if (message.role !== \"assistant\" && message.role !== \"tool\" || typeof message.content === \"string\" || keepLastMessagesCount && messageIndex >= messages.length - keepLastMessagesCount) {\n        return message;\n      }\n      const toolCallIdToToolName = {};\n      const approvalIdToToolName = {};\n      return {\n        ...message,\n        content: message.content.filter((part) => {\n          if (part.type !== \"tool-call\" && part.type !== \"tool-result\" && part.type !== \"tool-approval-request\" && part.type !== \"tool-approval-response\") {\n            return true;\n          }\n          if (part.type === \"tool-call\") {\n            toolCallIdToToolName[part.toolCallId] = part.toolName;\n          } else if (part.type === \"tool-approval-request\") {\n            approvalIdToToolName[part.approvalId] = toolCallIdToToolName[part.toolCallId];\n          }\n          if ((part.type === \"tool-call\" || part.type === \"tool-result\") && keptToolCallIds.has(part.toolCallId) || (part.type === \"tool-approval-request\" || part.type === \"tool-approval-response\") && keptApprovalIds.has(part.approvalId)) {\n            return true;\n          }\n          return toolCall.tools != null && !toolCall.tools.includes(\n            part.type === \"tool-call\" || part.type === \"tool-result\" ? part.toolName : approvalIdToToolName[part.approvalId]\n          );\n        })\n      };\n    });\n  }\n  if (emptyMessages === \"remove\") {\n    messages = messages.filter((message) => message.content.length > 0);\n  }\n  return messages;\n}\n\n// src/generate-text/smooth-stream.ts\n\n\nvar CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m\n};\nfunction smoothStream({\n  delayInMs = 10,\n  chunking = \"word\",\n  _internal: { delay: delay2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.delay } = {}\n} = {}) {\n  let detectChunk;\n  if (chunking != null && typeof chunking === \"object\" && \"segment\" in chunking && typeof chunking.segment === \"function\") {\n    const segmenter = chunking;\n    detectChunk = (buffer) => {\n      if (buffer.length === 0)\n        return null;\n      const iterator = segmenter.segment(buffer)[Symbol.iterator]();\n      const first = iterator.next().value;\n      return (first == null ? void 0 : first.segment) || null;\n    };\n  } else if (typeof chunking === \"function\") {\n    detectChunk = (buffer) => {\n      const match = chunking(buffer);\n      if (match == null) {\n        return null;\n      }\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`\n        );\n      }\n      return match;\n    };\n  } else {\n    const chunkingRegex = typeof chunking === \"string\" ? CHUNKING_REGEXPS[chunking] : chunking instanceof RegExp ? chunking : void 0;\n    if (chunkingRegex == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidArgumentError({\n        argument: \"chunking\",\n        message: `Chunking must be \"word\", \"line\", a RegExp, an Intl.Segmenter, or a ChunkDetector function. Received: ${chunking}`\n      });\n    }\n    detectChunk = (buffer) => {\n      const match = chunkingRegex.exec(buffer);\n      if (!match) {\n        return null;\n      }\n      return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);\n    };\n  }\n  return () => {\n    let buffer = \"\";\n    let id = \"\";\n    let type = void 0;\n    let providerMetadata = void 0;\n    function flushBuffer(controller) {\n      if (buffer.length > 0 && type !== void 0) {\n        controller.enqueue({\n          type,\n          text: buffer,\n          id,\n          ...providerMetadata != null ? { providerMetadata } : {}\n        });\n        buffer = \"\";\n        providerMetadata = void 0;\n      }\n    }\n    return new TransformStream({\n      async transform(chunk, controller) {\n        if (chunk.type !== \"text-delta\" && chunk.type !== \"reasoning-delta\") {\n          flushBuffer(controller);\n          controller.enqueue(chunk);\n          return;\n        }\n        if ((chunk.type !== type || chunk.id !== id) && buffer.length > 0) {\n          flushBuffer(controller);\n        }\n        buffer += chunk.text;\n        id = chunk.id;\n        type = chunk.type;\n        if (chunk.providerMetadata != null) {\n          providerMetadata = chunk.providerMetadata;\n        }\n        let match;\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type, text: match, id });\n          buffer = buffer.slice(match.length);\n          await delay2(delayInMs);\n        }\n      }\n    });\n  };\n}\n\n// src/generate-video/generate-video.ts\n\nasync function experimental_generateVideo({\n  model: modelArg,\n  prompt: promptArg,\n  n = 1,\n  maxVideosPerCall,\n  aspectRatio,\n  resolution,\n  duration,\n  fps,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  var _a21;\n  const model = resolveVideoModel(modelArg);\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const { prompt, image } = normalizePrompt2(promptArg);\n  const maxVideosPerCallWithDefault = (_a21 = maxVideosPerCall != null ? maxVideosPerCall : await invokeModelMaxVideosPerCall(model)) != null ? _a21 : 1;\n  const callCount = Math.ceil(n / maxVideosPerCallWithDefault);\n  const callVideoCounts = Array.from({ length: callCount }, (_, index) => {\n    const remaining = n - index * maxVideosPerCallWithDefault;\n    return Math.min(remaining, maxVideosPerCallWithDefault);\n  });\n  const results = await Promise.all(\n    callVideoCounts.map(\n      async (callVideoCount) => retry(\n        () => model.doGenerate({\n          prompt,\n          n: callVideoCount,\n          aspectRatio,\n          resolution,\n          duration,\n          fps,\n          seed,\n          image,\n          providerOptions: providerOptions != null ? providerOptions : {},\n          headers: headersWithUserAgent,\n          abortSignal\n        })\n      )\n    )\n  );\n  const videos = [];\n  const warnings = [];\n  const responses = [];\n  const providerMetadata = {};\n  for (const result of results) {\n    for (const videoData of result.videos) {\n      switch (videoData.type) {\n        case \"url\": {\n          const { data, mediaType: downloadedMediaType } = await download({\n            url: new URL(videoData.url)\n          });\n          const isUsableMediaType = (type) => !!type && type !== \"application/octet-stream\";\n          const mediaType = isUsableMediaType(videoData.mediaType) && videoData.mediaType || isUsableMediaType(downloadedMediaType) && downloadedMediaType || detectMediaType({\n            data,\n            signatures: videoMediaTypeSignatures\n          }) || \"video/mp4\";\n          videos.push(\n            new DefaultGeneratedFile({\n              data,\n              mediaType\n            })\n          );\n          break;\n        }\n        case \"base64\": {\n          videos.push(\n            new DefaultGeneratedFile({\n              data: videoData.data,\n              mediaType: videoData.mediaType || \"video/mp4\"\n            })\n          );\n          break;\n        }\n        case \"binary\": {\n          const mediaType = videoData.mediaType || detectMediaType({\n            data: videoData.data,\n            signatures: videoMediaTypeSignatures\n          }) || \"video/mp4\";\n          videos.push(\n            new DefaultGeneratedFile({\n              data: videoData.data,\n              mediaType\n            })\n          );\n          break;\n        }\n      }\n    }\n    warnings.push(...result.warnings);\n    responses.push({\n      timestamp: result.response.timestamp,\n      modelId: result.response.modelId,\n      headers: result.response.headers,\n      providerMetadata: result.providerMetadata\n    });\n    if (result.providerMetadata != null) {\n      for (const [providerName, metadata] of Object.entries(\n        result.providerMetadata\n      )) {\n        const existingMetadata = providerMetadata[providerName];\n        if (existingMetadata != null && typeof existingMetadata === \"object\") {\n          providerMetadata[providerName] = {\n            ...existingMetadata,\n            ...metadata\n          };\n          if (\"videos\" in existingMetadata && Array.isArray(existingMetadata.videos) && \"videos\" in metadata && Array.isArray(metadata.videos)) {\n            providerMetadata[providerName].videos = [\n              ...existingMetadata.videos,\n              ...metadata.videos\n            ];\n          }\n        } else {\n          providerMetadata[providerName] = metadata;\n        }\n      }\n    }\n  }\n  if (videos.length === 0) {\n    throw new NoVideoGeneratedError({ responses });\n  }\n  if (warnings.length > 0) {\n    logWarnings({\n      warnings,\n      provider: model.provider,\n      model: model.modelId\n    });\n  }\n  return {\n    video: videos[0],\n    videos,\n    warnings,\n    responses,\n    providerMetadata\n  };\n}\nfunction normalizePrompt2(promptArg) {\n  var _a21, _b;\n  if (typeof promptArg === \"string\") {\n    return {\n      prompt: promptArg,\n      image: void 0\n    };\n  }\n  let image;\n  if (promptArg.image != null) {\n    const dataContent = promptArg.image;\n    if (typeof dataContent === \"string\") {\n      if (dataContent.startsWith(\"http://\") || dataContent.startsWith(\"https://\")) {\n        image = {\n          type: \"url\",\n          url: dataContent\n        };\n      } else if (dataContent.startsWith(\"data:\")) {\n        const { mediaType, base64Content } = splitDataUrl(dataContent);\n        image = {\n          type: \"file\",\n          mediaType: mediaType != null ? mediaType : \"image/png\",\n          data: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(base64Content != null ? base64Content : \"\")\n        };\n      } else {\n        const bytes = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.convertBase64ToUint8Array)(dataContent);\n        const mediaType = (_a21 = detectMediaType({\n          data: bytes,\n          signatures: imageMediaTypeSignatures\n        })) != null ? _a21 : \"image/png\";\n        image = {\n          type: \"file\",\n          mediaType,\n          data: bytes\n        };\n      }\n    } else if (dataContent instanceof Uint8Array) {\n      const mediaType = (_b = detectMediaType({\n        data: dataContent,\n        signatures: imageMediaTypeSignatures\n      })) != null ? _b : \"image/png\";\n      image = {\n        type: \"file\",\n        mediaType,\n        data: dataContent\n      };\n    }\n  }\n  return {\n    prompt: promptArg.text,\n    image\n  };\n}\nasync function invokeModelMaxVideosPerCall(model) {\n  if (typeof model.maxVideosPerCall === \"function\") {\n    return await model.maxVideosPerCall({ modelId: model.modelId });\n  }\n  return model.maxVideosPerCall;\n}\n\n// src/middleware/default-embedding-settings-middleware.ts\nfunction defaultEmbeddingSettingsMiddleware({\n  settings\n}) {\n  return {\n    specificationVersion: \"v3\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/middleware/default-settings-middleware.ts\nfunction defaultSettingsMiddleware({\n  settings\n}) {\n  return {\n    specificationVersion: \"v3\",\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params);\n    }\n  };\n}\n\n// src/middleware/extract-json-middleware.ts\nfunction defaultTransform(text2) {\n  return text2.replace(/^```(?:json)?\\s*\\n?/, \"\").replace(/\\n?```\\s*$/, \"\").trim();\n}\nfunction extractJsonMiddleware(options) {\n  var _a21;\n  const transform = (_a21 = options == null ? void 0 : options.transform) != null ? _a21 : defaultTransform;\n  const hasCustomTransform = (options == null ? void 0 : options.transform) !== void 0;\n  return {\n    specificationVersion: \"v3\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        transformedContent.push({\n          ...part,\n          text: transform(part.text)\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const textBlocks = {};\n      const SUFFIX_BUFFER_SIZE = 12;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                textBlocks[chunk.id] = {\n                  startEvent: chunk,\n                  // Custom transforms need to buffer all content\n                  phase: hasCustomTransform ? \"buffering\" : \"prefix\",\n                  buffer: \"\",\n                  prefixStripped: false\n                };\n                return;\n              }\n              if (chunk.type === \"text-delta\") {\n                const block = textBlocks[chunk.id];\n                if (!block) {\n                  controller.enqueue(chunk);\n                  return;\n                }\n                block.buffer += chunk.delta;\n                if (block.phase === \"buffering\") {\n                  return;\n                }\n                if (block.phase === \"prefix\") {\n                  if (block.buffer.length > 0 && !block.buffer.startsWith(\"`\")) {\n                    block.phase = \"streaming\";\n                    controller.enqueue(block.startEvent);\n                  } else if (block.buffer.startsWith(\"```\")) {\n                    if (block.buffer.includes(\"\\n\")) {\n                      const prefixMatch = block.buffer.match(/^```(?:json)?\\s*\\n/);\n                      if (prefixMatch) {\n                        block.buffer = block.buffer.slice(\n                          prefixMatch[0].length\n                        );\n                        block.prefixStripped = true;\n                        block.phase = \"streaming\";\n                        controller.enqueue(block.startEvent);\n                      } else {\n                        block.phase = \"streaming\";\n                        controller.enqueue(block.startEvent);\n                      }\n                    }\n                  } else if (block.buffer.length >= 3 && !block.buffer.startsWith(\"```\")) {\n                    block.phase = \"streaming\";\n                    controller.enqueue(block.startEvent);\n                  }\n                }\n                if (block.phase === \"streaming\" && block.buffer.length > SUFFIX_BUFFER_SIZE) {\n                  const toStream = block.buffer.slice(0, -SUFFIX_BUFFER_SIZE);\n                  block.buffer = block.buffer.slice(-SUFFIX_BUFFER_SIZE);\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: chunk.id,\n                    delta: toStream\n                  });\n                }\n                return;\n              }\n              if (chunk.type === \"text-end\") {\n                const block = textBlocks[chunk.id];\n                if (block) {\n                  if (block.phase === \"prefix\" || block.phase === \"buffering\") {\n                    controller.enqueue(block.startEvent);\n                  }\n                  let remaining = block.buffer;\n                  if (block.phase === \"buffering\") {\n                    remaining = transform(remaining);\n                  } else if (block.prefixStripped) {\n                    remaining = remaining.replace(/\\n?```\\s*$/, \"\").trimEnd();\n                  } else {\n                    remaining = transform(remaining);\n                  }\n                  if (remaining.length > 0) {\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      id: chunk.id,\n                      delta: remaining\n                    });\n                  }\n                  controller.enqueue(chunk);\n                  delete textBlocks[chunk.id];\n                  return;\n                }\n              }\n              controller.enqueue(chunk);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/util/get-potential-start-index.ts\nfunction getPotentialStartIndex(text2, searchedText) {\n  if (searchedText.length === 0) {\n    return null;\n  }\n  const directIndex = text2.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n  for (let i = text2.length - 1; i >= 0; i--) {\n    const suffix = text2.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n  return null;\n}\n\n// src/middleware/extract-reasoning-middleware.ts\nfunction extractReasoningMiddleware({\n  tagName,\n  separator = \"\\n\",\n  startWithReasoning = false\n}) {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `</${tagName}>`;\n  return {\n    specificationVersion: \"v3\",\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n      const transformedContent = [];\n      for (const part of content) {\n        if (part.type !== \"text\") {\n          transformedContent.push(part);\n          continue;\n        }\n        const text2 = startWithReasoning ? openingTag + part.text : part.text;\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, \"gs\");\n        const matches = Array.from(text2.matchAll(regexp));\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n        const reasoningText = matches.map((match) => match[1]).join(separator);\n        let textWithoutReasoning = text2;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index + match[0].length\n          );\n          textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : \"\") + afterMatch;\n        }\n        transformedContent.push({\n          type: \"reasoning\",\n          text: reasoningText\n        });\n        transformedContent.push({\n          type: \"text\",\n          text: textWithoutReasoning\n        });\n      }\n      return { content: transformedContent, ...rest };\n    },\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n      const reasoningExtractions = {};\n      let delayedTextStart;\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream({\n            transform: (chunk, controller) => {\n              if (chunk.type === \"text-start\") {\n                delayedTextStart = chunk;\n                return;\n              }\n              if (chunk.type === \"text-end\" && delayedTextStart) {\n                controller.enqueue(delayedTextStart);\n                delayedTextStart = void 0;\n              }\n              if (chunk.type !== \"text-delta\") {\n                controller.enqueue(chunk);\n                return;\n              }\n              if (reasoningExtractions[chunk.id] == null) {\n                reasoningExtractions[chunk.id] = {\n                  isFirstReasoning: true,\n                  isFirstText: true,\n                  afterSwitch: false,\n                  isReasoning: startWithReasoning,\n                  buffer: \"\",\n                  idCounter: 0,\n                  textId: chunk.id\n                };\n              }\n              const activeExtraction = reasoningExtractions[chunk.id];\n              activeExtraction.buffer += chunk.delta;\n              function publish(text2) {\n                if (text2.length > 0) {\n                  const prefix = activeExtraction.afterSwitch && (activeExtraction.isReasoning ? !activeExtraction.isFirstReasoning : !activeExtraction.isFirstText) ? separator : \"\";\n                  if (activeExtraction.isReasoning && (activeExtraction.afterSwitch || activeExtraction.isFirstReasoning)) {\n                    controller.enqueue({\n                      type: \"reasoning-start\",\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  }\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: \"reasoning-delta\",\n                      delta: prefix + text2,\n                      id: `reasoning-${activeExtraction.idCounter}`\n                    });\n                  } else {\n                    if (delayedTextStart) {\n                      controller.enqueue(delayedTextStart);\n                      delayedTextStart = void 0;\n                    }\n                    controller.enqueue({\n                      type: \"text-delta\",\n                      delta: prefix + text2,\n                      id: activeExtraction.textId\n                    });\n                  }\n                  activeExtraction.afterSwitch = false;\n                  if (activeExtraction.isReasoning) {\n                    activeExtraction.isFirstReasoning = false;\n                  } else {\n                    activeExtraction.isFirstText = false;\n                  }\n                }\n              }\n              do {\n                const nextTag = activeExtraction.isReasoning ? closingTag : openingTag;\n                const startIndex = getPotentialStartIndex(\n                  activeExtraction.buffer,\n                  nextTag\n                );\n                if (startIndex == null) {\n                  publish(activeExtraction.buffer);\n                  activeExtraction.buffer = \"\";\n                  break;\n                }\n                publish(activeExtraction.buffer.slice(0, startIndex));\n                const foundFullMatch = startIndex + nextTag.length <= activeExtraction.buffer.length;\n                if (foundFullMatch) {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(\n                    startIndex + nextTag.length\n                  );\n                  if (activeExtraction.isReasoning) {\n                    if (activeExtraction.isFirstReasoning) {\n                      controller.enqueue({\n                        type: \"reasoning-start\",\n                        id: `reasoning-${activeExtraction.idCounter}`\n                      });\n                    }\n                    controller.enqueue({\n                      type: \"reasoning-end\",\n                      id: `reasoning-${activeExtraction.idCounter++}`\n                    });\n                  }\n                  activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                  activeExtraction.afterSwitch = true;\n                } else {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            }\n          })\n        ),\n        ...rest\n      };\n    }\n  };\n}\n\n// src/middleware/simulate-streaming-middleware.ts\nfunction simulateStreamingMiddleware() {\n  return {\n    specificationVersion: \"v3\",\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n      let id = 0;\n      const simulatedStream = new ReadableStream({\n        start(controller) {\n          controller.enqueue({\n            type: \"stream-start\",\n            warnings: result.warnings\n          });\n          controller.enqueue({ type: \"response-metadata\", ...result.response });\n          for (const part of result.content) {\n            switch (part.type) {\n              case \"text\": {\n                if (part.text.length > 0) {\n                  controller.enqueue({ type: \"text-start\", id: String(id) });\n                  controller.enqueue({\n                    type: \"text-delta\",\n                    id: String(id),\n                    delta: part.text\n                  });\n                  controller.enqueue({ type: \"text-end\", id: String(id) });\n                  id++;\n                }\n                break;\n              }\n              case \"reasoning\": {\n                controller.enqueue({\n                  type: \"reasoning-start\",\n                  id: String(id),\n                  providerMetadata: part.providerMetadata\n                });\n                controller.enqueue({\n                  type: \"reasoning-delta\",\n                  id: String(id),\n                  delta: part.text\n                });\n                controller.enqueue({ type: \"reasoning-end\", id: String(id) });\n                id++;\n                break;\n              }\n              default: {\n                controller.enqueue(part);\n                break;\n              }\n            }\n          }\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata\n          });\n          controller.close();\n        }\n      });\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response\n      };\n    }\n  };\n}\n\n// src/middleware/add-tool-input-examples-middleware.ts\nfunction defaultFormatExample(example) {\n  return JSON.stringify(example.input);\n}\nfunction addToolInputExamplesMiddleware({\n  prefix = \"Input Examples:\",\n  format = defaultFormatExample,\n  remove = true\n} = {}) {\n  return {\n    specificationVersion: \"v3\",\n    transformParams: async ({ params }) => {\n      var _a21;\n      if (!((_a21 = params.tools) == null ? void 0 : _a21.length)) {\n        return params;\n      }\n      const transformedTools = params.tools.map((tool2) => {\n        var _a22;\n        if (tool2.type !== \"function\" || !((_a22 = tool2.inputExamples) == null ? void 0 : _a22.length)) {\n          return tool2;\n        }\n        const formattedExamples = tool2.inputExamples.map((example, index) => format(example, index)).join(\"\\n\");\n        const examplesSection = `${prefix}\n${formattedExamples}`;\n        const toolDescription = tool2.description ? `${tool2.description}\n\n${examplesSection}` : examplesSection;\n        return {\n          ...tool2,\n          description: toolDescription,\n          inputExamples: remove ? void 0 : tool2.inputExamples\n        };\n      });\n      return {\n        ...params,\n        tools: transformedTools\n      };\n    }\n  };\n}\n\n// src/middleware/wrap-language-model.ts\nvar wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    wrapStream,\n    overrideProvider,\n    overrideModelId,\n    overrideSupportedUrls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a21, _b, _c;\n  async function doTransform({\n    params,\n    type\n  }) {\n    return transformParams ? await transformParams({ params, type, model }) : params;\n  }\n  return {\n    specificationVersion: \"v3\",\n    provider: (_a21 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a21 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    supportedUrls: (_c = overrideSupportedUrls == null ? void 0 : overrideSupportedUrls({ model })) != null ? _c : model.supportedUrls,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params, type: \"generate\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        doStream,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    },\n    async doStream(params) {\n      const transformedParams = await doTransform({ params, type: \"stream\" });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream ? wrapStream({ doGenerate, doStream, params: transformedParams, model }) : doStream();\n    }\n  };\n};\n\n// src/middleware/wrap-embedding-model.ts\nvar wrapEmbeddingModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap2({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap2 = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapEmbed,\n    overrideProvider,\n    overrideModelId,\n    overrideMaxEmbeddingsPerCall,\n    overrideSupportsParallelCalls\n  },\n  modelId,\n  providerId\n}) => {\n  var _a21, _b, _c, _d;\n  async function doTransform({\n    params\n  }) {\n    return transformParams ? await transformParams({ params, model }) : params;\n  }\n  return {\n    specificationVersion: \"v3\",\n    provider: (_a21 = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _a21 : model.provider,\n    modelId: (_b = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _b : model.modelId,\n    maxEmbeddingsPerCall: (_c = overrideMaxEmbeddingsPerCall == null ? void 0 : overrideMaxEmbeddingsPerCall({ model })) != null ? _c : model.maxEmbeddingsPerCall,\n    supportsParallelCalls: (_d = overrideSupportsParallelCalls == null ? void 0 : overrideSupportsParallelCalls({ model })) != null ? _d : model.supportsParallelCalls,\n    async doEmbed(params) {\n      const transformedParams = await doTransform({ params });\n      const doEmbed = async () => model.doEmbed(transformedParams);\n      return wrapEmbed ? wrapEmbed({\n        doEmbed,\n        params: transformedParams,\n        model\n      }) : doEmbed();\n    }\n  };\n};\n\n// src/middleware/wrap-image-model.ts\nvar wrapImageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId\n}) => {\n  return [...asArray(middlewareArg)].reverse().reduce((wrappedModel, middleware) => {\n    return doWrap3({ model: wrappedModel, middleware, modelId, providerId });\n  }, model);\n};\nvar doWrap3 = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    overrideProvider,\n    overrideModelId,\n    overrideMaxImagesPerCall\n  },\n  modelId,\n  providerId\n}) => {\n  var _a21, _b, _c;\n  async function doTransform({ params }) {\n    return transformParams ? await transformParams({ params, model }) : params;\n  }\n  const maxImagesPerCallRaw = (_a21 = overrideMaxImagesPerCall == null ? void 0 : overrideMaxImagesPerCall({ model })) != null ? _a21 : model.maxImagesPerCall;\n  const maxImagesPerCall = maxImagesPerCallRaw instanceof Function ? maxImagesPerCallRaw.bind(model) : maxImagesPerCallRaw;\n  return {\n    specificationVersion: \"v3\",\n    provider: (_b = providerId != null ? providerId : overrideProvider == null ? void 0 : overrideProvider({ model })) != null ? _b : model.provider,\n    modelId: (_c = modelId != null ? modelId : overrideModelId == null ? void 0 : overrideModelId({ model })) != null ? _c : model.modelId,\n    maxImagesPerCall,\n    async doGenerate(params) {\n      const transformedParams = await doTransform({ params });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      return wrapGenerate ? wrapGenerate({\n        doGenerate,\n        params: transformedParams,\n        model\n      }) : doGenerate();\n    }\n  };\n};\n\n// src/model/as-provider-v3.ts\nfunction asProviderV3(provider) {\n  if (\"specificationVersion\" in provider && provider.specificationVersion === \"v3\") {\n    return provider;\n  }\n  const v2Provider = provider;\n  return {\n    specificationVersion: \"v3\",\n    languageModel: (modelId) => asLanguageModelV3(v2Provider.languageModel(modelId)),\n    embeddingModel: (modelId) => asEmbeddingModelV3(v2Provider.textEmbeddingModel(modelId)),\n    imageModel: (modelId) => asImageModelV3(v2Provider.imageModel(modelId)),\n    transcriptionModel: v2Provider.transcriptionModel ? (modelId) => asTranscriptionModelV3(v2Provider.transcriptionModel(modelId)) : void 0,\n    speechModel: v2Provider.speechModel ? (modelId) => asSpeechModelV3(v2Provider.speechModel(modelId)) : void 0,\n    rerankingModel: void 0\n    // v2 providers don't have reranking models\n  };\n}\n\n// src/middleware/wrap-provider.ts\nfunction wrapProvider({\n  provider,\n  languageModelMiddleware,\n  imageModelMiddleware\n}) {\n  const providerV3 = asProviderV3(provider);\n  return {\n    specificationVersion: \"v3\",\n    languageModel: (modelId) => wrapLanguageModel({\n      model: providerV3.languageModel(modelId),\n      middleware: languageModelMiddleware\n    }),\n    embeddingModel: providerV3.embeddingModel,\n    imageModel: (modelId) => {\n      let model = providerV3.imageModel(modelId);\n      if (imageModelMiddleware != null) {\n        model = wrapImageModel({ model, middleware: imageModelMiddleware });\n      }\n      return model;\n    },\n    transcriptionModel: providerV3.transcriptionModel,\n    speechModel: providerV3.speechModel,\n    rerankingModel: providerV3.rerankingModel\n  };\n}\n\n// src/registry/custom-provider.ts\n\nfunction customProvider({\n  languageModels,\n  embeddingModels,\n  imageModels,\n  transcriptionModels,\n  speechModels,\n  rerankingModels,\n  fallbackProvider: fallbackProviderArg\n}) {\n  const fallbackProvider = fallbackProviderArg ? asProviderV3(fallbackProviderArg) : void 0;\n  return {\n    specificationVersion: \"v3\",\n    languageModel(modelId) {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.languageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"languageModel\" });\n    },\n    embeddingModel(modelId) {\n      if (embeddingModels != null && modelId in embeddingModels) {\n        return embeddingModels[modelId];\n      }\n      if (fallbackProvider) {\n        return fallbackProvider.embeddingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"embeddingModel\" });\n    },\n    imageModel(modelId) {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {\n        return fallbackProvider.imageModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"imageModel\" });\n    },\n    transcriptionModel(modelId) {\n      if (transcriptionModels != null && modelId in transcriptionModels) {\n        return transcriptionModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.transcriptionModel) {\n        return fallbackProvider.transcriptionModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"transcriptionModel\" });\n    },\n    speechModel(modelId) {\n      if (speechModels != null && modelId in speechModels) {\n        return speechModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.speechModel) {\n        return fallbackProvider.speechModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"speechModel\" });\n    },\n    rerankingModel(modelId) {\n      if (rerankingModels != null && modelId in rerankingModels) {\n        return rerankingModels[modelId];\n      }\n      if (fallbackProvider == null ? void 0 : fallbackProvider.rerankingModel) {\n        return fallbackProvider.rerankingModel(modelId);\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId, modelType: \"rerankingModel\" });\n    }\n  };\n}\nvar experimental_customProvider = customProvider;\n\n// src/registry/no-such-provider-error.ts\n\nvar name20 = \"AI_NoSuchProviderError\";\nvar marker20 = `vercel.ai.error.${name20}`;\nvar symbol20 = Symbol.for(marker20);\nvar _a20;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`\n  }) {\n    super({ errorName: name20, modelId, modelType, message });\n    this[_a20] = true;\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n  static isInstance(error) {\n    return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker20);\n  }\n};\n_a20 = symbol20;\n\n// src/registry/provider-registry.ts\n\nfunction createProviderRegistry(providers, {\n  separator = \":\",\n  languageModelMiddleware,\n  imageModelMiddleware\n} = {}) {\n  const registry = new DefaultProviderRegistry({\n    separator,\n    languageModelMiddleware,\n    imageModelMiddleware\n  });\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider });\n  }\n  return registry;\n}\nvar experimental_createProviderRegistry = createProviderRegistry;\nvar DefaultProviderRegistry = class {\n  constructor({\n    separator,\n    languageModelMiddleware,\n    imageModelMiddleware\n  }) {\n    this.providers = {};\n    this.separator = separator;\n    this.languageModelMiddleware = languageModelMiddleware;\n    this.imageModelMiddleware = imageModelMiddleware;\n  }\n  registerProvider({\n    id,\n    provider\n  }) {\n    this.providers[id] = provider;\n  }\n  getProvider(id, modelType) {\n    const provider = this.providers[id];\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType,\n        providerId: id,\n        availableProviders: Object.keys(this.providers)\n      });\n    }\n    return provider;\n  }\n  splitId(id, modelType) {\n    const index = id.indexOf(this.separator);\n    if (index === -1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType,\n        message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId${this.separator}modelId\")`\n      });\n    }\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n  languageModel(id) {\n    var _a21, _b;\n    const [providerId, modelId] = this.splitId(id, \"languageModel\");\n    let model = (_b = (_a21 = this.getProvider(providerId, \"languageModel\")).languageModel) == null ? void 0 : _b.call(\n      _a21,\n      modelId\n    );\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"languageModel\" });\n    }\n    if (this.languageModelMiddleware != null) {\n      model = wrapLanguageModel({\n        model,\n        middleware: this.languageModelMiddleware\n      });\n    }\n    return model;\n  }\n  embeddingModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"embeddingModel\");\n    const provider = this.getProvider(providerId, \"embeddingModel\");\n    const model = (_a21 = provider.embeddingModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"embeddingModel\"\n      });\n    }\n    return model;\n  }\n  imageModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"imageModel\");\n    const provider = this.getProvider(providerId, \"imageModel\");\n    let model = (_a21 = provider.imageModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"imageModel\" });\n    }\n    if (this.imageModelMiddleware != null) {\n      model = wrapImageModel({\n        model,\n        middleware: this.imageModelMiddleware\n      });\n    }\n    return model;\n  }\n  transcriptionModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"transcriptionModel\");\n    const provider = this.getProvider(providerId, \"transcriptionModel\");\n    const model = (_a21 = provider.transcriptionModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n        modelId: id,\n        modelType: \"transcriptionModel\"\n      });\n    }\n    return model;\n  }\n  speechModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"speechModel\");\n    const provider = this.getProvider(providerId, \"speechModel\");\n    const model = (_a21 = provider.speechModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"speechModel\" });\n    }\n    return model;\n  }\n  rerankingModel(id) {\n    var _a21;\n    const [providerId, modelId] = this.splitId(id, \"rerankingModel\");\n    const provider = this.getProvider(providerId, \"rerankingModel\");\n    const model = (_a21 = provider.rerankingModel) == null ? void 0 : _a21.call(provider, modelId);\n    if (model == null) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({ modelId: id, modelType: \"rerankingModel\" });\n    }\n    return model;\n  }\n};\n\n// src/rerank/rerank.ts\nasync function rerank({\n  model,\n  documents,\n  query,\n  topN,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry\n}) {\n  if (documents.length === 0) {\n    return new DefaultRerankResult({\n      originalDocuments: [],\n      ranking: [],\n      providerMetadata: void 0,\n      response: {\n        timestamp: /* @__PURE__ */ new Date(),\n        modelId: model.modelId\n      }\n    });\n  }\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const documentsToSend = typeof documents[0] === \"string\" ? { type: \"text\", values: documents } : { type: \"object\", values: documents };\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries }\n  });\n  const tracer = getTracer(telemetry);\n  return recordSpan({\n    name: \"ai.rerank\",\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: \"ai.rerank\", telemetry }),\n        ...baseTelemetryAttributes,\n        \"ai.documents\": {\n          input: () => documents.map((document) => JSON.stringify(document))\n        }\n      }\n    }),\n    tracer,\n    fn: async () => {\n      var _a21, _b;\n      const { ranking, response, providerMetadata, warnings } = await retry(\n        () => recordSpan({\n          name: \"ai.rerank.doRerank\",\n          attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              ...assembleOperationName({\n                operationId: \"ai.rerank.doRerank\",\n                telemetry\n              }),\n              ...baseTelemetryAttributes,\n              // specific settings that only make sense on the outer level:\n              \"ai.documents\": {\n                input: () => documents.map((document) => JSON.stringify(document))\n              }\n            }\n          }),\n          tracer,\n          fn: async (doRerankSpan) => {\n            const modelResponse = await model.doRerank({\n              documents: documentsToSend,\n              query,\n              topN,\n              providerOptions,\n              abortSignal,\n              headers\n            });\n            const ranking2 = modelResponse.ranking;\n            doRerankSpan.setAttributes(\n              await selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  \"ai.ranking.type\": documentsToSend.type,\n                  \"ai.ranking\": {\n                    output: () => ranking2.map((ranking3) => JSON.stringify(ranking3))\n                  }\n                }\n              })\n            );\n            return {\n              ranking: ranking2,\n              providerMetadata: modelResponse.providerMetadata,\n              response: modelResponse.response,\n              warnings: modelResponse.warnings\n            };\n          }\n        })\n      );\n      logWarnings({\n        warnings: warnings != null ? warnings : [],\n        provider: model.provider,\n        model: model.modelId\n      });\n      return new DefaultRerankResult({\n        originalDocuments: documents,\n        ranking: ranking.map((ranking2) => ({\n          originalIndex: ranking2.index,\n          score: ranking2.relevanceScore,\n          document: documents[ranking2.index]\n        })),\n        providerMetadata,\n        response: {\n          id: response == null ? void 0 : response.id,\n          timestamp: (_a21 = response == null ? void 0 : response.timestamp) != null ? _a21 : /* @__PURE__ */ new Date(),\n          modelId: (_b = response == null ? void 0 : response.modelId) != null ? _b : model.modelId,\n          headers: response == null ? void 0 : response.headers,\n          body: response == null ? void 0 : response.body\n        }\n      });\n    }\n  });\n}\nvar DefaultRerankResult = class {\n  constructor(options) {\n    this.originalDocuments = options.originalDocuments;\n    this.ranking = options.ranking;\n    this.response = options.response;\n    this.providerMetadata = options.providerMetadata;\n  }\n  get rerankedDocuments() {\n    return this.ranking.map((ranking) => ranking.document);\n  }\n};\n\n// src/transcribe/transcribe.ts\n\nasync function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers\n}) {\n  const resolvedModel = resolveTranscriptionModel(model);\n  if (!resolvedModel) {\n    throw new Error(\"Model could not be resolved\");\n  }\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal\n  });\n  const headersWithUserAgent = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n    headers != null ? headers : {},\n    `ai/${VERSION}`\n  );\n  const audioData = audio instanceof URL ? (await download({ url: audio })).data : convertDataContentToUint8Array(audio);\n  const result = await retry(\n    () => {\n      var _a21;\n      return resolvedModel.doGenerate({\n        audio: audioData,\n        abortSignal,\n        headers: headersWithUserAgent,\n        providerOptions,\n        mediaType: (_a21 = detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures\n        })) != null ? _a21 : \"audio/wav\"\n      });\n    }\n  );\n  logWarnings({\n    warnings: result.warnings,\n    provider: resolvedModel.provider,\n    model: resolvedModel.modelId\n  });\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata\n  });\n}\nvar DefaultTranscriptionResult = class {\n  constructor(options) {\n    var _a21;\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = (_a21 = options.providerMetadata) != null ? _a21 : {};\n  }\n};\n\n// src/ui/call-completion-api.ts\n\n\n// src/ui/process-text-stream.ts\nasync function processTextStream({\n  stream,\n  onTextPart\n}) {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n\n// src/ui/call-completion-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a21;\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const response = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_a21 = await response.text()) != null ? _a21 : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    switch (streamProtocol) {\n      case \"text\": {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: (chunk) => {\n            result += chunk;\n            setCompletion(result);\n          }\n        });\n        break;\n      }\n      case \"data\": {\n        await consumeStream({\n          stream: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n            stream: response.body,\n            schema: uiMessageChunkSchema\n          }).pipeThrough(\n            new TransformStream({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n                const streamPart = part.value;\n                if (streamPart.type === \"text-delta\") {\n                  result += streamPart.delta;\n                  setCompletion(result);\n                } else if (streamPart.type === \"error\") {\n                  throw new Error(streamPart.errorText);\n                }\n              }\n            })\n          ),\n          onError: (error) => {\n            throw error;\n          }\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/ui/chat.ts\n\n\n// src/ui/convert-file-list-to-file-ui-parts.ts\nasync function convertFileListToFileUIParts(files) {\n  if (files == null) {\n    return [];\n  }\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error(\"FileList is not supported in the current environment\");\n  }\n  return Promise.all(\n    Array.from(files).map(async (file) => {\n      const { name: name21, type } = file;\n      const dataUrl = await new Promise((resolve3, reject) => {\n        const reader = new FileReader();\n        reader.onload = (readerEvent) => {\n          var _a21;\n          resolve3((_a21 = readerEvent.target) == null ? void 0 : _a21.result);\n        };\n        reader.onerror = (error) => reject(error);\n        reader.readAsDataURL(file);\n      });\n      return {\n        type: \"file\",\n        mediaType: type,\n        filename: name21,\n        url: dataUrl\n      };\n    })\n  );\n}\n\n// src/ui/default-chat-transport.ts\n\n\n// src/ui/http-chat-transport.ts\n\nvar HttpChatTransport = class {\n  constructor({\n    api = \"/api/chat\",\n    credentials,\n    headers,\n    body,\n    fetch: fetch2,\n    prepareSendMessagesRequest,\n    prepareReconnectToStreamRequest\n  }) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.fetch = fetch2;\n    this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n    this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n  }\n  async sendMessages({\n    abortSignal,\n    ...options\n  }) {\n    var _a21, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const baseHeaders = {\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n    };\n    const preparedRequest = await ((_a21 = this.prepareSendMessagesRequest) == null ? void 0 : _a21.call(this, {\n      api: this.api,\n      id: options.chatId,\n      messages: options.messages,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n      trigger: options.trigger,\n      messageId: options.messageId\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : this.api;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n    const body = (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {\n      ...resolvedBody,\n      ...options.body,\n      id: options.chatId,\n      messages: options.messages,\n      trigger: options.trigger,\n      messageId: options.messageId\n    };\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"POST\",\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      body: JSON.stringify(body),\n      credentials,\n      signal: abortSignal\n    });\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n  async reconnectToStream(options) {\n    var _a21, _b, _c, _d, _e;\n    const resolvedBody = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.body);\n    const resolvedHeaders = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.headers);\n    const resolvedCredentials = await (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.resolve)(this.credentials);\n    const baseHeaders = {\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(resolvedHeaders),\n      ...(0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(options.headers)\n    };\n    const preparedRequest = await ((_a21 = this.prepareReconnectToStreamRequest) == null ? void 0 : _a21.call(this, {\n      api: this.api,\n      id: options.chatId,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata\n    }));\n    const api = (_b = preparedRequest == null ? void 0 : preparedRequest.api) != null ? _b : `${this.api}/${options.chatId}/stream`;\n    const headers = (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.normalizeHeaders)(preparedRequest.headers) : baseHeaders;\n    const credentials = (_c = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _c : resolvedCredentials;\n    const fetch2 = (_d = this.fetch) != null ? _d : globalThis.fetch;\n    const response = await fetch2(api, {\n      method: \"GET\",\n      headers: (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.withUserAgentSuffix)(\n        headers,\n        `ai-sdk/${VERSION}`,\n        (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.getRuntimeEnvironmentUserAgent)()\n      ),\n      credentials\n    });\n    if (response.status === 204) {\n      return null;\n    }\n    if (!response.ok) {\n      throw new Error(\n        (_e = await response.text()) != null ? _e : \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!response.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    return this.processResponseStream(response.body);\n  }\n};\n\n// src/ui/default-chat-transport.ts\nvar DefaultChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.parseJsonEventStream)({\n      stream,\n      schema: uiMessageChunkSchema\n    }).pipeThrough(\n      new TransformStream({\n        async transform(chunk, controller) {\n          if (!chunk.success) {\n            throw chunk.error;\n          }\n          controller.enqueue(chunk.value);\n        }\n      })\n    );\n  }\n};\n\n// src/ui/chat.ts\nvar AbstractChat = class {\n  constructor({\n    generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_2__.generateId,\n    id = generateId2(),\n    transport = new DefaultChatTransport(),\n    messageMetadataSchema,\n    dataPartSchemas,\n    state,\n    onError,\n    onToolCall,\n    onFinish,\n    onData,\n    sendAutomaticallyWhen\n  }) {\n    this.activeResponse = void 0;\n    this.jobExecutor = new SerialJobExecutor();\n    /**\n     * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n     * the assistant's response.\n     *\n     * If a messageId is provided, the message will be replaced.\n     */\n    this.sendMessage = async (message, options) => {\n      var _a21, _b, _c, _d;\n      if (message == null) {\n        await this.makeRequest({\n          trigger: \"submit-message\",\n          messageId: (_a21 = this.lastMessage) == null ? void 0 : _a21.id,\n          ...options\n        });\n        return;\n      }\n      let uiMessage;\n      if (\"text\" in message || \"files\" in message) {\n        const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);\n        uiMessage = {\n          parts: [\n            ...fileParts,\n            ...\"text\" in message && message.text != null ? [{ type: \"text\", text: message.text }] : []\n          ]\n        };\n      } else {\n        uiMessage = message;\n      }\n      if (message.messageId != null) {\n        const messageIndex = this.state.messages.findIndex(\n          (m) => m.id === message.messageId\n        );\n        if (messageIndex === -1) {\n          throw new Error(`message with id ${message.messageId} not found`);\n        }\n        if (this.state.messages[messageIndex].role !== \"user\") {\n          throw new Error(\n            `message with id ${message.messageId} is not a user message`\n          );\n        }\n        this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n        this.state.replaceMessage(messageIndex, {\n          ...uiMessage,\n          id: message.messageId,\n          role: (_b = uiMessage.role) != null ? _b : \"user\",\n          metadata: message.metadata\n        });\n      } else {\n        this.state.pushMessage({\n          ...uiMessage,\n          id: (_c = uiMessage.id) != null ? _c : this.generateId(),\n          role: (_d = uiMessage.role) != null ? _d : \"user\",\n          metadata: message.metadata\n        });\n      }\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: message.messageId,\n        ...options\n      });\n    };\n    /**\n     * Regenerate the assistant message with the provided message id.\n     * If no message id is provided, the last assistant message will be regenerated.\n     */\n    this.regenerate = async ({\n      messageId,\n      ...options\n    } = {}) => {\n      const messageIndex = messageId == null ? this.state.messages.length - 1 : this.state.messages.findIndex((message) => message.id === messageId);\n      if (messageIndex === -1) {\n        throw new Error(`message ${messageId} not found`);\n      }\n      this.state.messages = this.state.messages.slice(\n        0,\n        // if the message is a user message, we need to include it in the request:\n        this.messages[messageIndex].role === \"assistant\" ? messageIndex : messageIndex + 1\n      );\n      await this.makeRequest({\n        trigger: \"regenerate-message\",\n        messageId,\n        ...options\n      });\n    };\n    /**\n     * Attempt to resume an ongoing streaming response.\n     */\n    this.resumeStream = async (options = {}) => {\n      await this.makeRequest({ trigger: \"resume-stream\", ...options });\n    };\n    /**\n     * Clear the error state and set the status to ready if the chat is in an error state.\n     */\n    this.clearError = () => {\n      if (this.status === \"error\") {\n        this.state.error = void 0;\n        this.setStatus({ status: \"ready\" });\n      }\n    };\n    this.addToolApprovalResponse = async ({\n      id,\n      approved,\n      reason\n    }) => this.jobExecutor.run(async () => {\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      const updatePart = (part) => isToolUIPart(part) && part.state === \"approval-requested\" && part.approval.id === id ? {\n        ...part,\n        state: \"approval-responded\",\n        approval: { id, approved, reason }\n      } : part;\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(updatePart)\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && this.sendAutomaticallyWhen) {\n        this.shouldSendAutomatically().then((shouldSend) => {\n          var _a21;\n          if (shouldSend) {\n            this.makeRequest({\n              trigger: \"submit-message\",\n              messageId: (_a21 = this.lastMessage) == null ? void 0 : _a21.id\n            });\n          }\n        });\n      }\n    });\n    this.addToolOutput = async ({\n      state = \"output-available\",\n      tool: tool2,\n      toolCallId,\n      output,\n      errorText\n    }) => this.jobExecutor.run(async () => {\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n      const updatePart = (part) => isToolUIPart(part) && part.toolCallId === toolCallId ? { ...part, state, output, errorText } : part;\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(updatePart)\n      });\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts = this.activeResponse.state.message.parts.map(updatePart);\n      }\n      if (this.status !== \"streaming\" && this.status !== \"submitted\" && this.sendAutomaticallyWhen) {\n        this.shouldSendAutomatically().then((shouldSend) => {\n          var _a21;\n          if (shouldSend) {\n            this.makeRequest({\n              trigger: \"submit-message\",\n              messageId: (_a21 = this.lastMessage) == null ? void 0 : _a21.id\n            });\n          }\n        });\n      }\n    });\n    /** @deprecated Use addToolOutput */\n    this.addToolResult = this.addToolOutput;\n    /**\n     * Abort the current request immediately, keep the generated tokens if any.\n     */\n    this.stop = async () => {\n      var _a21;\n      if (this.status !== \"streaming\" && this.status !== \"submitted\")\n        return;\n      if ((_a21 = this.activeResponse) == null ? void 0 : _a21.abortController) {\n        this.activeResponse.abortController.abort();\n      }\n    };\n    this.id = id;\n    this.transport = transport;\n    this.generateId = generateId2;\n    this.messageMetadataSchema = messageMetadataSchema;\n    this.dataPartSchemas = dataPartSchemas;\n    this.state = state;\n    this.onError = onError;\n    this.onToolCall = onToolCall;\n    this.onFinish = onFinish;\n    this.onData = onData;\n    this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n  }\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  get status() {\n    return this.state.status;\n  }\n  setStatus({\n    status,\n    error\n  }) {\n    if (this.status === status)\n      return;\n    this.state.status = status;\n    this.state.error = error;\n  }\n  get error() {\n    return this.state.error;\n  }\n  get messages() {\n    return this.state.messages;\n  }\n  get lastMessage() {\n    return this.state.messages[this.state.messages.length - 1];\n  }\n  set messages(messages) {\n    this.state.messages = messages;\n  }\n  async shouldSendAutomatically() {\n    if (!this.sendAutomaticallyWhen)\n      return false;\n    const result = this.sendAutomaticallyWhen({\n      messages: this.state.messages\n    });\n    if (result && typeof result === \"object\" && \"then\" in result) {\n      return await result;\n    }\n    return result;\n  }\n  async makeRequest({\n    trigger,\n    metadata,\n    headers,\n    body,\n    messageId\n  }) {\n    var _a21, _b, _c;\n    this.setStatus({ status: \"submitted\", error: void 0 });\n    const lastMessage = this.lastMessage;\n    let isAbort = false;\n    let isDisconnect = false;\n    let isError = false;\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: this.state.snapshot(lastMessage),\n          messageId: this.generateId()\n        }),\n        abortController: new AbortController()\n      };\n      activeResponse.abortController.signal.addEventListener(\"abort\", () => {\n        isAbort = true;\n      });\n      this.activeResponse = activeResponse;\n      let stream;\n      if (trigger === \"resume-stream\") {\n        const reconnect = await this.transport.reconnectToStream({\n          chatId: this.id,\n          metadata,\n          headers,\n          body\n        });\n        if (reconnect == null) {\n          this.setStatus({ status: \"ready\" });\n          return;\n        }\n        stream = reconnect;\n      } else {\n        stream = await this.transport.sendMessages({\n          chatId: this.id,\n          messages: this.state.messages,\n          abortSignal: activeResponse.abortController.signal,\n          metadata,\n          headers,\n          body,\n          trigger,\n          messageId\n        });\n      }\n      const runUpdateMessageJob = (job) => (\n        // serialize the job execution to avoid race conditions:\n        this.jobExecutor.run(\n          () => job({\n            state: activeResponse.state,\n            write: () => {\n              var _a22;\n              this.setStatus({ status: \"streaming\" });\n              const replaceLastMessage = activeResponse.state.message.id === ((_a22 = this.lastMessage) == null ? void 0 : _a22.id);\n              if (replaceLastMessage) {\n                this.state.replaceMessage(\n                  this.state.messages.length - 1,\n                  activeResponse.state.message\n                );\n              } else {\n                this.state.pushMessage(activeResponse.state.message);\n              }\n            }\n          })\n        )\n      );\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall: this.onToolCall,\n          onData: this.onData,\n          messageMetadataSchema: this.messageMetadataSchema,\n          dataPartSchemas: this.dataPartSchemas,\n          runUpdateMessageJob,\n          onError: (error) => {\n            throw error;\n          }\n        }),\n        onError: (error) => {\n          throw error;\n        }\n      });\n      this.setStatus({ status: \"ready\" });\n    } catch (err) {\n      if (isAbort || err.name === \"AbortError\") {\n        isAbort = true;\n        this.setStatus({ status: \"ready\" });\n        return null;\n      }\n      isError = true;\n      if (err instanceof TypeError && (err.message.toLowerCase().includes(\"fetch\") || err.message.toLowerCase().includes(\"network\"))) {\n        isDisconnect = true;\n      }\n      if (this.onError && err instanceof Error) {\n        this.onError(err);\n      }\n      this.setStatus({ status: \"error\", error: err });\n    } finally {\n      try {\n        (_b = this.onFinish) == null ? void 0 : _b.call(this, {\n          message: this.activeResponse.state.message,\n          messages: this.state.messages,\n          isAbort,\n          isDisconnect,\n          isError,\n          finishReason: (_a21 = this.activeResponse) == null ? void 0 : _a21.state.finishReason\n        });\n      } catch (err) {\n        console.error(err);\n      }\n      this.activeResponse = void 0;\n    }\n    if (!isError && await this.shouldSendAutomatically()) {\n      await this.makeRequest({\n        trigger: \"submit-message\",\n        messageId: (_c = this.lastMessage) == null ? void 0 : _c.id,\n        metadata,\n        headers,\n        body\n      });\n    }\n  }\n};\n\n// src/ui/direct-chat-transport.ts\nvar DirectChatTransport = class {\n  constructor({\n    agent,\n    options,\n    ...uiMessageStreamOptions\n  }) {\n    this.agent = agent;\n    this.agentOptions = options;\n    this.uiMessageStreamOptions = uiMessageStreamOptions;\n  }\n  async sendMessages({\n    messages,\n    abortSignal\n  }) {\n    const validatedMessages = await validateUIMessages({\n      messages,\n      tools: this.agent.tools\n    });\n    const modelMessages = await convertToModelMessages(validatedMessages, {\n      tools: this.agent.tools\n    });\n    const result = await this.agent.stream({\n      prompt: modelMessages,\n      abortSignal,\n      ...this.agentOptions !== void 0 ? { options: this.agentOptions } : {}\n    });\n    return result.toUIMessageStream(this.uiMessageStreamOptions);\n  }\n  /**\n   * Direct transport does not support reconnection since there is no\n   * persistent server-side stream to reconnect to.\n   *\n   * @returns Always returns `null`\n   */\n  async reconnectToStream(_options) {\n    return null;\n  }\n};\n\n// src/ui/last-assistant-message-is-complete-with-approval-responses.ts\nfunction lastAssistantMessageIsCompleteWithApprovalResponses({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part) => !part.providerExecuted);\n  return (\n    // has at least one tool approval response\n    lastStepToolInvocations.filter((part) => part.state === \"approval-responded\").length > 0 && // all tool approvals must have a response\n    lastStepToolInvocations.every(\n      (part) => part.state === \"output-available\" || part.state === \"output-error\" || part.state === \"approval-responded\"\n    )\n  );\n}\n\n// src/ui/last-assistant-message-is-complete-with-tool-calls.ts\nfunction lastAssistantMessageIsCompleteWithToolCalls({\n  messages\n}) {\n  const message = messages[messages.length - 1];\n  if (!message) {\n    return false;\n  }\n  if (message.role !== \"assistant\") {\n    return false;\n  }\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === \"step-start\" ? index : lastIndex;\n  }, -1);\n  const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter(isToolUIPart).filter((part) => !part.providerExecuted);\n  return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every(\n    (part) => part.state === \"output-available\" || part.state === \"output-error\"\n  );\n}\n\n// src/ui/transform-text-to-ui-message-stream.ts\nfunction transformTextToUiMessageStream({\n  stream\n}) {\n  return stream.pipeThrough(\n    new TransformStream({\n      start(controller) {\n        controller.enqueue({ type: \"start\" });\n        controller.enqueue({ type: \"start-step\" });\n        controller.enqueue({ type: \"text-start\", id: \"text-1\" });\n      },\n      async transform(part, controller) {\n        controller.enqueue({ type: \"text-delta\", id: \"text-1\", delta: part });\n      },\n      async flush(controller) {\n        controller.enqueue({ type: \"text-end\", id: \"text-1\" });\n        controller.enqueue({ type: \"finish-step\" });\n        controller.enqueue({ type: \"finish\" });\n      }\n    })\n  );\n}\n\n// src/ui/text-stream-chat-transport.ts\nvar TextStreamChatTransport = class extends HttpChatTransport {\n  constructor(options = {}) {\n    super(options);\n  }\n  processResponseStream(stream) {\n    return transformTextToUiMessageStream({\n      stream: stream.pipeThrough(new TextDecoderStream())\n    });\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTs7QUFFQTtBQUNxRTtBQVVyQzs7QUFFaEM7QUFLZ0M7O0FBRWhDO0FBZTBCOztBQUUxQjtBQUM4QztBQUM5QztBQUNBLGdDQUFnQyxLQUFLO0FBQ3JDO0FBQ0E7QUFDQSx5Q0FBeUMsd0RBQVU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlEQUFpRCxVQUFVLElBQUksUUFBUTtBQUN2RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVU7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQzZEO0FBQzdEO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLDJDQUEyQyx3REFBVztBQUN0RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSw2Q0FBNkMsd0RBQVc7QUFDeEQsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLHlFQUF5RSxXQUFXO0FBQ3BGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVc7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQzhFO0FBQzlFO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLDBDQUEwQyx3REFBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTLElBQUksaUVBQWUsUUFBUTtBQUM1RSxHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVc7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQzZEO0FBQzdEO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBLHFEQUFxRCx3REFBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QixXQUFXLG9DQUFvQyxXQUFXO0FBQ3ZGLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBVztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDNkQ7QUFDN0Q7QUFDQSxpQ0FBaUMsTUFBTTtBQUN2QztBQUNBO0FBQ0EsNENBQTRDLHdEQUFXO0FBQ3ZELGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkIsMENBQTBDLHVCQUF1QixtQ0FBbUMsRUFBRTtBQUNuSTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM2RDtBQUM3RDtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUixZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFXO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSwrQ0FBK0Msd0RBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSwwQ0FBMEMsd0RBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSw4QkFBOEI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSxvQ0FBb0Msd0RBQVk7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVMsS0FBSyw0RUFBNEUsMEJBQTBCLEdBQUc7QUFDOUssR0FBRztBQUNILFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRztBQUNuRztBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSx3Q0FBd0Msd0RBQVk7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGlFQUFnQixRQUFRO0FBQ3BFLEdBQUc7QUFDSCxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0RBQVk7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQzhEO0FBQzlELGlEQUFpRCx3REFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsaUJBQWlCLGdCQUFnQixpQkFBaUIsZUFBZSxnQkFBZ0I7QUFDN0gsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7QUFDOUQ7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0EseUNBQXlDLHdEQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSw0Q0FBNEMsd0RBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHLGVBQWU7QUFDNUgsR0FBRztBQUNILFlBQVksOEJBQThCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDOEQ7QUFDOUQ7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0EsNENBQTRDLHdEQUFZO0FBQ3hEO0FBQ0E7QUFDQSx3Q0FBd0MsS0FBSztBQUM3QyxHQUFHO0FBQ0gsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUM4RDtBQUM5RDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQSwyQ0FBMkMsd0RBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksdUJBQXVCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3REFBWTtBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDdUQ7O0FBRXZEO0FBQzhEO0FBQzlEO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBLCtCQUErQix3REFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQyxVQUFVLElBQUksTUFBTTtBQUN4RDtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsZUFBZSxnQkFBZ0I7QUFDOUQ7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsZUFBZSxnQkFBZ0I7QUFDOUQ7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVEsRUFBRSxnQkFBZ0I7QUFDMUM7QUFDQTtBQUNBLGdCQUFnQixRQUFRLEVBQUUsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0RBQU87QUFDN0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHZ0M7O0FBRWhDO0FBQ21FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RkFBMEI7QUFDdkMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usd0NBQXdDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG1EQUFtRCwyQkFBMkI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxzQ0FBc0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFDQUFxQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixx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QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNpRTtBQUNpQztBQUNsRztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsMEVBQTBFLE9BQU87QUFDakY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDBDQUEwQztBQUN6RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsaUJBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0JBQW9CO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1RUFBZ0I7QUFDdkM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7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QUEwQyw2QkFBNkI7QUFDdkUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixlQUFlO0FBQzVDLDZCQUE2QixvQkFBb0I7QUFDakQsNkJBQTZCLGtDQUFrQztBQUMvRCxPQUFPO0FBQ1A7QUFDQSw2QkFBNkIsK0NBQStDO0FBQzVFLE9BQU87QUFDUDtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0QsNkJBQTZCLHFCQUFxQjtBQUNsRCw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUErSEU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21yLWF2bGFtbmluZy8uL25vZGVfbW9kdWxlcy9haS9kaXN0L2luZGV4Lm1qcz8wYjg3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZTIxIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lMjEsIHsgZ2V0OiBhbGxbbmFtZTIxXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG5cbi8vIHNyYy9pbmRleC50c1xuaW1wb3J0IHsgY3JlYXRlR2F0ZXdheSwgZ2F0ZXdheSBhcyBnYXRld2F5MiB9IGZyb20gXCJAYWktc2RrL2dhdGV3YXlcIjtcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hNSxcbiAgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I1LFxuICBkeW5hbWljVG9vbCxcbiAgZ2VuZXJhdGVJZCxcbiAganNvblNjaGVtYSxcbiAgcGFyc2VKc29uRXZlbnRTdHJlYW0gYXMgcGFyc2VKc29uRXZlbnRTdHJlYW0zLFxuICB0b29sLFxuICB6b2RTY2hlbWEgYXMgem9kU2NoZW1hM1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvcixcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTUsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL2Vycm9yL2luZGV4LnRzXG5pbXBvcnQge1xuICBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMSxcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IsXG4gIEludmFsaWRSZXNwb25zZURhdGFFcnJvcixcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTG9hZFNldHRpbmdFcnJvcixcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIFRvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lID0gXCJBSV9JbnZhbGlkQXJndW1lbnRFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIEludmFsaWRBcmd1bWVudEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lLFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxufTtcbl9hID0gc3ltYm9sO1xuXG4vLyBzcmMvZXJyb3IvaW52YWxpZC1zdHJlYW0tcGFydC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTIgPSBcIkFJX0ludmFsaWRTdHJlYW1QYXJ0RXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIEludmFsaWRTdHJlYW1QYXJ0RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNodW5rLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTJdID0gdHJ1ZTtcbiAgICB0aGlzLmNodW5rID0gY2h1bms7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIyKTtcbiAgfVxufTtcbl9hMiA9IHN5bWJvbDI7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLXRvb2wtYXBwcm92YWwtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUzID0gXCJBSV9JbnZhbGlkVG9vbEFwcHJvdmFsRXJyb3JcIjtcbnZhciBtYXJrZXIzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUzfWA7XG52YXIgc3ltYm9sMyA9IFN5bWJvbC5mb3IobWFya2VyMyk7XG52YXIgX2EzO1xudmFyIEludmFsaWRUb29sQXBwcm92YWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7IGFwcHJvdmFsSWQgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUzLFxuICAgICAgbWVzc2FnZTogYFRvb2wgYXBwcm92YWwgcmVzcG9uc2UgcmVmZXJlbmNlcyB1bmtub3duIGFwcHJvdmFsSWQ6IFwiJHthcHByb3ZhbElkfVwiLiBObyBtYXRjaGluZyB0b29sLWFwcHJvdmFsLXJlcXVlc3QgZm91bmQgaW4gbWVzc2FnZSBoaXN0b3J5LmBcbiAgICB9KTtcbiAgICB0aGlzW19hM10gPSB0cnVlO1xuICAgIHRoaXMuYXBwcm92YWxJZCA9IGFwcHJvdmFsSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjMuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIzKTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvci9pbnZhbGlkLXRvb2wtaW5wdXQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjQsIGdldEVycm9yTWVzc2FnZSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRUb29sSW5wdXRFcnJvclwiO1xudmFyIG1hcmtlcjQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w0ID0gU3ltYm9sLmZvcihtYXJrZXI0KTtcbnZhciBfYTQ7XG52YXIgSW52YWxpZFRvb2xJbnB1dEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sSW5wdXQsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0IGZvciB0b29sICR7dG9vbE5hbWV9OiAke2dldEVycm9yTWVzc2FnZShjYXVzZSl9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTRdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xJbnB1dCA9IHRvb2xJbnB1dDtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI0KTtcbiAgfVxufTtcbl9hNCA9IHN5bWJvbDQ7XG5cbi8vIHNyYy9lcnJvci90b29sLWNhbGwtbm90LWZvdW5kLWZvci1hcHByb3ZhbC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX1Rvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbENhbGxJZCxcbiAgICBhcHByb3ZhbElkXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNSxcbiAgICAgIG1lc3NhZ2U6IGBUb29sIGNhbGwgXCIke3Rvb2xDYWxsSWR9XCIgbm90IGZvdW5kIGZvciBhcHByb3ZhbCByZXF1ZXN0IFwiJHthcHByb3ZhbElkfVwiLmBcbiAgICB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbENhbGxJZCA9IHRvb2xDYWxsSWQ7XG4gICAgdGhpcy5hcHByb3ZhbElkID0gYXBwcm92YWxJZDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjUpO1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9yL21pc3NpbmctdG9vbC1yZXN1bHQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU2ID0gXCJBSV9NaXNzaW5nVG9vbFJlc3VsdHNFcnJvclwiO1xudmFyIG1hcmtlcjYgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w2ID0gU3ltYm9sLmZvcihtYXJrZXI2KTtcbnZhciBfYTY7XG52YXIgTWlzc2luZ1Rvb2xSZXN1bHRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I2IHtcbiAgY29uc3RydWN0b3IoeyB0b29sQ2FsbElkcyB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZTogbmFtZTYsXG4gICAgICBtZXNzYWdlOiBgVG9vbCByZXN1bHQke3Rvb2xDYWxsSWRzLmxlbmd0aCA+IDEgPyBcInMgYXJlXCIgOiBcIiBpc1wifSBtaXNzaW5nIGZvciB0b29sIGNhbGwke3Rvb2xDYWxsSWRzLmxlbmd0aCA+IDEgPyBcInNcIiA6IFwiXCJ9ICR7dG9vbENhbGxJZHMuam9pbihcbiAgICAgICAgXCIsIFwiXG4gICAgICApfS5gXG4gICAgfSk7XG4gICAgdGhpc1tfYTZdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xDYWxsSWRzID0gdG9vbENhbGxJZHM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjYuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI2KTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvci9uby1pbWFnZS1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9Ob0ltYWdlR2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI3ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sNyA9IFN5bWJvbC5mb3IobWFya2VyNyk7XG52YXIgX2E3O1xudmFyIE5vSW1hZ2VHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjcge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSA9IFwiTm8gaW1hZ2UgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlLFxuICAgIHJlc3BvbnNlc1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTddID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjcpO1xuICB9XG59O1xuX2E3ID0gc3ltYm9sNztcblxuLy8gc3JjL2Vycm9yL25vLW9iamVjdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjggfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU4ID0gXCJBSV9Ob09iamVjdEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lOH1gO1xudmFyIHN5bWJvbDggPSBTeW1ib2wuZm9yKG1hcmtlcjgpO1xudmFyIF9hODtcbnZhciBOb09iamVjdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yOCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBvYmplY3QgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlLFxuICAgIHRleHQ6IHRleHQyLFxuICAgIHJlc3BvbnNlLFxuICAgIHVzYWdlLFxuICAgIGZpbmlzaFJlYXNvblxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgICB0aGlzLnRleHQgPSB0ZXh0MjtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy51c2FnZSA9IHVzYWdlO1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gZmluaXNoUmVhc29uO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I4Lmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbn07XG5fYTggPSBzeW1ib2w4O1xuXG4vLyBzcmMvZXJyb3Ivbm8tb3V0cHV0LWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yOSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTkgPSBcIkFJX05vT3V0cHV0R2VuZXJhdGVkRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIE5vT3V0cHV0R2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I5IHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBvdXRwdXQgZ2VuZXJhdGVkLlwiLFxuICAgIGNhdXNlXG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTksIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIHNyYy9lcnJvci9uby1zcGVlY2gtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTEwID0gXCJBSV9Ob1NwZWVjaEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyMTAgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEwfWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lMTAsXG4gICAgICBtZXNzYWdlOiBcIk5vIHNwZWVjaCBhdWRpbyBnZW5lcmF0ZWQuXCJcbiAgICB9KTtcbiAgICB0aGlzW19hMTBdID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEwKTtcbiAgfVxufTtcbl9hMTAgPSBzeW1ib2wxMDtcblxuLy8gc3JjL2Vycm9yL25vLXRyYW5zY3JpcHQtZ2VuZXJhdGVkLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxMSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTExID0gXCJBSV9Ob1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBOb1RyYW5zY3JpcHRHZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjExIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMSxcbiAgICAgIG1lc3NhZ2U6IFwiTm8gdHJhbnNjcmlwdCBnZW5lcmF0ZWQuXCJcbiAgICB9KTtcbiAgICB0aGlzW19hMTFdID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMS5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjExKTtcbiAgfVxufTtcbl9hMTEgPSBzeW1ib2wxMTtcblxuLy8gc3JjL2Vycm9yL25vLXZpZGVvLWdlbmVyYXRlZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMiA9IFwiQUlfTm9WaWRlb0dlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyMTIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTIgPSBTeW1ib2wuZm9yKG1hcmtlcjEyKTtcbnZhciBfYTEyO1xudmFyIE5vVmlkZW9HZW5lcmF0ZWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjEyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UgPSBcIk5vIHZpZGVvIGdlbmVyYXRlZC5cIixcbiAgICBjYXVzZSxcbiAgICByZXNwb25zZXNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTEyLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLnJlc3BvbnNlcyA9IHJlc3BvbnNlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTIuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzTm9WaWRlb0dlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEyICYmIHR5cGVvZiBlcnJvci5yZXNwb25zZXMgIT09IFwidW5kZWZpbmVkXCIgPyB0cnVlIDogZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgcmVzcG9uc2VzOiB0aGlzLnJlc3BvbnNlc1xuICAgIH07XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvci9uby1zdWNoLXRvb2wtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjEzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTMgPSBcIkFJX05vU3VjaFRvb2xFcnJvclwiO1xudmFyIG1hcmtlcjEzID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxM31gO1xudmFyIHN5bWJvbDEzID0gU3ltYm9sLmZvcihtYXJrZXIxMyk7XG52YXIgX2ExMztcbnZhciBOb1N1Y2hUb29sRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0b29sTmFtZSxcbiAgICBhdmFpbGFibGVUb29scyA9IHZvaWQgMCxcbiAgICBtZXNzYWdlID0gYE1vZGVsIHRyaWVkIHRvIGNhbGwgdW5hdmFpbGFibGUgdG9vbCAnJHt0b29sTmFtZX0nLiAke2F2YWlsYWJsZVRvb2xzID09PSB2b2lkIDAgPyBcIk5vIHRvb2xzIGFyZSBhdmFpbGFibGUuXCIgOiBgQXZhaWxhYmxlIHRvb2xzOiAke2F2YWlsYWJsZVRvb2xzLmpvaW4oXCIsIFwiKX0uYH1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxMywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTNdID0gdHJ1ZTtcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gICAgdGhpcy5hdmFpbGFibGVUb29scyA9IGF2YWlsYWJsZVRvb2xzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxMy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjEzKTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcblxuLy8gc3JjL2Vycm9yL3Rvb2wtY2FsbC1yZXBhaXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE0LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE0ID0gXCJBSV9Ub29sQ2FsbFJlcGFpckVycm9yXCI7XG52YXIgbWFya2VyMTQgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE0fWA7XG52YXIgc3ltYm9sMTQgPSBTeW1ib2wuZm9yKG1hcmtlcjE0KTtcbnZhciBfYTE0O1xudmFyIFRvb2xDYWxsUmVwYWlyRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYXVzZSxcbiAgICBvcmlnaW5hbEVycm9yLFxuICAgIG1lc3NhZ2UgPSBgRXJyb3IgcmVwYWlyaW5nIHRvb2wgY2FsbDogJHtnZXRFcnJvck1lc3NhZ2UyKGNhdXNlKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNCwgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTE0XSA9IHRydWU7XG4gICAgdGhpcy5vcmlnaW5hbEVycm9yID0gb3JpZ2luYWxFcnJvcjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTQuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNCk7XG4gIH1cbn07XG5fYTE0ID0gc3ltYm9sMTQ7XG5cbi8vIHNyYy9lcnJvci91bnN1cHBvcnRlZC1tb2RlbC12ZXJzaW9uLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE1IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IFwiQUlfVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvclwiLFxuICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIG1vZGVsIHZlcnNpb24gJHtvcHRpb25zLnZlcnNpb259IGZvciBwcm92aWRlciBcIiR7b3B0aW9ucy5wcm92aWRlcn1cIiBhbmQgbW9kZWwgXCIke29wdGlvbnMubW9kZWxJZH1cIi4gQUkgU0RLIDUgb25seSBzdXBwb3J0cyBtb2RlbHMgdGhhdCBpbXBsZW1lbnQgc3BlY2lmaWNhdGlvbiB2ZXJzaW9uIFwidjJcIi5gXG4gICAgfSk7XG4gICAgdGhpcy52ZXJzaW9uID0gb3B0aW9ucy52ZXJzaW9uO1xuICAgIHRoaXMucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICAgIHRoaXMubW9kZWxJZCA9IG9wdGlvbnMubW9kZWxJZDtcbiAgfVxufTtcblxuLy8gc3JjL2Vycm9yL3VpLW1lc3NhZ2Utc3RyZWFtLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE1ID0gXCJBSV9VSU1lc3NhZ2VTdHJlYW1FcnJvclwiO1xudmFyIG1hcmtlcjE1ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNX1gO1xudmFyIHN5bWJvbDE1ID0gU3ltYm9sLmZvcihtYXJrZXIxNSk7XG52YXIgX2ExNTtcbnZhciBVSU1lc3NhZ2VTdHJlYW1FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE2IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNodW5rVHlwZSxcbiAgICBjaHVua0lkLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE1LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExNV0gPSB0cnVlO1xuICAgIHRoaXMuY2h1bmtUeXBlID0gY2h1bmtUeXBlO1xuICAgIHRoaXMuY2h1bmtJZCA9IGNodW5rSWQ7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjE2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpO1xuICB9XG59O1xuX2ExNSA9IHN5bWJvbDE1O1xuXG4vLyBzcmMvcHJvbXB0L2ludmFsaWQtZGF0YS1jb250ZW50LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IxNyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE2ID0gXCJBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvclwiO1xudmFyIG1hcmtlcjE2ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxNn1gO1xudmFyIHN5bWJvbDE2ID0gU3ltYm9sLmZvcihtYXJrZXIxNik7XG52YXIgX2ExNjtcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE3IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE2LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hMTZdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxNy5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE2KTtcbiAgfVxufTtcbl9hMTYgPSBzeW1ib2wxNjtcblxuLy8gc3JjL3Byb21wdC9pbnZhbGlkLW1lc3NhZ2Utcm9sZS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTggfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxNyA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXIxNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTd9YDtcbnZhciBzeW1ib2wxNyA9IFN5bWJvbC5mb3IobWFya2VyMTcpO1xudmFyIF9hMTc7XG52YXIgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IxOCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMTddID0gdHJ1ZTtcbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IxOC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjE3KTtcbiAgfVxufTtcbl9hMTcgPSBzeW1ib2wxNztcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjE5IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMTggPSBcIkFJX01lc3NhZ2VDb252ZXJzaW9uRXJyb3JcIjtcbnZhciBtYXJrZXIxOCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTh9YDtcbnZhciBzeW1ib2wxOCA9IFN5bWJvbC5mb3IobWFya2VyMTgpO1xudmFyIF9hMTg7XG52YXIgTWVzc2FnZUNvbnZlcnNpb25FcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjE5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG9yaWdpbmFsTWVzc2FnZSxcbiAgICBtZXNzYWdlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUxOCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMThdID0gdHJ1ZTtcbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMTkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxOCk7XG4gIH1cbn07XG5fYTE4ID0gc3ltYm9sMTg7XG5cbi8vIHNyYy9lcnJvci9pbmRleC50c1xuaW1wb3J0IHsgRG93bmxvYWRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3JldHJ5LWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3IyMCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTE5ID0gXCJBSV9SZXRyeUVycm9yXCI7XG52YXIgbWFya2VyMTkgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTE5fWA7XG52YXIgc3ltYm9sMTkgPSBTeW1ib2wuZm9yKG1hcmtlcjE5KTtcbnZhciBfYTE5O1xudmFyIFJldHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyMCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnNcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTE5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExOV0gPSB0cnVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yMjAuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxOSk7XG4gIH1cbn07XG5fYTE5ID0gc3ltYm9sMTk7XG5cbi8vIHNyYy9sb2dnZXIvbG9nLXdhcm5pbmdzLnRzXG5mdW5jdGlvbiBmb3JtYXRXYXJuaW5nKHtcbiAgd2FybmluZyxcbiAgcHJvdmlkZXIsXG4gIG1vZGVsXG59KSB7XG4gIGNvbnN0IHByZWZpeCA9IGBBSSBTREsgV2FybmluZyAoJHtwcm92aWRlcn0gLyAke21vZGVsfSk6YDtcbiAgc3dpdGNoICh3YXJuaW5nLnR5cGUpIHtcbiAgICBjYXNlIFwidW5zdXBwb3J0ZWRcIjoge1xuICAgICAgbGV0IG1lc3NhZ2UgPSBgJHtwcmVmaXh9IFRoZSBmZWF0dXJlIFwiJHt3YXJuaW5nLmZlYXR1cmV9XCIgaXMgbm90IHN1cHBvcnRlZC5gO1xuICAgICAgaWYgKHdhcm5pbmcuZGV0YWlscykge1xuICAgICAgICBtZXNzYWdlICs9IGAgJHt3YXJuaW5nLmRldGFpbHN9YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICBjYXNlIFwiY29tcGF0aWJpbGl0eVwiOiB7XG4gICAgICBsZXQgbWVzc2FnZSA9IGAke3ByZWZpeH0gVGhlIGZlYXR1cmUgXCIke3dhcm5pbmcuZmVhdHVyZX1cIiBpcyB1c2VkIGluIGEgY29tcGF0aWJpbGl0eSBtb2RlLmA7XG4gICAgICBpZiAod2FybmluZy5kZXRhaWxzKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYCAke3dhcm5pbmcuZGV0YWlsc31gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuICAgIGNhc2UgXCJvdGhlclwiOiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke3dhcm5pbmcubWVzc2FnZX1gO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICByZXR1cm4gYCR7cHJlZml4fSAke0pTT04uc3RyaW5naWZ5KHdhcm5pbmcsIG51bGwsIDIpfWA7XG4gICAgfVxuICB9XG59XG52YXIgRklSU1RfV0FSTklOR19JTkZPX01FU1NBR0UgPSBcIkFJIFNESyBXYXJuaW5nIFN5c3RlbTogVG8gdHVybiBvZmYgd2FybmluZyBsb2dnaW5nLCBzZXQgdGhlIEFJX1NES19MT0dfV0FSTklOR1MgZ2xvYmFsIHRvIGZhbHNlLlwiO1xudmFyIGhhc0xvZ2dlZEJlZm9yZSA9IGZhbHNlO1xudmFyIGxvZ1dhcm5pbmdzID0gKG9wdGlvbnMpID0+IHtcbiAgaWYgKG9wdGlvbnMud2FybmluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxvZ2dlciA9IGdsb2JhbFRoaXMuQUlfU0RLX0xPR19XQVJOSU5HUztcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHR5cGVvZiBsb2dnZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGxvZ2dlcihvcHRpb25zKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFoYXNMb2dnZWRCZWZvcmUpIHtcbiAgICBoYXNMb2dnZWRCZWZvcmUgPSB0cnVlO1xuICAgIGNvbnNvbGUuaW5mbyhGSVJTVF9XQVJOSU5HX0lORk9fTUVTU0FHRSk7XG4gIH1cbiAgZm9yIChjb25zdCB3YXJuaW5nIG9mIG9wdGlvbnMud2FybmluZ3MpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBmb3JtYXRXYXJuaW5nKHtcbiAgICAgICAgd2FybmluZyxcbiAgICAgICAgcHJvdmlkZXI6IG9wdGlvbnMucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsXG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy9tb2RlbC9yZXNvbHZlLW1vZGVsLnRzXG5pbXBvcnQgeyBnYXRld2F5IH0gZnJvbSBcIkBhaS1zZGsvZ2F0ZXdheVwiO1xuXG4vLyBzcmMvdXRpbC9sb2ctdjItY29tcGF0aWJpbGl0eS13YXJuaW5nLnRzXG5mdW5jdGlvbiBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgcHJvdmlkZXIsXG4gIG1vZGVsSWRcbn0pIHtcbiAgbG9nV2FybmluZ3Moe1xuICAgIHdhcm5pbmdzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwiY29tcGF0aWJpbGl0eVwiLFxuICAgICAgICBmZWF0dXJlOiBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIsXG4gICAgICAgIGRldGFpbHM6IGBVc2luZyB2MiBzcGVjaWZpY2F0aW9uIGNvbXBhdGliaWxpdHkgbW9kZS4gU29tZSBmZWF0dXJlcyBtYXkgbm90IGJlIGF2YWlsYWJsZS5gXG4gICAgICB9XG4gICAgXSxcbiAgICBwcm92aWRlcixcbiAgICBtb2RlbDogbW9kZWxJZFxuICB9KTtcbn1cblxuLy8gc3JjL21vZGVsL2FzLWVtYmVkZGluZy1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNFbWJlZGRpbmdNb2RlbFYzKG1vZGVsKSB7XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9PT0gXCJ2M1wiKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGxvZ1YyQ29tcGF0aWJpbGl0eVdhcm5pbmcoe1xuICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHByb3AgPT09IFwic3BlY2lmaWNhdGlvblZlcnNpb25cIilcbiAgICAgICAgcmV0dXJuIFwidjNcIjtcbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL21vZGVsL2FzLWltYWdlLW1vZGVsLXYzLnRzXG5mdW5jdGlvbiBhc0ltYWdlTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1sYW5ndWFnZS1tb2RlbC12My50c1xuZnVuY3Rpb24gYXNMYW5ndWFnZU1vZGVsVjMobW9kZWwpIHtcbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbiAgbG9nVjJDb21wYXRpYmlsaXR5V2FybmluZyh7XG4gICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgUHJveHkobW9kZWwsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIFwidjNcIjtcbiAgICAgICAgY2FzZSBcImRvR2VuZXJhdGVcIjpcbiAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRhcmdldC5kb0dlbmVyYXRlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnZlcnRWMkZpbmlzaFJlYXNvblRvVjMocmVzdWx0LmZpbmlzaFJlYXNvbiksXG4gICAgICAgICAgICAgIHVzYWdlOiBjb252ZXJ0VjJVc2FnZVRvVjMocmVzdWx0LnVzYWdlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZG9TdHJlYW1cIjpcbiAgICAgICAgICByZXR1cm4gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRhcmdldC5kb1N0cmVhbSguLi5hcmdzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgICAgICAgc3RyZWFtOiBjb252ZXJ0VjJTdHJlYW1Ub1YzKHJlc3VsdC5zdHJlYW0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY29udmVydFYyU3RyZWFtVG9WMyhzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjb252ZXJ0VjJGaW5pc2hSZWFzb25Ub1YzKGNodW5rLmZpbmlzaFJlYXNvbiksXG4gICAgICAgICAgICAgIHVzYWdlOiBjb252ZXJ0VjJVc2FnZVRvVjMoY2h1bmsudXNhZ2UpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFYyRmluaXNoUmVhc29uVG9WMyhmaW5pc2hSZWFzb24pIHtcbiAgcmV0dXJuIHtcbiAgICB1bmlmaWVkOiBmaW5pc2hSZWFzb24gPT09IFwidW5rbm93blwiID8gXCJvdGhlclwiIDogZmluaXNoUmVhc29uLFxuICAgIHJhdzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0VjJVc2FnZVRvVjModXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2Vuczoge1xuICAgICAgdG90YWw6IHVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgbm9DYWNoZTogdm9pZCAwLFxuICAgICAgY2FjaGVSZWFkOiB1c2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgIGNhY2hlV3JpdGU6IHZvaWQgMFxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiB7XG4gICAgICB0b3RhbDogdXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgdGV4dDogdm9pZCAwLFxuICAgICAgcmVhc29uaW5nOiB1c2FnZS5yZWFzb25pbmdUb2tlbnNcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tb2RlbC9hcy1zcGVlY2gtbW9kZWwtdjMudHNcbmZ1bmN0aW9uIGFzU3BlZWNoTW9kZWxWMyhtb2RlbCkge1xuICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gPT09IFwidjNcIikge1xuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBsb2dWMkNvbXBhdGliaWxpdHlXYXJuaW5nKHtcbiAgICBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbiAgcmV0dXJuIG5ldyBQcm94eShtb2RlbCwge1xuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIGlmIChwcm9wID09PSBcInNwZWNpZmljYXRpb25WZXJzaW9uXCIpXG4gICAgICAgIHJldHVybiBcInYzXCI7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9tb2RlbC9hcy10cmFuc2NyaXB0aW9uLW1vZGVsLXYzLnRzXG5mdW5jdGlvbiBhc1RyYW5zY3JpcHRpb25Nb2RlbFYzKG1vZGVsKSB7XG4gIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiA9PT0gXCJ2M1wiKSB7XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGxvZ1YyQ29tcGF0aWJpbGl0eVdhcm5pbmcoe1xuICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gIH0pO1xuICByZXR1cm4gbmV3IFByb3h5KG1vZGVsLCB7XG4gICAgZ2V0KHRhcmdldCwgcHJvcCkge1xuICAgICAgaWYgKHByb3AgPT09IFwic3BlY2lmaWNhdGlvblZlcnNpb25cIilcbiAgICAgICAgcmV0dXJuIFwidjNcIjtcbiAgICAgIHJldHVybiB0YXJnZXRbcHJvcF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL21vZGVsL3Jlc29sdmUtbW9kZWwudHNcbmZ1bmN0aW9uIHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNMYW5ndWFnZU1vZGVsVjMobW9kZWwpO1xuICB9XG4gIHJldHVybiBnZXRHbG9iYWxQcm92aWRlcigpLmxhbmd1YWdlTW9kZWwobW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsKSB7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNFbWJlZGRpbmdNb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gZ2V0R2xvYmFsUHJvdmlkZXIoKS5lbWJlZGRpbmdNb2RlbChtb2RlbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlVHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsKSB7XG4gIHZhciBfYTIxLCBfYjtcbiAgaWYgKHR5cGVvZiBtb2RlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2M1wiICYmIG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICAgIGNvbnN0IHVuc3VwcG9ydGVkTW9kZWwgPSBtb2RlbDtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgICAgdmVyc2lvbjogdW5zdXBwb3J0ZWRNb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IHVuc3VwcG9ydGVkTW9kZWwucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsSWQ6IHVuc3VwcG9ydGVkTW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhc1RyYW5zY3JpcHRpb25Nb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gKF9iID0gKF9hMjEgPSBnZXRHbG9iYWxQcm92aWRlcigpKS50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMjEsIG1vZGVsKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTcGVlY2hNb2RlbChtb2RlbCkge1xuICB2YXIgX2EyMSwgX2I7XG4gIGlmICh0eXBlb2YgbW9kZWwgIT09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAobW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24gIT09IFwidjNcIiAmJiBtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2MlwiKSB7XG4gICAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRNb2RlbFZlcnNpb25FcnJvcih7XG4gICAgICAgIHZlcnNpb246IHVuc3VwcG9ydGVkTW9kZWwuc3BlY2lmaWNhdGlvblZlcnNpb24sXG4gICAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbElkOiB1bnN1cHBvcnRlZE1vZGVsLm1vZGVsSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYXNTcGVlY2hNb2RlbFYzKG1vZGVsKTtcbiAgfVxuICByZXR1cm4gKF9iID0gKF9hMjEgPSBnZXRHbG9iYWxQcm92aWRlcigpKS5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EyMSwgbW9kZWwpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUltYWdlTW9kZWwobW9kZWwpIHtcbiAgaWYgKHR5cGVvZiBtb2RlbCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChtb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbiAhPT0gXCJ2M1wiICYmIG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYyXCIpIHtcbiAgICAgIGNvbnN0IHVuc3VwcG9ydGVkTW9kZWwgPSBtb2RlbDtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yKHtcbiAgICAgICAgdmVyc2lvbjogdW5zdXBwb3J0ZWRNb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgICAgcHJvdmlkZXI6IHVuc3VwcG9ydGVkTW9kZWwucHJvdmlkZXIsXG4gICAgICAgIG1vZGVsSWQ6IHVuc3VwcG9ydGVkTW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhc0ltYWdlTW9kZWxWMyhtb2RlbCk7XG4gIH1cbiAgcmV0dXJuIGdldEdsb2JhbFByb3ZpZGVyKCkuaW1hZ2VNb2RlbChtb2RlbCk7XG59XG5mdW5jdGlvbiByZXNvbHZlVmlkZW9Nb2RlbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ1ZpZGVvIG1vZGVscyBjYW5ub3QgYmUgcmVzb2x2ZWQgZnJvbSBzdHJpbmdzLiBQbGVhc2UgdXNlIGEgRXhwZXJpbWVudGFsX1ZpZGVvTW9kZWxWMyBvYmplY3QgZnJvbSBhIHByb3ZpZGVyIChlLmcuLCBmYWwudmlkZW8oXCJtb2RlbC1pZFwiKSkuJ1xuICAgICk7XG4gIH1cbiAgaWYgKG1vZGVsLnNwZWNpZmljYXRpb25WZXJzaW9uICE9PSBcInYzXCIpIHtcbiAgICBjb25zdCB1bnN1cHBvcnRlZE1vZGVsID0gbW9kZWw7XG4gICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkTW9kZWxWZXJzaW9uRXJyb3Ioe1xuICAgICAgdmVyc2lvbjogdW5zdXBwb3J0ZWRNb2RlbC5zcGVjaWZpY2F0aW9uVmVyc2lvbixcbiAgICAgIHByb3ZpZGVyOiB1bnN1cHBvcnRlZE1vZGVsLnByb3ZpZGVyLFxuICAgICAgbW9kZWxJZDogdW5zdXBwb3J0ZWRNb2RlbC5tb2RlbElkXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG1vZGVsO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsUHJvdmlkZXIoKSB7XG4gIHZhciBfYTIxO1xuICByZXR1cm4gKF9hMjEgPSBnbG9iYWxUaGlzLkFJX1NES19ERUZBVUxUX1BST1ZJREVSKSAhPSBudWxsID8gX2EyMSA6IGdhdGV3YXk7XG59XG5cbi8vIHNyYy9wcm9tcHQvY2FsbC1zZXR0aW5ncy50c1xuZnVuY3Rpb24gZ2V0VG90YWxUaW1lb3V0TXModGltZW91dCkge1xuICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdGltZW91dDtcbiAgfVxuICByZXR1cm4gdGltZW91dC50b3RhbE1zO1xufVxuZnVuY3Rpb24gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0ID09IG51bGwgfHwgdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB0aW1lb3V0LnN0ZXBNcztcbn1cbmZ1bmN0aW9uIGdldENodW5rVGltZW91dE1zKHRpbWVvdXQpIHtcbiAgaWYgKHRpbWVvdXQgPT0gbnVsbCB8fCB0eXBlb2YgdGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHRpbWVvdXQuY2h1bmtNcztcbn1cblxuLy8gc3JjL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuaW1wb3J0IHtcbiAgaXNVcmxTdXBwb3J0ZWRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvZGV0ZWN0LW1lZGlhLXR5cGUudHNcbmltcG9ydCB7IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlcyA9IFtcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9naWZcIixcbiAgICBieXRlc1ByZWZpeDogWzcxLCA3MywgNzBdXG4gICAgLy8gR0lGXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFsxMzcsIDgwLCA3OCwgNzFdXG4gICAgLy8gUE5HXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvanBlZ1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMjU1LCAyMTZdXG4gICAgLy8gSlBFR1xuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL3dlYnBcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgODIsXG4gICAgICA3MyxcbiAgICAgIDcwLFxuICAgICAgNzAsXG4gICAgICAvLyBcIlJJRkZcIlxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZpbGUgc2l6ZSAodmFyaWFibGUpXG4gICAgICA4NyxcbiAgICAgIDY5LFxuICAgICAgNjYsXG4gICAgICA4MFxuICAgICAgLy8gXCJXRUJQXCJcbiAgICBdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvYm1wXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs2NiwgNzddXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbNzMsIDczLCA0MiwgMF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS90aWZmXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFs3NywgNzcsIDAsIDQyXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImltYWdlL2F2aWZcIixcbiAgICBieXRlc1ByZWZpeDogW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMzIsXG4gICAgICAxMDIsXG4gICAgICAxMTYsXG4gICAgICAxMjEsXG4gICAgICAxMTIsXG4gICAgICA5NyxcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMlxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJpbWFnZS9oZWljXCIsXG4gICAgYnl0ZXNQcmVmaXg6IFtcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDMyLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyLFxuICAgICAgMTA0LFxuICAgICAgMTAxLFxuICAgICAgMTA1LFxuICAgICAgOTlcbiAgICBdXG4gIH1cbl07XG52YXIgYXVkaW9NZWRpYVR5cGVTaWduYXR1cmVzID0gW1xuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUxXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjUwXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjQzXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjQyXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjI3XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wZWdcIixcbiAgICBieXRlc1ByZWZpeDogWzI1NSwgMjI2XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL3dhdlwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICA4MixcbiAgICAgIC8vIFJcbiAgICAgIDczLFxuICAgICAgLy8gSVxuICAgICAgNzAsXG4gICAgICAvLyBGXG4gICAgICA3MCxcbiAgICAgIC8vIEZcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICA4NyxcbiAgICAgIC8vIFdcbiAgICAgIDY1LFxuICAgICAgLy8gQVxuICAgICAgODYsXG4gICAgICAvLyBWXG4gICAgICA2OVxuICAgICAgLy8gRVxuICAgIF1cbiAgfSxcbiAge1xuICAgIG1lZGlhVHlwZTogXCJhdWRpby9vZ2dcIixcbiAgICBieXRlc1ByZWZpeDogWzc5LCAxMDMsIDEwMywgODNdXG4gIH0sXG4gIHtcbiAgICBtZWRpYVR5cGU6IFwiYXVkaW8vZmxhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCA3NiwgOTcsIDY3XVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL2FhY1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbNjQsIDIxLCAwLCAwXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL21wNFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbMTAyLCAxMTYsIDEyMSwgMTEyXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcImF1ZGlvL3dlYm1cIixcbiAgICBieXRlc1ByZWZpeDogWzI2LCA2OSwgMjIzLCAxNjNdXG4gIH1cbl07XG52YXIgdmlkZW9NZWRpYVR5cGVTaWduYXR1cmVzID0gW1xuICB7XG4gICAgbWVkaWFUeXBlOiBcInZpZGVvL21wNFwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBudWxsLFxuICAgICAgMTAyLFxuICAgICAgMTE2LFxuICAgICAgMTIxLFxuICAgICAgMTEyXG4gICAgICAvLyBmdHlwXG4gICAgXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcInZpZGVvL3dlYm1cIixcbiAgICBieXRlc1ByZWZpeDogWzI2LCA2OSwgMjIzLCAxNjNdXG4gICAgLy8gRUJNTFxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcInZpZGVvL3F1aWNrdGltZVwiLFxuICAgIGJ5dGVzUHJlZml4OiBbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAyMCxcbiAgICAgIDEwMixcbiAgICAgIDExNixcbiAgICAgIDEyMSxcbiAgICAgIDExMixcbiAgICAgIDExMyxcbiAgICAgIDExNlxuICAgICAgLy8gZnR5cHF0XG4gICAgXVxuICB9LFxuICB7XG4gICAgbWVkaWFUeXBlOiBcInZpZGVvL3gtbXN2aWRlb1wiLFxuICAgIGJ5dGVzUHJlZml4OiBbODIsIDczLCA3MCwgNzBdXG4gICAgLy8gUklGRiAoQVZJKVxuICB9XG5dO1xudmFyIHN0cmlwSUQzID0gKGRhdGEpID0+IHtcbiAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoZGF0YSkgOiBkYXRhO1xuICBjb25zdCBpZDNTaXplID0gKGJ5dGVzWzZdICYgMTI3KSA8PCAyMSB8IChieXRlc1s3XSAmIDEyNykgPDwgMTQgfCAoYnl0ZXNbOF0gJiAxMjcpIDw8IDcgfCBieXRlc1s5XSAmIDEyNztcbiAgcmV0dXJuIGJ5dGVzLnNsaWNlKGlkM1NpemUgKyAxMCk7XG59O1xuZnVuY3Rpb24gc3RyaXBJRDNUYWdzSWZQcmVzZW50KGRhdGEpIHtcbiAgY29uc3QgaGFzSWQzID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgJiYgZGF0YS5zdGFydHNXaXRoKFwiU1VRelwiKSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiAmJiBkYXRhLmxlbmd0aCA+IDEwICYmIGRhdGFbMF0gPT09IDczICYmIC8vICdJJ1xuICBkYXRhWzFdID09PSA2OCAmJiAvLyAnRCdcbiAgZGF0YVsyXSA9PT0gNTE7XG4gIHJldHVybiBoYXNJZDMgPyBzdHJpcElEMyhkYXRhKSA6IGRhdGE7XG59XG5mdW5jdGlvbiBkZXRlY3RNZWRpYVR5cGUoe1xuICBkYXRhLFxuICBzaWduYXR1cmVzXG59KSB7XG4gIGNvbnN0IHByb2Nlc3NlZERhdGEgPSBzdHJpcElEM1RhZ3NJZlByZXNlbnQoZGF0YSk7XG4gIGNvbnN0IGJ5dGVzID0gdHlwZW9mIHByb2Nlc3NlZERhdGEgPT09IFwic3RyaW5nXCIgPyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KFxuICAgIHByb2Nlc3NlZERhdGEuc3Vic3RyaW5nKDAsIE1hdGgubWluKHByb2Nlc3NlZERhdGEubGVuZ3RoLCAyNCkpXG4gICkgOiBwcm9jZXNzZWREYXRhO1xuICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiBzaWduYXR1cmVzKSB7XG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+PSBzaWduYXR1cmUuYnl0ZXNQcmVmaXgubGVuZ3RoICYmIHNpZ25hdHVyZS5ieXRlc1ByZWZpeC5ldmVyeShcbiAgICAgIChieXRlLCBpbmRleCkgPT4gYnl0ZSA9PT0gbnVsbCB8fCBieXRlc1tpbmRleF0gPT09IGJ5dGVcbiAgICApKSB7XG4gICAgICByZXR1cm4gc2lnbmF0dXJlLm1lZGlhVHlwZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL3V0aWwvZG93bmxvYWQvZG93bmxvYWQudHNcbmltcG9ydCB7IERvd25sb2FkRXJyb3IgYXMgRG93bmxvYWRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHtcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCxcbiAgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IHRydWUgPyBcIjYuMC42OFwiIDogXCIwLjAuMC10ZXN0XCI7XG5cbi8vIHNyYy91dGlsL2Rvd25sb2FkL2Rvd25sb2FkLnRzXG52YXIgZG93bmxvYWQgPSBhc3luYyAoeyB1cmwgfSkgPT4ge1xuICB2YXIgX2EyMTtcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsVGV4dCwge1xuICAgICAgaGVhZGVyczogd2l0aFVzZXJBZ2VudFN1ZmZpeChcbiAgICAgICAge30sXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudCgpXG4gICAgICApXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IyKHtcbiAgICAgICAgdXJsOiB1cmxUZXh0LFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSksXG4gICAgICBtZWRpYVR5cGU6IChfYTIxID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTIxIDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvcjIuaXNJbnN0YW5jZShlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcjIoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWwvZG93bmxvYWQvZG93bmxvYWQtZnVuY3Rpb24udHNcbnZhciBjcmVhdGVEZWZhdWx0RG93bmxvYWRGdW5jdGlvbiA9IChkb3dubG9hZDIgPSBkb3dubG9hZCkgPT4gKHJlcXVlc3RlZERvd25sb2FkcykgPT4gUHJvbWlzZS5hbGwoXG4gIHJlcXVlc3RlZERvd25sb2Fkcy5tYXAoXG4gICAgYXN5bmMgKHJlcXVlc3RlZERvd25sb2FkKSA9PiByZXF1ZXN0ZWREb3dubG9hZC5pc1VybFN1cHBvcnRlZEJ5TW9kZWwgPyBudWxsIDogZG93bmxvYWQyKHJlcXVlc3RlZERvd25sb2FkKVxuICApXG4pO1xuXG4vLyBzcmMvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MixcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3Byb21wdC9zcGxpdC1kYXRhLXVybC50c1xuZnVuY3Rpb24gc3BsaXREYXRhVXJsKGRhdGFVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBtZWRpYVR5cGU6IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdLFxuICAgICAgYmFzZTY0Q29udGVudFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1lZGlhVHlwZTogdm9pZCAwLFxuICAgICAgYmFzZTY0Q29udGVudDogdm9pZCAwXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcHJvbXB0L2RhdGEtY29udGVudC50c1xudmFyIGRhdGFDb250ZW50U2NoZW1hID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9hMjEsIF9iO1xuICAgICAgcmV0dXJuIChfYiA9IChfYTIxID0gZ2xvYmFsVGhpcy5CdWZmZXIpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmlzQnVmZmVyKHZhbHVlKSkgIT0gbnVsbCA/IF9iIDogZmFsc2U7XG4gICAgfSxcbiAgICB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhIEJ1ZmZlclwiIH1cbiAgKVxuXSk7XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjNEYXRhQ29udGVudChjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB7IGRhdGE6IGNvbnRlbnQsIG1lZGlhVHlwZTogdm9pZCAwIH07XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IGRhdGE6IG5ldyBVaW50OEFycmF5KGNvbnRlbnQpLCBtZWRpYVR5cGU6IHZvaWQgMCB9O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50ID0gbmV3IFVSTChjb250ZW50KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCAmJiBjb250ZW50LnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICBjb25zdCB7IG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgY29udGVudC50b1N0cmluZygpXG4gICAgKTtcbiAgICBpZiAoZGF0YVVybE1lZGlhVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEFJU0RLRXJyb3IyMih7XG4gICAgICAgIG5hbWU6IFwiSW52YWxpZERhdGFDb250ZW50RXJyb3JcIixcbiAgICAgICAgbWVzc2FnZTogYEludmFsaWQgZGF0YSBVUkwgZm9ybWF0IGluIGNvbnRlbnQgJHtjb250ZW50LnRvU3RyaW5nKCl9YFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGRhdGE6IGJhc2U2NENvbnRlbnQsIG1lZGlhVHlwZTogZGF0YVVybE1lZGlhVHlwZSB9O1xuICB9XG4gIHJldHVybiB7IGRhdGE6IGNvbnRlbnQsIG1lZGlhVHlwZTogdm9pZCAwIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50KSB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoY29udGVudCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoY29udGVudCkge1xuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkyKGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgZGF0YSBjb250ZW50LiBDb250ZW50IHN0cmluZyBpcyBub3QgYSBiYXNlNjQtZW5jb2RlZCBtZWRpYS5cIixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuXG4vLyBzcmMvdXRpbC9hcy1hcnJheS50c1xuZnVuY3Rpb24gYXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IFtdIDogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG59XG5cbi8vIHNyYy9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHN1cHBvcnRlZFVybHMsXG4gIGRvd25sb2FkOiBkb3dubG9hZDIgPSBjcmVhdGVEZWZhdWx0RG93bmxvYWRGdW5jdGlvbigpXG59KSB7XG4gIGNvbnN0IGRvd25sb2FkZWRBc3NldHMgPSBhd2FpdCBkb3dubG9hZEFzc2V0cyhcbiAgICBwcm9tcHQubWVzc2FnZXMsXG4gICAgZG93bmxvYWQyLFxuICAgIHN1cHBvcnRlZFVybHNcbiAgKTtcbiAgY29uc3QgYXBwcm92YWxJZFRvVG9vbENhbGxJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBwcm9tcHQubWVzc2FnZXMpIHtcbiAgICBpZiAobWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSkge1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIG1lc3NhZ2UuY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiICYmIFwiYXBwcm92YWxJZFwiIGluIHBhcnQgJiYgXCJ0b29sQ2FsbElkXCIgaW4gcGFydCkge1xuICAgICAgICAgIGFwcHJvdmFsSWRUb1Rvb2xDYWxsSWQuc2V0KFxuICAgICAgICAgICAgcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgICAgcGFydC50b29sQ2FsbElkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhcHByb3ZlZFRvb2xDYWxsSWRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHByb21wdC5tZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwidG9vbFwiKSB7XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGxJZCA9IGFwcHJvdmFsSWRUb1Rvb2xDYWxsSWQuZ2V0KHBhcnQuYXBwcm92YWxJZCk7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsSWQpIHtcbiAgICAgICAgICAgIGFwcHJvdmVkVG9vbENhbGxJZHMuYWRkKHRvb2xDYWxsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBtZXNzYWdlcyA9IFtcbiAgICAuLi5wcm9tcHQuc3lzdGVtICE9IG51bGwgPyB0eXBlb2YgcHJvbXB0LnN5c3RlbSA9PT0gXCJzdHJpbmdcIiA/IFt7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV0gOiBhc0FycmF5KHByb21wdC5zeXN0ZW0pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIHJvbGU6IFwic3lzdGVtXCIsXG4gICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgfSkpIDogW10sXG4gICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcChcbiAgICAgIChtZXNzYWdlKSA9PiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSh7IG1lc3NhZ2UsIGRvd25sb2FkZWRBc3NldHMgfSlcbiAgICApXG4gIF07XG4gIGNvbnN0IGNvbWJpbmVkTWVzc2FnZXMgPSBbXTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJ0b29sXCIpIHtcbiAgICAgIGNvbWJpbmVkTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBsYXN0Q29tYmluZWRNZXNzYWdlID0gY29tYmluZWRNZXNzYWdlcy5hdCgtMSk7XG4gICAgaWYgKChsYXN0Q29tYmluZWRNZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBsYXN0Q29tYmluZWRNZXNzYWdlLnJvbGUpID09PSBcInRvb2xcIikge1xuICAgICAgbGFzdENvbWJpbmVkTWVzc2FnZS5jb250ZW50LnB1c2goLi4ubWVzc2FnZS5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tYmluZWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuICBjb25zdCB0b29sQ2FsbElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBjb21iaW5lZE1lc3NhZ2VzKSB7XG4gICAgc3dpdGNoIChtZXNzYWdlLnJvbGUpIHtcbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgbWVzc2FnZS5jb250ZW50KSB7XG4gICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiAmJiAhY29udGVudC5wcm92aWRlckV4ZWN1dGVkKSB7XG4gICAgICAgICAgICB0b29sQ2FsbElkcy5hZGQoY29udGVudC50b29sQ2FsbElkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgICBpZiAoY29udGVudC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWRzLmRlbGV0ZShjb250ZW50LnRvb2xDYWxsSWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ1c2VyXCI6XG4gICAgICBjYXNlIFwic3lzdGVtXCI6XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgYXBwcm92ZWRUb29sQ2FsbElkcykge1xuICAgICAgICAgIHRvb2xDYWxsSWRzLmRlbGV0ZShpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvb2xDYWxsSWRzLnNpemUgPiAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdUb29sUmVzdWx0c0Vycm9yKHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWRzOiBBcnJheS5mcm9tKHRvb2xDYWxsSWRzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGlkIG9mIGFwcHJvdmVkVG9vbENhbGxJZHMpIHtcbiAgICB0b29sQ2FsbElkcy5kZWxldGUoaWQpO1xuICB9XG4gIGlmICh0b29sQ2FsbElkcy5zaXplID4gMCkge1xuICAgIHRocm93IG5ldyBNaXNzaW5nVG9vbFJlc3VsdHNFcnJvcih7IHRvb2xDYWxsSWRzOiBBcnJheS5mcm9tKHRvb2xDYWxsSWRzKSB9KTtcbiAgfVxuICByZXR1cm4gY29tYmluZWRNZXNzYWdlcy5maWx0ZXIoXG4gICAgLy8gRmlsdGVyIG91dCBlbXB0eSB0b29sIG1lc3NhZ2VzIChlLmcuIGlmIHRoZXkgb25seSBjb250YWluZWRcbiAgICAvLyB0b29sLWFwcHJvdmFsLXJlc3BvbnNlIHBhcnRzIHRoYXQgd2VyZSByZW1vdmVkKS5cbiAgICAvLyBUaGlzIHByZXZlbnRzIHNlbmRpbmcgaW52YWxpZCBlbXB0eSBtZXNzYWdlcyB0byB0aGUgcHJvdmlkZXIuXG4gICAgLy8gTm90ZTogcHJvdmlkZXItZXhlY3V0ZWQgdG9vbC1hcHByb3ZhbC1yZXNwb25zZSBwYXJ0cyBhcmUgcHJlc2VydmVkLlxuICAgIChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgIT09IFwidG9vbFwiIHx8IG1lc3NhZ2UuY29udGVudC5sZW5ndGggPiAwXG4gICk7XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSh7XG4gIG1lc3NhZ2UsXG4gIGRvd25sb2FkZWRBc3NldHNcbn0pIHtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcCgocGFydCkgPT4gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpKS5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiKSxcbiAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBtZXNzYWdlLnByb3ZpZGVyT3B0aW9uc1xuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzIChubyB0ZXh0LCBhbmQgbm8gcHJvdmlkZXIgb3B0aW9ucyk6XG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0ZXh0XCIgfHwgcGFydC50ZXh0ICE9PSBcIlwiIHx8IHBhcnQucHJvdmlkZXJPcHRpb25zICE9IG51bGxcbiAgICAgICAgKS5maWx0ZXIoXG4gICAgICAgICAgKHBhcnQpID0+IHBhcnQudHlwZSAhPT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIlxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IHBhcnQucHJvdmlkZXJPcHRpb25zO1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgbWVkaWFUeXBlIH0gPSBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsVjNEYXRhQ29udGVudChcbiAgICAgICAgICAgICAgICBwYXJ0LmRhdGFcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLXJlc3VsdFwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IG1hcFRvb2xSZXN1bHRPdXRwdXQocGFydC5vdXRwdXQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogbWVzc2FnZS5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKFxuICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0b29sLWFwcHJvdmFsLXJlc3BvbnNlIGZvciBwcm92aWRlci1leGVjdXRlZCB0b29sc1xuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiIHx8IHBhcnQucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICApLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBtYXBUb29sUmVzdWx0T3V0cHV0KHBhcnQub3V0cHV0KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiOiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgICAgICAgIGFwcHJvdmVkOiBwYXJ0LmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogcGFydC5yZWFzb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IG1lc3NhZ2UucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWQyLCBzdXBwb3J0ZWRVcmxzKSB7XG4gIGNvbnN0IHBsYW5uZWREb3dubG9hZHMgPSBtZXNzYWdlcy5maWx0ZXIoKG1lc3NhZ2UpID0+IG1lc3NhZ2Uucm9sZSA9PT0gXCJ1c2VyXCIpLm1hcCgobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50KS5maWx0ZXIoXG4gICAgKGNvbnRlbnQpID0+IEFycmF5LmlzQXJyYXkoY29udGVudClcbiAgKS5mbGF0KCkuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiB8fCBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiXG4gICkubWFwKChwYXJ0KSA9PiB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgbWVkaWFUeXBlID0gKF9hMjEgPSBwYXJ0Lm1lZGlhVHlwZSkgIT0gbnVsbCA/IF9hMjEgOiBwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiA/IFwiaW1hZ2UvKlwiIDogdm9pZCAwO1xuICAgIGxldCBkYXRhID0gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IG5ldyBVUkwoZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG1lZGlhVHlwZSwgZGF0YSB9O1xuICB9KS5maWx0ZXIoXG4gICAgKHBhcnQpID0+IHBhcnQuZGF0YSBpbnN0YW5jZW9mIFVSTFxuICApLm1hcCgocGFydCkgPT4gKHtcbiAgICB1cmw6IHBhcnQuZGF0YSxcbiAgICBpc1VybFN1cHBvcnRlZEJ5TW9kZWw6IHBhcnQubWVkaWFUeXBlICE9IG51bGwgJiYgaXNVcmxTdXBwb3J0ZWQoe1xuICAgICAgdXJsOiBwYXJ0LmRhdGEudG9TdHJpbmcoKSxcbiAgICAgIG1lZGlhVHlwZTogcGFydC5tZWRpYVR5cGUsXG4gICAgICBzdXBwb3J0ZWRVcmxzXG4gICAgfSlcbiAgfSkpO1xuICBjb25zdCBkb3dubG9hZGVkRmlsZXMgPSBhd2FpdCBkb3dubG9hZDIocGxhbm5lZERvd25sb2Fkcyk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgZG93bmxvYWRlZEZpbGVzLm1hcChcbiAgICAgIChmaWxlLCBpbmRleCkgPT4gZmlsZSA9PSBudWxsID8gbnVsbCA6IFtcbiAgICAgICAgcGxhbm5lZERvd25sb2Fkc1tpbmRleF0udXJsLnRvU3RyaW5nKCksXG4gICAgICAgIHsgZGF0YTogZmlsZS5kYXRhLCBtZWRpYVR5cGU6IGZpbGUubWVkaWFUeXBlIH1cbiAgICAgIF1cbiAgICApLmZpbHRlcigoZmlsZSkgPT4gZmlsZSAhPSBudWxsKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgdmFyIF9hMjE7XG4gIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyT3B0aW9uc1xuICAgIH07XG4gIH1cbiAgbGV0IG9yaWdpbmFsRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBvcmlnaW5hbERhdGEgPSBwYXJ0LmltYWdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIG9yaWdpbmFsRGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIGNvbnN0IHsgZGF0YTogY29udmVydGVkRGF0YSwgbWVkaWFUeXBlOiBjb252ZXJ0ZWRNZWRpYVR5cGUgfSA9IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxWM0RhdGFDb250ZW50KG9yaWdpbmFsRGF0YSk7XG4gIGxldCBtZWRpYVR5cGUgPSBjb252ZXJ0ZWRNZWRpYVR5cGUgIT0gbnVsbCA/IGNvbnZlcnRlZE1lZGlhVHlwZSA6IHBhcnQubWVkaWFUeXBlO1xuICBsZXQgZGF0YSA9IGNvbnZlcnRlZERhdGE7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgZG93bmxvYWRlZEZpbGUgPSBkb3dubG9hZGVkQXNzZXRzW2RhdGEudG9TdHJpbmcoKV07XG4gICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICBkYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgIG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogbWVkaWFUeXBlID0gZG93bmxvYWRlZEZpbGUubWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lZGlhVHlwZSA9IChfYTIxID0gZGV0ZWN0TWVkaWFUeXBlKHsgZGF0YSwgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzIH0pKSAhPSBudWxsID8gX2EyMSA6IG1lZGlhVHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSAhPSBudWxsID8gbWVkaWFUeXBlIDogXCJpbWFnZS8qXCIsXG4gICAgICAgIC8vIGFueSBpbWFnZVxuICAgICAgICBmaWxlbmFtZTogdm9pZCAwLFxuICAgICAgICBkYXRhLFxuICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJPcHRpb25zXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICBpZiAobWVkaWFUeXBlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZWRpYSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck9wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXBUb29sUmVzdWx0T3V0cHV0KG91dHB1dCkge1xuICBpZiAob3V0cHV0LnR5cGUgIT09IFwiY29udGVudFwiKSB7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiY29udGVudFwiLFxuICAgIHZhbHVlOiBvdXRwdXQudmFsdWUubWFwKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS50eXBlICE9PSBcIm1lZGlhXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5tZWRpYVR5cGUuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IFwiaW1hZ2UtZGF0YVwiLFxuICAgICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgICBtZWRpYVR5cGU6IGl0ZW0ubWVkaWFUeXBlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImZpbGUtZGF0YVwiLFxuICAgICAgICBkYXRhOiBpdGVtLmRhdGEsXG4gICAgICAgIG1lZGlhVHlwZTogaXRlbS5tZWRpYVR5cGVcbiAgICAgIH07XG4gICAgfSlcbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9jcmVhdGUtdG9vbC1tb2RlbC1vdXRwdXQudHNcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2UzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gIHRvb2xDYWxsSWQsXG4gIGlucHV0LFxuICBvdXRwdXQsXG4gIHRvb2w6IHRvb2wyLFxuICBlcnJvck1vZGVcbn0pIHtcbiAgaWYgKGVycm9yTW9kZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLXRleHRcIiwgdmFsdWU6IGdldEVycm9yTWVzc2FnZTMob3V0cHV0KSB9O1xuICB9IGVsc2UgaWYgKGVycm9yTW9kZSA9PT0gXCJqc29uXCIpIHtcbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yLWpzb25cIiwgdmFsdWU6IHRvSlNPTlZhbHVlKG91dHB1dCkgfTtcbiAgfVxuICBpZiAodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLnRvTW9kZWxPdXRwdXQpIHtcbiAgICByZXR1cm4gYXdhaXQgdG9vbDIudG9Nb2RlbE91dHB1dCh7IHRvb2xDYWxsSWQsIGlucHV0LCBvdXRwdXQgfSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09IFwic3RyaW5nXCIgPyB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogb3V0cHV0IH0gOiB7IHR5cGU6IFwianNvblwiLCB2YWx1ZTogdG9KU09OVmFsdWUob3V0cHV0KSB9O1xufVxuZnVuY3Rpb24gdG9KU09OVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyBudWxsIDogdmFsdWU7XG59XG5cbi8vIHNyYy9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4T3V0cHV0VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBzdG9wU2VxdWVuY2VzXG59KSB7XG4gIGlmIChtYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhPdXRwdXRUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4T3V0cHV0VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4T3V0cHV0VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heE91dHB1dFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhPdXRwdXRUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heE91dHB1dFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhPdXRwdXRUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbWF4T3V0cHV0VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzLFxuICAgIHNlZWRcbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC9wcmVwYXJlLXRvb2xzLWFuZC10b29sLWNob2ljZS50c1xuaW1wb3J0IHsgYXNTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9pcy1ub24tZW1wdHktb2JqZWN0LnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5T2JqZWN0KG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIgIT0gbnVsbCAmJiBPYmplY3Qua2V5cyhvYmplY3QyKS5sZW5ndGggPiAwO1xufVxuXG4vLyBzcmMvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIGFjdGl2ZVRvb2xzXG59KSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHZvaWQgMCxcbiAgICAgIHRvb2xDaG9pY2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgY29uc3QgZmlsdGVyZWRUb29scyA9IGFjdGl2ZVRvb2xzICE9IG51bGwgPyBPYmplY3QuZW50cmllcyh0b29scykuZmlsdGVyKFxuICAgIChbbmFtZTIxXSkgPT4gYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZTIxKVxuICApIDogT2JqZWN0LmVudHJpZXModG9vbHMpO1xuICBjb25zdCBsYW5ndWFnZU1vZGVsVG9vbHMgPSBbXTtcbiAgZm9yIChjb25zdCBbbmFtZTIxLCB0b29sMl0gb2YgZmlsdGVyZWRUb29scykge1xuICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICBzd2l0Y2ggKHRvb2xUeXBlKSB7XG4gICAgICBjYXNlIHZvaWQgMDpcbiAgICAgIGNhc2UgXCJkeW5hbWljXCI6XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgbGFuZ3VhZ2VNb2RlbFRvb2xzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBuYW1lOiBuYW1lMjEsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wyLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBhd2FpdCBhc1NjaGVtYSh0b29sMi5pbnB1dFNjaGVtYSkuanNvblNjaGVtYSxcbiAgICAgICAgICAuLi50b29sMi5pbnB1dEV4YW1wbGVzICE9IG51bGwgPyB7IGlucHV0RXhhbXBsZXM6IHRvb2wyLmlucHV0RXhhbXBsZXMgfSA6IHt9LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogdG9vbDIucHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgIC4uLnRvb2wyLnN0cmljdCAhPSBudWxsID8geyBzdHJpY3Q6IHRvb2wyLnN0cmljdCB9IDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInByb3ZpZGVyXCI6XG4gICAgICAgIGxhbmd1YWdlTW9kZWxUb29scy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInByb3ZpZGVyXCIsXG4gICAgICAgICAgbmFtZTogbmFtZTIxLFxuICAgICAgICAgIGlkOiB0b29sMi5pZCxcbiAgICAgICAgICBhcmdzOiB0b29sMi5hcmdzXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gdG9vbFR5cGU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdG9vbCB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b29sczogbGFuZ3VhZ2VNb2RlbFRvb2xzLFxuICAgIHRvb2xDaG9pY2U6IHRvb2xDaG9pY2UgPT0gbnVsbCA/IHsgdHlwZTogXCJhdXRvXCIgfSA6IHR5cGVvZiB0b29sQ2hvaWNlID09PSBcInN0cmluZ1wiID8geyB0eXBlOiB0b29sQ2hvaWNlIH0gOiB7IHR5cGU6IFwidG9vbFwiLCB0b29sTmFtZTogdG9vbENob2ljZS50b29sTmFtZSB9XG4gIH07XG59XG5cbi8vIHNyYy9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBzYWZlVmFsaWRhdGVUeXBlc1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHsgeiBhcyB6NiB9IGZyb20gXCJ6b2QvdjRcIjtcblxuLy8gc3JjL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo1IH0gZnJvbSBcInpvZC92NFwiO1xuXG4vLyBzcmMvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbmltcG9ydCB7IHogYXMgejMgfSBmcm9tIFwiem9kL3Y0XCI7XG5cbi8vIHNyYy90eXBlcy9qc29uLXZhbHVlLnRzXG5pbXBvcnQgeyB6IGFzIHoyIH0gZnJvbSBcInpvZC92NFwiO1xudmFyIGpzb25WYWx1ZVNjaGVtYSA9IHoyLmxhenkoXG4gICgpID0+IHoyLnVuaW9uKFtcbiAgICB6Mi5udWxsKCksXG4gICAgejIuc3RyaW5nKCksXG4gICAgejIubnVtYmVyKCksXG4gICAgejIuYm9vbGVhbigpLFxuICAgIHoyLnJlY29yZCh6Mi5zdHJpbmcoKSwganNvblZhbHVlU2NoZW1hLm9wdGlvbmFsKCkpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIHNyYy90eXBlcy9wcm92aWRlci1tZXRhZGF0YS50c1xudmFyIHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgPSB6My5yZWNvcmQoXG4gIHozLnN0cmluZygpLFxuICB6My5yZWNvcmQoejMuc3RyaW5nKCksIGpzb25WYWx1ZVNjaGVtYS5vcHRpb25hbCgpKVxuKTtcblxuLy8gc3JjL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgdGV4dFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgdGV4dDogejQuc3RyaW5nKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBpbWFnZVBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2VcIiksXG4gIGltYWdlOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBtZWRpYVR5cGU6IHo0LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBmaWxlUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlXCIpLFxuICBkYXRhOiB6NC51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHo0Lmluc3RhbmNlb2YoVVJMKV0pLFxuICBmaWxlbmFtZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgbWVkaWFUeXBlOiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHJlYXNvbmluZ1BhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICB0ZXh0OiB6NC5zdHJpbmcoKSxcbiAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIHRvb2xDYWxsUGFydFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWNhbGxcIiksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sTmFtZTogejQuc3RyaW5nKCksXG4gIGlucHV0OiB6NC51bmtub3duKCksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICBwcm92aWRlckV4ZWN1dGVkOiB6NC5ib29sZWFuKCkub3B0aW9uYWwoKVxufSk7XG52YXIgb3V0cHV0U2NoZW1hID0gejQuZGlzY3JpbWluYXRlZFVuaW9uKFxuICBcInR5cGVcIixcbiAgW1xuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgICAgIHZhbHVlOiB6NC5zdHJpbmcoKSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJqc29uXCIpLFxuICAgICAgdmFsdWU6IGpzb25WYWx1ZVNjaGVtYSxcbiAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgfSksXG4gICAgejQub2JqZWN0KHtcbiAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJleGVjdXRpb24tZGVuaWVkXCIpLFxuICAgICAgcmVhc29uOiB6NC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImVycm9yLXRleHRcIiksXG4gICAgICB2YWx1ZTogejQuc3RyaW5nKCksXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZXJyb3ItanNvblwiKSxcbiAgICAgIHZhbHVlOiBqc29uVmFsdWVTY2hlbWEsXG4gICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgIH0pLFxuICAgIHo0Lm9iamVjdCh7XG4gICAgICB0eXBlOiB6NC5saXRlcmFsKFwiY29udGVudFwiKSxcbiAgICAgIHZhbHVlOiB6NC5hcnJheShcbiAgICAgICAgejQudW5pb24oW1xuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwidGV4dFwiKSxcbiAgICAgICAgICAgIHRleHQ6IHo0LnN0cmluZygpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcIm1lZGlhXCIpLFxuICAgICAgICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBtZWRpYVR5cGU6IHo0LnN0cmluZygpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlLWRhdGFcIiksXG4gICAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBmaWxlbmFtZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJmaWxlLXVybFwiKSxcbiAgICAgICAgICAgIHVybDogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiZmlsZS1pZFwiKSxcbiAgICAgICAgICAgIGZpbGVJZDogejQudW5pb24oW3o0LnN0cmluZygpLCB6NC5yZWNvcmQoejQuc3RyaW5nKCksIHo0LnN0cmluZygpKV0pLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB6NC5vYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlLWRhdGFcIiksXG4gICAgICAgICAgICBkYXRhOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogejQuc3RyaW5nKCksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiaW1hZ2UtdXJsXCIpLFxuICAgICAgICAgICAgdXJsOiB6NC5zdHJpbmcoKSxcbiAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgfSksXG4gICAgICAgICAgejQub2JqZWN0KHtcbiAgICAgICAgICAgIHR5cGU6IHo0LmxpdGVyYWwoXCJpbWFnZS1maWxlLWlkXCIpLFxuICAgICAgICAgICAgZmlsZUlkOiB6NC51bmlvbihbejQuc3RyaW5nKCksIHo0LnJlY29yZCh6NC5zdHJpbmcoKSwgejQuc3RyaW5nKCkpXSksXG4gICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHo0Lm9iamVjdCh7XG4gICAgICAgICAgICB0eXBlOiB6NC5saXRlcmFsKFwiY3VzdG9tXCIpLFxuICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgKVxuICAgIH0pXG4gIF1cbik7XG52YXIgdG9vbFJlc3VsdFBhcnRTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1yZXN1bHRcIiksXG4gIHRvb2xDYWxsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sTmFtZTogejQuc3RyaW5nKCksXG4gIG91dHB1dDogb3V0cHV0U2NoZW1hLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbEFwcHJvdmFsUmVxdWVzdFNjaGVtYSA9IHo0Lm9iamVjdCh7XG4gIHR5cGU6IHo0LmxpdGVyYWwoXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIiksXG4gIGFwcHJvdmFsSWQ6IHo0LnN0cmluZygpLFxuICB0b29sQ2FsbElkOiB6NC5zdHJpbmcoKVxufSk7XG52YXIgdG9vbEFwcHJvdmFsUmVzcG9uc2VTY2hlbWEgPSB6NC5vYmplY3Qoe1xuICB0eXBlOiB6NC5saXRlcmFsKFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiKSxcbiAgYXBwcm92YWxJZDogejQuc3RyaW5nKCksXG4gIGFwcHJvdmVkOiB6NC5ib29sZWFuKCksXG4gIHJlYXNvbjogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxufSk7XG5cbi8vIHNyYy9wcm9tcHQvbWVzc2FnZS50c1xudmFyIHN5c3RlbU1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdChcbiAge1xuICAgIHJvbGU6IHo1LmxpdGVyYWwoXCJzeXN0ZW1cIiksXG4gICAgY29udGVudDogejUuc3RyaW5nKCksXG4gICAgcHJvdmlkZXJPcHRpb25zOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgfVxuKTtcbnZhciB1c2VyTW9kZWxNZXNzYWdlU2NoZW1hID0gejUub2JqZWN0KHtcbiAgcm9sZTogejUubGl0ZXJhbChcInVzZXJcIiksXG4gIGNvbnRlbnQ6IHo1LnVuaW9uKFtcbiAgICB6NS5zdHJpbmcoKSxcbiAgICB6NS5hcnJheSh6NS51bmlvbihbdGV4dFBhcnRTY2hlbWEsIGltYWdlUGFydFNjaGVtYSwgZmlsZVBhcnRTY2hlbWFdKSlcbiAgXSksXG4gIHByb3ZpZGVyT3B0aW9uczogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBhc3Npc3RhbnRNb2RlbE1lc3NhZ2VTY2hlbWEgPSB6NS5vYmplY3Qoe1xuICByb2xlOiB6NS5saXRlcmFsKFwiYXNzaXN0YW50XCIpLFxuICBjb250ZW50OiB6NS51bmlvbihbXG4gICAgejUuc3RyaW5nKCksXG4gICAgejUuYXJyYXkoXG4gICAgICB6NS51bmlvbihbXG4gICAgICAgIHRleHRQYXJ0U2NoZW1hLFxuICAgICAgICBmaWxlUGFydFNjaGVtYSxcbiAgICAgICAgcmVhc29uaW5nUGFydFNjaGVtYSxcbiAgICAgICAgdG9vbENhbGxQYXJ0U2NoZW1hLFxuICAgICAgICB0b29sUmVzdWx0UGFydFNjaGVtYSxcbiAgICAgICAgdG9vbEFwcHJvdmFsUmVxdWVzdFNjaGVtYVxuICAgICAgXSlcbiAgICApXG4gIF0pLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHJvbGU6IHo1LmxpdGVyYWwoXCJ0b29sXCIpLFxuICBjb250ZW50OiB6NS5hcnJheSh6NS51bmlvbihbdG9vbFJlc3VsdFBhcnRTY2hlbWEsIHRvb2xBcHByb3ZhbFJlc3BvbnNlU2NoZW1hXSkpLFxuICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgbW9kZWxNZXNzYWdlU2NoZW1hID0gejUudW5pb24oW1xuICBzeXN0ZW1Nb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIGFzc2lzdGFudE1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYVxuXSk7XG5cbi8vIHNyYy9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzXG5hc3luYyBmdW5jdGlvbiBzdGFuZGFyZGl6ZVByb21wdChwcm9tcHQpIHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnN5c3RlbSAhPSBudWxsICYmIHR5cGVvZiBwcm9tcHQuc3lzdGVtICE9PSBcInN0cmluZ1wiICYmICFhc0FycmF5KHByb21wdC5zeXN0ZW0pLmV2ZXJ5KFxuICAgIChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgbWVzc2FnZS5yb2xlID09PSBcInN5c3RlbVwiXG4gICkpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInN5c3RlbSBtdXN0IGJlIGEgc3RyaW5nLCBTeXN0ZW1Nb2RlbE1lc3NhZ2UsIG9yIGFycmF5IG9mIFN5c3RlbU1vZGVsTWVzc2FnZVwiXG4gICAgfSk7XG4gIH1cbiAgbGV0IG1lc3NhZ2VzO1xuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHR5cGVvZiBwcm9tcHQucHJvbXB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgbWVzc2FnZXMgPSBbeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogcHJvbXB0LnByb21wdCB9XTtcbiAgfSBlbHNlIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgQXJyYXkuaXNBcnJheShwcm9tcHQucHJvbXB0KSkge1xuICAgIG1lc3NhZ2VzID0gcHJvbXB0LnByb21wdDtcbiAgfSBlbHNlIGlmIChwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIG1lc3NhZ2VzID0gcHJvbXB0Lm1lc3NhZ2VzO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3IyKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBub3QgYmUgZW1wdHlcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgIHNjaGVtYTogejYuYXJyYXkobW9kZWxNZXNzYWdlU2NoZW1hKVxuICB9KTtcbiAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yMih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcIlRoZSBtZXNzYWdlcyBkbyBub3QgbWF0Y2ggdGhlIE1vZGVsTWVzc2FnZVtdIHNjaGVtYS5cIixcbiAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlcyxcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfTtcbn1cblxuLy8gc3JjL3Byb21wdC93cmFwLWdhdGV3YXktZXJyb3IudHNcbmltcG9ydCB7IEdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yIH0gZnJvbSBcIkBhaS1zZGsvZ2F0ZXdheVwiO1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gd3JhcEdhdGV3YXlFcnJvcihlcnJvcikge1xuICBpZiAoIUdhdGV3YXlBdXRoZW50aWNhdGlvbkVycm9yLmlzSW5zdGFuY2UoZXJyb3IpKVxuICAgIHJldHVybiBlcnJvcjtcbiAgY29uc3QgaXNQcm9kdWN0aW9uRW52ID0gKHByb2Nlc3MgPT0gbnVsbCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52Lk5PREVfRU5WKSA9PT0gXCJwcm9kdWN0aW9uXCI7XG4gIGNvbnN0IG1vcmVJbmZvVVJMID0gXCJodHRwczovL2FpLXNkay5kZXYvdW5hdXRoZW50aWNhdGVkLWFpLWdhdGV3YXlcIjtcbiAgaWYgKGlzUHJvZHVjdGlvbkVudikge1xuICAgIHJldHVybiBuZXcgQUlTREtFcnJvcjIzKHtcbiAgICAgIG5hbWU6IFwiR2F0ZXdheUVycm9yXCIsXG4gICAgICBtZXNzYWdlOiBgVW5hdXRoZW50aWNhdGVkLiBDb25maWd1cmUgQUlfR0FURVdBWV9BUElfS0VZIG9yIHVzZSBhIHByb3ZpZGVyIG1vZHVsZS4gTGVhcm4gbW9yZTogJHttb3JlSW5mb1VSTH1gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgbmV3IEVycm9yKGBcXHgxQlsxbVxceDFCWzMxbVVuYXV0aGVudGljYXRlZCByZXF1ZXN0IHRvIEFJIEdhdGV3YXkuXFx4MUJbMG1cblxuVG8gYXV0aGVudGljYXRlLCBzZXQgdGhlIFxceDFCWzMzbUFJX0dBVEVXQVlfQVBJX0tFWVxceDFCWzBtIGVudmlyb25tZW50IHZhcmlhYmxlIHdpdGggeW91ciBBUEkga2V5LlxuXG5BbHRlcm5hdGl2ZWx5LCB5b3UgY2FuIHVzZSBhIHByb3ZpZGVyIG1vZHVsZSBpbnN0ZWFkIG9mIHRoZSBBSSBHYXRld2F5LlxuXG5MZWFybiBtb3JlOiBcXHgxQlszNG0ke21vcmVJbmZvVVJMfVxceDFCWzBtXG5cbmApLFxuICAgIHsgbmFtZTogXCJHYXRld2F5QXV0aGVudGljYXRpb25FcnJvclwiIH1cbiAgKTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uSWQsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIC8vIHN0YW5kYXJkaXplZCBvcGVyYXRpb24gYW5kIHJlc291cmNlIG5hbWU6XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25JZH0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWAsXG4gICAgXCJyZXNvdXJjZS5uYW1lXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gZGV0YWlsZWQsIEFJIFNESyBzcGVjaWZpYyBkYXRhOlxuICAgIFwiYWkub3BlcmF0aW9uSWRcIjogb3BlcmF0aW9uSWQsXG4gICAgXCJhaS50ZWxlbWV0cnkuZnVuY3Rpb25JZFwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkXG4gIH07XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvZ2V0LWJhc2UtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgbW9kZWwsXG4gIHNldHRpbmdzLFxuICB0ZWxlbWV0cnksXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIHJldHVybiB7XG4gICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBtb2RlbC5wcm92aWRlcixcbiAgICBcImFpLm1vZGVsLmlkXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgLy8gc2V0dGluZ3M6XG4gICAgLi4uT2JqZWN0LmVudHJpZXMoc2V0dGluZ3MpLnJlZHVjZSgoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSBcInRpbWVvdXRcIikge1xuICAgICAgICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgICk7XG4gICAgICAgIGlmICh0b3RhbFRpbWVvdXRNcyAhPSBudWxsKSB7XG4gICAgICAgICAgYXR0cmlidXRlc1tgYWkuc2V0dGluZ3MuJHtrZXl9YF0gPSB0b3RhbFRpbWVvdXRNcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkuc2V0dGluZ3MuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KSxcbiAgICAvLyBhZGQgbWV0YWRhdGEgYXMgYXR0cmlidXRlczpcbiAgICAuLi5PYmplY3QuZW50cmllcygoX2EyMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IHt9KS5yZWR1Y2UoXG4gICAgICAoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnRlbGVtZXRyeS5tZXRhZGF0YS4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICksXG4gICAgLy8gcmVxdWVzdCBoZWFkZXJzXG4gICAgLi4uT2JqZWN0LmVudHJpZXMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkucmVxdWVzdC5oZWFkZXJzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5pbXBvcnQgeyB0cmFjZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcblxuLy8gc3JjL3RlbGVtZXRyeS9ub29wLXRyYWNlci50c1xudmFyIG5vb3BUcmFjZXIgPSB7XG4gIHN0YXJ0U3BhbigpIHtcbiAgICByZXR1cm4gbm9vcFNwYW47XG4gIH0sXG4gIHN0YXJ0QWN0aXZlU3BhbihuYW1lMjEsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIGFyZzEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzEobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzIobm9vcFNwYW4pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGFyZzMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIGFyZzMobm9vcFNwYW4pO1xuICAgIH1cbiAgfVxufTtcbnZhciBub29wU3BhbiA9IHtcbiAgc3BhbkNvbnRleHQoKSB7XG4gICAgcmV0dXJuIG5vb3BTcGFuQ29udGV4dDtcbiAgfSxcbiAgc2V0QXR0cmlidXRlKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBzZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGluaygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkTGlua3MoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgdXBkYXRlTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZW5kKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpc1JlY29yZGluZygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIHJlY29yZEV4Y2VwdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcbnZhciBub29wU3BhbkNvbnRleHQgPSB7XG4gIHRyYWNlSWQ6IFwiXCIsXG4gIHNwYW5JZDogXCJcIixcbiAgdHJhY2VGbGFnczogMFxufTtcblxuLy8gc3JjL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5mdW5jdGlvbiBnZXRUcmFjZXIoe1xuICBpc0VuYWJsZWQgPSBmYWxzZSxcbiAgdHJhY2VyXG59ID0ge30pIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbm9vcFRyYWNlcjtcbiAgfVxuICBpZiAodHJhY2VyKSB7XG4gICAgcmV0dXJuIHRyYWNlcjtcbiAgfVxuICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKFwiYWlcIik7XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvcmVjb3JkLXNwYW4udHNcbmltcG9ydCB7XG4gIFNwYW5TdGF0dXNDb2RlLFxuICBjb250ZXh0XG59IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcbmFzeW5jIGZ1bmN0aW9uIHJlY29yZFNwYW4oe1xuICBuYW1lOiBuYW1lMjEsXG4gIHRyYWNlcixcbiAgYXR0cmlidXRlcyxcbiAgZm4sXG4gIGVuZFdoZW5Eb25lID0gdHJ1ZVxufSkge1xuICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihcbiAgICBuYW1lMjEsXG4gICAgeyBhdHRyaWJ1dGVzOiBhd2FpdCBhdHRyaWJ1dGVzIH0sXG4gICAgYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IGNvbnRleHQuYWN0aXZlKCk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250ZXh0LndpdGgoY3R4LCAoKSA9PiBmbihzcGFuKSk7XG4gICAgICAgIGlmIChlbmRXaGVuRG9uZSkge1xuICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gcmVjb3JkRXJyb3JPblNwYW4oc3BhbiwgZXJyb3IpIHtcbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbih7XG4gICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgIH0pO1xuICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gIH1cbn1cblxuLy8gc3JjL3RlbGVtZXRyeS9zZWxlY3QtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmFzeW5jIGZ1bmN0aW9uIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICB0ZWxlbWV0cnksXG4gIGF0dHJpYnV0ZXNcbn0pIHtcbiAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHJlc3VsdEF0dHJpYnV0ZXMgPSB7fTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJpbnB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnB1dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBpZiAoKHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LnJlY29yZElucHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdmFsdWUuaW5wdXQoKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRBdHRyaWJ1dGVzW2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcIm91dHB1dFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5vdXRwdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRPdXRwdXRzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWx1ZS5vdXRwdXQoKTtcbiAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHRBdHRyaWJ1dGVzW2tleV0gPSByZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmVzdWx0QXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdEF0dHJpYnV0ZXM7XG59XG5cbi8vIHNyYy90ZWxlbWV0cnkvc3RyaW5naWZ5LWZvci10ZWxlbWV0cnkudHNcbmZ1bmN0aW9uIHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHQpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KFxuICAgIHByb21wdC5tYXAoKG1lc3NhZ2UpID0+ICh7XG4gICAgICAuLi5tZXNzYWdlLFxuICAgICAgY29udGVudDogdHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UuY29udGVudCA6IG1lc3NhZ2UuY29udGVudC5tYXAoXG4gICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiID8ge1xuICAgICAgICAgIC4uLnBhcnQsXG4gICAgICAgICAgZGF0YTogcGFydC5kYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKHBhcnQuZGF0YSkgOiBwYXJ0LmRhdGFcbiAgICAgICAgfSA6IHBhcnRcbiAgICAgIClcbiAgICB9KSlcbiAgKTtcbn1cblxuLy8gc3JjL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBhc0xhbmd1YWdlTW9kZWxVc2FnZSh1c2FnZSkge1xuICByZXR1cm4ge1xuICAgIGlucHV0VG9rZW5zOiB1c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICBpbnB1dFRva2VuRGV0YWlsczoge1xuICAgICAgbm9DYWNoZVRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMubm9DYWNoZSxcbiAgICAgIGNhY2hlUmVhZFRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMuY2FjaGVSZWFkLFxuICAgICAgY2FjaGVXcml0ZVRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMuY2FjaGVXcml0ZVxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiB1c2FnZS5vdXRwdXRUb2tlbnMudG90YWwsXG4gICAgb3V0cHV0VG9rZW5EZXRhaWxzOiB7XG4gICAgICB0ZXh0VG9rZW5zOiB1c2FnZS5vdXRwdXRUb2tlbnMudGV4dCxcbiAgICAgIHJlYXNvbmluZ1Rva2VuczogdXNhZ2Uub3V0cHV0VG9rZW5zLnJlYXNvbmluZ1xuICAgIH0sXG4gICAgdG90YWxUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgdXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICB1c2FnZS5vdXRwdXRUb2tlbnMudG90YWxcbiAgICApLFxuICAgIHJhdzogdXNhZ2UucmF3LFxuICAgIHJlYXNvbmluZ1Rva2VuczogdXNhZ2Uub3V0cHV0VG9rZW5zLnJlYXNvbmluZyxcbiAgICBjYWNoZWRJbnB1dFRva2VuczogdXNhZ2UuaW5wdXRUb2tlbnMuY2FjaGVSZWFkXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKCkge1xuICByZXR1cm4ge1xuICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgaW5wdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIG5vQ2FjaGVUb2tlbnM6IHZvaWQgMCxcbiAgICAgIGNhY2hlUmVhZFRva2Vuczogdm9pZCAwLFxuICAgICAgY2FjaGVXcml0ZVRva2Vuczogdm9pZCAwXG4gICAgfSxcbiAgICBvdXRwdXRUb2tlbnM6IHZvaWQgMCxcbiAgICBvdXRwdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIHRleHRUb2tlbnM6IHZvaWQgMCxcbiAgICAgIHJlYXNvbmluZ1Rva2Vuczogdm9pZCAwXG4gICAgfSxcbiAgICB0b3RhbFRva2Vuczogdm9pZCAwLFxuICAgIHJhdzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UxLCB1c2FnZTIpIHtcbiAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaSwgX2o7XG4gIHJldHVybiB7XG4gICAgaW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS5pbnB1dFRva2VucywgdXNhZ2UyLmlucHV0VG9rZW5zKSxcbiAgICBpbnB1dFRva2VuRGV0YWlsczoge1xuICAgICAgbm9DYWNoZVRva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICAgIChfYTIxID0gdXNhZ2UxLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5ub0NhY2hlVG9rZW5zLFxuICAgICAgICAoX2IgPSB1c2FnZTIuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYi5ub0NhY2hlVG9rZW5zXG4gICAgICApLFxuICAgICAgY2FjaGVSZWFkVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9jID0gdXNhZ2UxLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FjaGVSZWFkVG9rZW5zLFxuICAgICAgICAoX2QgPSB1c2FnZTIuaW5wdXRUb2tlbkRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5jYWNoZVJlYWRUb2tlbnNcbiAgICAgICksXG4gICAgICBjYWNoZVdyaXRlVG9rZW5zOiBhZGRUb2tlbkNvdW50cyhcbiAgICAgICAgKF9lID0gdXNhZ2UxLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UuY2FjaGVXcml0ZVRva2VucyxcbiAgICAgICAgKF9mID0gdXNhZ2UyLmlucHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2YuY2FjaGVXcml0ZVRva2Vuc1xuICAgICAgKVxuICAgIH0sXG4gICAgb3V0cHV0VG9rZW5zOiBhZGRUb2tlbkNvdW50cyh1c2FnZTEub3V0cHV0VG9rZW5zLCB1c2FnZTIub3V0cHV0VG9rZW5zKSxcbiAgICBvdXRwdXRUb2tlbkRldGFpbHM6IHtcbiAgICAgIHRleHRUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2cgPSB1c2FnZTEub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cudGV4dFRva2VucyxcbiAgICAgICAgKF9oID0gdXNhZ2UyLm91dHB1dFRva2VuRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLnRleHRUb2tlbnNcbiAgICAgICksXG4gICAgICByZWFzb25pbmdUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgICAoX2kgPSB1c2FnZTEub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2kucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAoX2ogPSB1c2FnZTIub3V0cHV0VG9rZW5EZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogX2oucmVhc29uaW5nVG9rZW5zXG4gICAgICApXG4gICAgfSxcbiAgICB0b3RhbFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLnRvdGFsVG9rZW5zLCB1c2FnZTIudG90YWxUb2tlbnMpLFxuICAgIHJlYXNvbmluZ1Rva2VuczogYWRkVG9rZW5Db3VudHMoXG4gICAgICB1c2FnZTEucmVhc29uaW5nVG9rZW5zLFxuICAgICAgdXNhZ2UyLnJlYXNvbmluZ1Rva2Vuc1xuICAgICksXG4gICAgY2FjaGVkSW5wdXRUb2tlbnM6IGFkZFRva2VuQ291bnRzKFxuICAgICAgdXNhZ2UxLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgdXNhZ2UyLmNhY2hlZElucHV0VG9rZW5zXG4gICAgKVxuICB9O1xufVxuZnVuY3Rpb24gYWRkVG9rZW5Db3VudHModG9rZW5Db3VudDEsIHRva2VuQ291bnQyKSB7XG4gIHJldHVybiB0b2tlbkNvdW50MSA9PSBudWxsICYmIHRva2VuQ291bnQyID09IG51bGwgPyB2b2lkIDAgOiAodG9rZW5Db3VudDEgIT0gbnVsbCA/IHRva2VuQ291bnQxIDogMCkgKyAodG9rZW5Db3VudDIgIT0gbnVsbCA/IHRva2VuQ291bnQyIDogMCk7XG59XG5mdW5jdGlvbiBhZGRJbWFnZU1vZGVsVXNhZ2UodXNhZ2UxLCB1c2FnZTIpIHtcbiAgcmV0dXJuIHtcbiAgICBpbnB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLmlucHV0VG9rZW5zLCB1c2FnZTIuaW5wdXRUb2tlbnMpLFxuICAgIG91dHB1dFRva2VuczogYWRkVG9rZW5Db3VudHModXNhZ2UxLm91dHB1dFRva2VucywgdXNhZ2UyLm91dHB1dFRva2VucyksXG4gICAgdG90YWxUb2tlbnM6IGFkZFRva2VuQ291bnRzKHVzYWdlMS50b3RhbFRva2VucywgdXNhZ2UyLnRvdGFsVG9rZW5zKVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9tZXJnZS1vYmplY3RzLnRzXG5mdW5jdGlvbiBtZXJnZU9iamVjdHMoYmFzZSwgb3ZlcnJpZGVzKSB7XG4gIGlmIChiYXNlID09PSB2b2lkIDAgJiYgb3ZlcnJpZGVzID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChiYXNlID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVzO1xuICB9XG4gIGlmIChvdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiBiYXNlO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG92ZXJyaWRlcywga2V5KSkge1xuICAgICAgY29uc3Qgb3ZlcnJpZGVzVmFsdWUgPSBvdmVycmlkZXNba2V5XTtcbiAgICAgIGlmIChvdmVycmlkZXNWYWx1ZSA9PT0gdm9pZCAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGJhc2VWYWx1ZSA9IGtleSBpbiBiYXNlID8gYmFzZVtrZXldIDogdm9pZCAwO1xuICAgICAgY29uc3QgaXNTb3VyY2VPYmplY3QgPSBvdmVycmlkZXNWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygb3ZlcnJpZGVzVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkob3ZlcnJpZGVzVmFsdWUpICYmICEob3ZlcnJpZGVzVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSAmJiAhKG92ZXJyaWRlc1ZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGNvbnN0IGlzVGFyZ2V0T2JqZWN0ID0gYmFzZVZhbHVlICE9PSBudWxsICYmIGJhc2VWYWx1ZSAhPT0gdm9pZCAwICYmIHR5cGVvZiBiYXNlVmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYmFzZVZhbHVlKSAmJiAhKGJhc2VWYWx1ZSBpbnN0YW5jZW9mIERhdGUpICYmICEoYmFzZVZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKTtcbiAgICAgIGlmIChpc1NvdXJjZU9iamVjdCAmJiBpc1RhcmdldE9iamVjdCkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICBiYXNlVmFsdWUsXG4gICAgICAgICAgb3ZlcnJpZGVzVmFsdWVcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb3ZlcnJpZGVzVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZGVsYXksIGdldEVycm9yTWVzc2FnZSBhcyBnZXRFcnJvck1lc3NhZ2U0LCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gZ2V0UmV0cnlEZWxheUluTXMoe1xuICBlcnJvcixcbiAgZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXlcbn0pIHtcbiAgY29uc3QgaGVhZGVycyA9IGVycm9yLnJlc3BvbnNlSGVhZGVycztcbiAgaWYgKCFoZWFkZXJzKVxuICAgIHJldHVybiBleHBvbmVudGlhbEJhY2tvZmZEZWxheTtcbiAgbGV0IG1zO1xuICBjb25zdCByZXRyeUFmdGVyTXMgPSBoZWFkZXJzW1wicmV0cnktYWZ0ZXItbXNcIl07XG4gIGlmIChyZXRyeUFmdGVyTXMpIHtcbiAgICBjb25zdCB0aW1lb3V0TXMgPSBwYXJzZUZsb2F0KHJldHJ5QWZ0ZXJNcyk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dE1zKSkge1xuICAgICAgbXMgPSB0aW1lb3V0TXM7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJldHJ5QWZ0ZXIgPSBoZWFkZXJzW1wicmV0cnktYWZ0ZXJcIl07XG4gIGlmIChyZXRyeUFmdGVyICYmIG1zID09PSB2b2lkIDApIHtcbiAgICBjb25zdCB0aW1lb3V0U2Vjb25kcyA9IHBhcnNlRmxvYXQocmV0cnlBZnRlcik7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4odGltZW91dFNlY29uZHMpKSB7XG4gICAgICBtcyA9IHRpbWVvdXRTZWNvbmRzICogMWUzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtcyA9IERhdGUucGFyc2UocmV0cnlBZnRlcikgLSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfVxuICBpZiAobXMgIT0gbnVsbCAmJiAhTnVtYmVyLmlzTmFOKG1zKSAmJiAwIDw9IG1zICYmIChtcyA8IDYwICogMWUzIHx8IG1zIDwgZXhwb25lbnRpYWxCYWNrb2ZmRGVsYXkpKSB7XG4gICAgcmV0dXJuIG1zO1xuICB9XG4gIHJldHVybiBleHBvbmVudGlhbEJhY2tvZmZEZWxheTtcbn1cbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZSZXNwZWN0aW5nUmV0cnlIZWFkZXJzID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyLFxuICBhYm9ydFNpZ25hbFxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvcixcbiAgYWJvcnRTaWduYWxcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvcixcbiAgYWJvcnRTaWduYWxcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlNChlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IpICYmIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBhd2FpdCBkZWxheShcbiAgICAgICAgZ2V0UmV0cnlEZWxheUluTXMoe1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGV4cG9uZW50aWFsQmFja29mZkRlbGF5OiBkZWxheUluTXNcbiAgICAgICAgfSksXG4gICAgICAgIHsgYWJvcnRTaWduYWwgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7XG4gICAgICAgICAgbWF4UmV0cmllcyxcbiAgICAgICAgICBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsXG4gICAgICAgICAgYmFja29mZkZhY3RvcixcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbC9wcmVwYXJlLXJldHJpZXMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXRyaWVzKHtcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWxcbn0pIHtcbiAgaWYgKG1heFJldHJpZXMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhSZXRyaWVzKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFJldHJpZXNcIixcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4UmV0cmllcyBtdXN0IGJlID49IDBcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG1heFJldHJpZXNSZXN1bHQgPSBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMjtcbiAgcmV0dXJuIHtcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzUmVzdWx0LFxuICAgIHJldHJ5OiByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmZSZXNwZWN0aW5nUmV0cnlIZWFkZXJzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNSZXN1bHQsXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2NvbGxlY3QtdG9vbC1hcHByb3ZhbHMudHNcbmZ1bmN0aW9uIGNvbGxlY3RUb29sQXBwcm92YWxzKHtcbiAgbWVzc2FnZXNcbn0pIHtcbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlcy5hdCgtMSk7XG4gIGlmICgobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpICE9IFwidG9vbFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFwcHJvdmVkVG9vbEFwcHJvdmFsczogW10sXG4gICAgICBkZW5pZWRUb29sQXBwcm92YWxzOiBbXVxuICAgIH07XG4gIH1cbiAgY29uc3QgdG9vbENhbGxzQnlUb29sQ2FsbElkID0ge307XG4gIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgIGlmIChtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgdHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgY29udGVudCA9IG1lc3NhZ2UuY29udGVudDtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICB0b29sQ2FsbHNCeVRvb2xDYWxsSWRbcGFydC50b29sQ2FsbElkXSA9IHBhcnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgdG9vbEFwcHJvdmFsUmVxdWVzdHNCeUFwcHJvdmFsSWQgPSB7fTtcbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG1lc3NhZ2Uucm9sZSA9PT0gXCJhc3Npc3RhbnRcIiAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIikge1xuICAgICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RzQnlBcHByb3ZhbElkW3BhcnQuYXBwcm92YWxJZF0gPSBwYXJ0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBsYXN0TWVzc2FnZS5jb250ZW50KSB7XG4gICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiKSB7XG4gICAgICB0b29sUmVzdWx0c1twYXJ0LnRvb2xDYWxsSWRdID0gcGFydDtcbiAgICB9XG4gIH1cbiAgY29uc3QgYXBwcm92ZWRUb29sQXBwcm92YWxzID0gW107XG4gIGNvbnN0IGRlbmllZFRvb2xBcHByb3ZhbHMgPSBbXTtcbiAgY29uc3QgYXBwcm92YWxSZXNwb25zZXMgPSBsYXN0TWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIlxuICApO1xuICBmb3IgKGNvbnN0IGFwcHJvdmFsUmVzcG9uc2Ugb2YgYXBwcm92YWxSZXNwb25zZXMpIHtcbiAgICBjb25zdCBhcHByb3ZhbFJlcXVlc3QgPSB0b29sQXBwcm92YWxSZXF1ZXN0c0J5QXBwcm92YWxJZFthcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWRdO1xuICAgIGlmIChhcHByb3ZhbFJlcXVlc3QgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXBwcm92YWxFcnJvcih7XG4gICAgICAgIGFwcHJvdmFsSWQ6IGFwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0b29sUmVzdWx0c1thcHByb3ZhbFJlcXVlc3QudG9vbENhbGxJZF0gIT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzQnlUb29sQ2FsbElkW2FwcHJvdmFsUmVxdWVzdC50b29sQ2FsbElkXTtcbiAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFRvb2xDYWxsTm90Rm91bmRGb3JBcHByb3ZhbEVycm9yKHtcbiAgICAgICAgdG9vbENhbGxJZDogYXBwcm92YWxSZXF1ZXN0LnRvb2xDYWxsSWQsXG4gICAgICAgIGFwcHJvdmFsSWQ6IGFwcHJvdmFsUmVxdWVzdC5hcHByb3ZhbElkXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXBwcm92YWwgPSB7XG4gICAgICBhcHByb3ZhbFJlcXVlc3QsXG4gICAgICBhcHByb3ZhbFJlc3BvbnNlLFxuICAgICAgdG9vbENhbGxcbiAgICB9O1xuICAgIGlmIChhcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmVkKSB7XG4gICAgICBhcHByb3ZlZFRvb2xBcHByb3ZhbHMucHVzaChhcHByb3ZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbmllZFRvb2xBcHByb3ZhbHMucHVzaChhcHByb3ZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGFwcHJvdmVkVG9vbEFwcHJvdmFscywgZGVuaWVkVG9vbEFwcHJvdmFscyB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leGVjdXRlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHsgZXhlY3V0ZVRvb2wgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgb25QcmVsaW1pbmFyeVRvb2xSZXN1bHRcbn0pIHtcbiAgY29uc3QgeyB0b29sTmFtZSwgdG9vbENhbGxJZCwgaW5wdXQgfSA9IHRvb2xDYWxsO1xuICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sTmFtZV07XG4gIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgfSksXG4gICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sTmFtZSxcbiAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbElkLFxuICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoaW5wdXQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBsZXQgb3V0cHV0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gZXhlY3V0ZVRvb2woe1xuICAgICAgICAgIGV4ZWN1dGU6IHRvb2wyLmV4ZWN1dGUuYmluZCh0b29sMiksXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiBzdHJlYW0pIHtcbiAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInByZWxpbWluYXJ5XCIpIHtcbiAgICAgICAgICAgIG9uUHJlbGltaW5hcnlUb29sUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBvblByZWxpbWluYXJ5VG9vbFJlc3VsdCh7XG4gICAgICAgICAgICAgIC4uLnRvb2xDYWxsLFxuICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgIG91dHB1dDogcGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgIHByZWxpbWluYXJ5OiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0ID0gcGFydC5vdXRwdXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWNvcmRFcnJvck9uU3BhbihzcGFuLCBlcnJvcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICBkeW5hbWljOiB0b29sMi50eXBlID09PSBcImR5bmFtaWNcIixcbiAgICAgICAgICAuLi50b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkudG9vbENhbGwucmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgIHRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lLFxuICAgICAgICBpbnB1dCxcbiAgICAgICAgb3V0cHV0LFxuICAgICAgICBkeW5hbWljOiB0b29sMi50eXBlID09PSBcImR5bmFtaWNcIixcbiAgICAgICAgLi4udG9vbENhbGwucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LXRleHQtY29udGVudC50c1xuZnVuY3Rpb24gZXh0cmFjdFRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgY29uc3QgcGFydHMgPSBjb250ZW50LmZpbHRlcihcbiAgICAoY29udGVudDIpID0+IGNvbnRlbnQyLnR5cGUgPT09IFwidGV4dFwiXG4gICk7XG4gIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXCIpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZWQtZmlsZS50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5MyxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCBhcyBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0MlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIERlZmF1bHRHZW5lcmF0ZWRGaWxlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZWRpYVR5cGVcbiAgfSkge1xuICAgIGNvbnN0IGlzVWludDhBcnJheSA9IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgIHRoaXMuYmFzZTY0RGF0YSA9IGlzVWludDhBcnJheSA/IHZvaWQgMCA6IGRhdGE7XG4gICAgdGhpcy51aW50OEFycmF5RGF0YSA9IGlzVWludDhBcnJheSA/IGRhdGEgOiB2b2lkIDA7XG4gICAgdGhpcy5tZWRpYVR5cGUgPSBtZWRpYVR5cGU7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgYmFzZTY0KCkge1xuICAgIGlmICh0aGlzLmJhc2U2NERhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy5iYXNlNjREYXRhID0gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NDIodGhpcy51aW50OEFycmF5RGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJhc2U2NERhdGE7XG4gIH1cbiAgLy8gbGF6eSBjb252ZXJzaW9uIHdpdGggY2FjaGluZyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBjb252ZXJzaW9uIG92ZXJoZWFkOlxuICBnZXQgdWludDhBcnJheSgpIHtcbiAgICBpZiAodGhpcy51aW50OEFycmF5RGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLnVpbnQ4QXJyYXlEYXRhID0gY29udmVydEJhc2U2NFRvVWludDhBcnJheTModGhpcy5iYXNlNjREYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudWludDhBcnJheURhdGE7XG4gIH1cbn07XG52YXIgRGVmYXVsdEdlbmVyYXRlZEZpbGVXaXRoVHlwZSA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdEdlbmVyYXRlZEZpbGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy50eXBlID0gXCJmaWxlXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L2lzLWFwcHJvdmFsLW5lZWRlZC50c1xuYXN5bmMgZnVuY3Rpb24gaXNBcHByb3ZhbE5lZWRlZCh7XG4gIHRvb2w6IHRvb2wyLFxuICB0b29sQ2FsbCxcbiAgbWVzc2FnZXMsXG4gIGV4cGVyaW1lbnRhbF9jb250ZXh0XG59KSB7XG4gIGlmICh0b29sMi5uZWVkc0FwcHJvdmFsID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHR5cGVvZiB0b29sMi5uZWVkc0FwcHJvdmFsID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0b29sMi5uZWVkc0FwcHJvdmFsO1xuICB9XG4gIHJldHVybiBhd2FpdCB0b29sMi5uZWVkc0FwcHJvdmFsKHRvb2xDYWxsLmlucHV0LCB7XG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICBtZXNzYWdlcyxcbiAgICBleHBlcmltZW50YWxfY29udGV4dFxuICB9KTtcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvb3V0cHV0LnRzXG52YXIgb3V0cHV0X2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KG91dHB1dF9leHBvcnRzLCB7XG4gIGFycmF5OiAoKSA9PiBhcnJheSxcbiAgY2hvaWNlOiAoKSA9PiBjaG9pY2UsXG4gIGpzb246ICgpID0+IGpzb24sXG4gIG9iamVjdDogKCkgPT4gb2JqZWN0LFxuICB0ZXh0OiAoKSA9PiB0ZXh0XG59KTtcbmltcG9ydCB7XG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGFzU2NoZW1hIGFzIGFzU2NoZW1hMixcbiAgcmVzb2x2ZSxcbiAgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMixcbiAgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy91dGlsL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5hc3luYyBmdW5jdGlvbiBwYXJzZVBhcnRpYWxKc29uKGpzb25UZXh0KSB7XG4gIGlmIChqc29uVGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwidW5kZWZpbmVkLWlucHV0XCIgfTtcbiAgfVxuICBsZXQgcmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTih7IHRleHQ6IGpzb25UZXh0IH0pO1xuICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogcmVzdWx0LnZhbHVlLCBzdGF0ZTogXCJzdWNjZXNzZnVsLXBhcnNlXCIgfTtcbiAgfVxuICByZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OKHsgdGV4dDogZml4SnNvbihqc29uVGV4dCkgfSk7XG4gIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgIHJldHVybiB7IHZhbHVlOiByZXN1bHQudmFsdWUsIHN0YXRlOiBcInJlcGFpcmVkLXBhcnNlXCIgfTtcbiAgfVxuICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJmYWlsZWQtcGFyc2VcIiB9O1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9vdXRwdXQudHNcbnZhciB0ZXh0ID0gKCkgPT4gKHtcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHJlc3BvbnNlRm9ybWF0OiBQcm9taXNlLnJlc29sdmUoeyB0eXBlOiBcInRleHRcIiB9KSxcbiAgYXN5bmMgcGFyc2VDb21wbGV0ZU91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICByZXR1cm4gdGV4dDI7XG4gIH0sXG4gIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICByZXR1cm4geyBwYXJ0aWFsOiB0ZXh0MiB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn0pO1xudmFyIG9iamVjdCA9ICh7XG4gIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gIG5hbWU6IG5hbWUyMSxcbiAgZGVzY3JpcHRpb25cbn0pID0+IHtcbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEyKGlucHV0U2NoZW1hKTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcIm9iamVjdFwiLFxuICAgIHJlc3BvbnNlRm9ybWF0OiByZXNvbHZlKHNjaGVtYS5qc29uU2NoZW1hKS50aGVuKChqc29uU2NoZW1hMikgPT4gKHtcbiAgICAgIHR5cGU6IFwianNvblwiLFxuICAgICAgc2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICAgIC4uLm5hbWUyMSAhPSBudWxsICYmIHsgbmFtZTogbmFtZTIxIH0sXG4gICAgICAuLi5kZXNjcmlwdGlvbiAhPSBudWxsICYmIHsgZGVzY3JpcHRpb24gfVxuICAgIH0pKSxcbiAgICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSwgY29udGV4dDIpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzMih7XG4gICAgICAgIHZhbHVlOiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICAgICAgc2NoZW1hXG4gICAgICB9KTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHJlc3BvbnNlIGRpZCBub3QgbWF0Y2ggc2NoZW1hLlwiLFxuICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24odGV4dDIpO1xuICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkLWlucHV0XCI6IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIE5vdGU6IGN1cnJlbnRseSBubyB2YWxpZGF0aW9uIG9mIHBhcnRpYWwgcmVzdWx0czpcbiAgICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdC52YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn07XG52YXIgYXJyYXkgPSAoe1xuICBlbGVtZW50OiBpbnB1dEVsZW1lbnRTY2hlbWEsXG4gIG5hbWU6IG5hbWUyMSxcbiAgZGVzY3JpcHRpb25cbn0pID0+IHtcbiAgY29uc3QgZWxlbWVudFNjaGVtYSA9IGFzU2NoZW1hMihpbnB1dEVsZW1lbnRTY2hlbWEpO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwiYXJyYXlcIixcbiAgICAvLyBKU09OIHNjaGVtYSB0aGF0IGRlc2NyaWJlcyBhbiBhcnJheSBvZiBlbGVtZW50czpcbiAgICByZXNwb25zZUZvcm1hdDogcmVzb2x2ZShlbGVtZW50U2NoZW1hLmpzb25TY2hlbWEpLnRoZW4oKGpzb25TY2hlbWEyKSA9PiB7XG4gICAgICBjb25zdCB7ICRzY2hlbWEsIC4uLml0ZW1TY2hlbWEgfSA9IGpzb25TY2hlbWEyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJqc29uXCIsXG4gICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBlbGVtZW50czogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiBpdGVtU2NoZW1hIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbXCJlbGVtZW50c1wiXSxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgLi4ubmFtZTIxICE9IG51bGwgJiYgeyBuYW1lOiBuYW1lMjEgfSxcbiAgICAgICAgLi4uZGVzY3JpcHRpb24gIT0gbnVsbCAmJiB7IGRlc2NyaXB0aW9uIH1cbiAgICAgIH07XG4gICAgfSksXG4gICAgYXN5bmMgcGFyc2VDb21wbGV0ZU91dHB1dCh7IHRleHQ6IHRleHQyIH0sIGNvbnRleHQyKSB7XG4gICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGF3YWl0IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdGV4dDIgfSk7XG4gICAgICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZS5cIixcbiAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBjb250ZXh0Mi51c2FnZSxcbiAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dGVyVmFsdWUgPSBwYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgIGlmIChvdXRlclZhbHVlID09IG51bGwgfHwgdHlwZW9mIG91dGVyVmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImVsZW1lbnRzXCIgaW4gb3V0ZXJWYWx1ZSkgfHwgIUFycmF5LmlzQXJyYXkob3V0ZXJWYWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgICAgY2F1c2U6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yMih7XG4gICAgICAgICAgICB2YWx1ZTogb3V0ZXJWYWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInJlc3BvbnNlIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggYW4gZWxlbWVudHMgYXJyYXlcIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2Ygb3V0ZXJWYWx1ZS5lbGVtZW50cykge1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2FmZVZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICB2YWx1ZTogZWxlbWVudCxcbiAgICAgICAgICBzY2hlbWE6IGVsZW1lbnRTY2hlbWFcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgICAgICAgdGV4dDogdGV4dDIsXG4gICAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0ZXJWYWx1ZS5lbGVtZW50cztcbiAgICB9LFxuICAgIGFzeW5jIHBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24odGV4dDIpO1xuICAgICAgc3dpdGNoIChyZXN1bHQuc3RhdGUpIHtcbiAgICAgICAgY2FzZSBcImZhaWxlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwidW5kZWZpbmVkLWlucHV0XCI6IHtcbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJyZXBhaXJlZC1wYXJzZVwiOlxuICAgICAgICBjYXNlIFwic3VjY2Vzc2Z1bC1wYXJzZVwiOiB7XG4gICAgICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICBpZiAob3V0ZXJWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBvdXRlclZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJlbGVtZW50c1wiIGluIG91dGVyVmFsdWUpIHx8ICFBcnJheS5pc0FycmF5KG91dGVyVmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByYXdFbGVtZW50cyA9IHJlc3VsdC5zdGF0ZSA9PT0gXCJyZXBhaXJlZC1wYXJzZVwiICYmIG91dGVyVmFsdWUuZWxlbWVudHMubGVuZ3RoID4gMCA/IG91dGVyVmFsdWUuZWxlbWVudHMuc2xpY2UoMCwgLTEpIDogb3V0ZXJWYWx1ZS5lbGVtZW50cztcbiAgICAgICAgICBjb25zdCBwYXJzZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgIGZvciAoY29uc3QgcmF3RWxlbWVudCBvZiByYXdFbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzMih7XG4gICAgICAgICAgICAgIHZhbHVlOiByYXdFbGVtZW50LFxuICAgICAgICAgICAgICBzY2hlbWE6IGVsZW1lbnRTY2hlbWFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICBwYXJzZWRFbGVtZW50cy5wdXNoKHZhbGlkYXRpb25SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBwYXJ0aWFsOiBwYXJzZWRFbGVtZW50cyB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtVHJhbnNmb3JtKCkge1xuICAgICAgbGV0IHB1Ymxpc2hlZEVsZW1lbnRzID0gMDtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgcGFydGlhbE91dHB1dCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKHBhcnRpYWxPdXRwdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICg7IHB1Ymxpc2hlZEVsZW1lbnRzIDwgcGFydGlhbE91dHB1dC5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXRbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG52YXIgY2hvaWNlID0gKHtcbiAgb3B0aW9uczogY2hvaWNlT3B0aW9ucyxcbiAgbmFtZTogbmFtZTIxLFxuICBkZXNjcmlwdGlvblxufSkgPT4ge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IFwiY2hvaWNlXCIsXG4gICAgLy8gSlNPTiBzY2hlbWEgdGhhdCBkZXNjcmliZXMgYW4gZW51bWVyYXRpb246XG4gICAgcmVzcG9uc2VGb3JtYXQ6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgIHNjaGVtYToge1xuICAgICAgICAkc2NoZW1hOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgcmVzdWx0OiB7IHR5cGU6IFwic3RyaW5nXCIsIGVudW06IGNob2ljZU9wdGlvbnMgfVxuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlZDogW1wicmVzdWx0XCJdLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICAgIH0sXG4gICAgICAuLi5uYW1lMjEgIT0gbnVsbCAmJiB7IG5hbWU6IG5hbWUyMSB9LFxuICAgICAgLi4uZGVzY3JpcHRpb24gIT0gbnVsbCAmJiB7IGRlc2NyaXB0aW9uIH1cbiAgICB9KSxcbiAgICBhc3luYyBwYXJzZUNvbXBsZXRlT3V0cHV0KHsgdGV4dDogdGV4dDIgfSwgY29udGV4dDIpIHtcbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgc2FmZVBhcnNlSlNPTjIoeyB0ZXh0OiB0ZXh0MiB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvcixcbiAgICAgICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogY29udGV4dDIuZmluaXNoUmVhc29uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0ZXJWYWx1ZSA9IHBhcnNlUmVzdWx0LnZhbHVlO1xuICAgICAgaWYgKG91dGVyVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwicmVzdWx0XCIgaW4gb3V0ZXJWYWx1ZSkgfHwgdHlwZW9mIG91dGVyVmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiIHx8ICFjaG9pY2VPcHRpb25zLmluY2x1ZGVzKG91dGVyVmFsdWUucmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgICAgICBjYXVzZTogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3IyKHtcbiAgICAgICAgICAgIHZhbHVlOiBvdXRlclZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwicmVzcG9uc2UgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIGNob2ljZSB2YWx1ZS5cIlxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0ZXJWYWx1ZS5yZXN1bHQ7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKHRleHQyKTtcbiAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZC1pbnB1dFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjoge1xuICAgICAgICAgIGNvbnN0IG91dGVyVmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgaWYgKG91dGVyVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygb3V0ZXJWYWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwicmVzdWx0XCIgaW4gb3V0ZXJWYWx1ZSkgfHwgdHlwZW9mIG91dGVyVmFsdWUucmVzdWx0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwb3RlbnRpYWxNYXRjaGVzID0gY2hvaWNlT3B0aW9ucy5maWx0ZXIoXG4gICAgICAgICAgICAoY2hvaWNlT3B0aW9uKSA9PiBjaG9pY2VPcHRpb24uc3RhcnRzV2l0aChvdXRlclZhbHVlLnJlc3VsdClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdGUgPT09IFwic3VjY2Vzc2Z1bC1wYXJzZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsTWF0Y2hlcy5pbmNsdWRlcyhvdXRlclZhbHVlLnJlc3VsdCkgPyB7IHBhcnRpYWw6IG91dGVyVmFsdWUucmVzdWx0IH0gOiB2b2lkIDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxNYXRjaGVzLmxlbmd0aCA9PT0gMSA/IHsgcGFydGlhbDogcG90ZW50aWFsTWF0Y2hlc1swXSB9IDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbVRyYW5zZm9ybSgpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9O1xufTtcbnZhciBqc29uID0gKHtcbiAgbmFtZTogbmFtZTIxLFxuICBkZXNjcmlwdGlvblxufSA9IHt9KSA9PiB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogXCJqc29uXCIsXG4gICAgcmVzcG9uc2VGb3JtYXQ6IFByb21pc2UucmVzb2x2ZSh7XG4gICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgIC4uLm5hbWUyMSAhPSBudWxsICYmIHsgbmFtZTogbmFtZTIxIH0sXG4gICAgICAuLi5kZXNjcmlwdGlvbiAhPSBudWxsICYmIHsgZGVzY3JpcHRpb24gfVxuICAgIH0pLFxuICAgIGFzeW5jIHBhcnNlQ29tcGxldGVPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9LCBjb250ZXh0Mikge1xuICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09OMih7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2UuXCIsXG4gICAgICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgICAgIHRleHQ6IHRleHQyLFxuICAgICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgICB1c2FnZTogY29udGV4dDIudXNhZ2UsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VSZXN1bHQudmFsdWU7XG4gICAgfSxcbiAgICBhc3luYyBwYXJzZVBhcnRpYWxPdXRwdXQoeyB0ZXh0OiB0ZXh0MiB9KSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBwYXJzZVBhcnRpYWxKc29uKHRleHQyKTtcbiAgICAgIHN3aXRjaCAocmVzdWx0LnN0YXRlKSB7XG4gICAgICAgIGNhc2UgXCJmYWlsZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZC1pbnB1dFwiOiB7XG4gICAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwicmVwYWlyZWQtcGFyc2VcIjpcbiAgICAgICAgY2FzZSBcInN1Y2Nlc3NmdWwtcGFyc2VcIjoge1xuICAgICAgICAgIHJldHVybiByZXN1bHQudmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHsgcGFydGlhbDogcmVzdWx0LnZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHtcbiAgYXNTY2hlbWEgYXMgYXNTY2hlbWEzLFxuICBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04zLFxuICBzYWZlVmFsaWRhdGVUeXBlcyBhcyBzYWZlVmFsaWRhdGVUeXBlczNcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHMsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBzeXN0ZW0sXG4gIG1lc3NhZ2VzXG59KSB7XG4gIHZhciBfYTIxO1xuICB0cnkge1xuICAgIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgICBpZiAodG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAmJiB0b29sQ2FsbC5keW5hbWljKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBwYXJzZVByb3ZpZGVyRXhlY3V0ZWREeW5hbWljVG9vbENhbGwodG9vbENhbGwpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBkb1BhcnNlVG9vbENhbGwoeyB0b29sQ2FsbCwgdG9vbHMgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChyZXBhaXJUb29sQ2FsbCA9PSBudWxsIHx8ICEoTm9TdWNoVG9vbEVycm9yLmlzSW5zdGFuY2UoZXJyb3IpIHx8IEludmFsaWRUb29sSW5wdXRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICBsZXQgcmVwYWlyZWRUb29sQ2FsbCA9IG51bGw7XG4gICAgICB0cnkge1xuICAgICAgICByZXBhaXJlZFRvb2xDYWxsID0gYXdhaXQgcmVwYWlyVG9vbENhbGwoe1xuICAgICAgICAgIHRvb2xDYWxsLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiBhc3luYyAoeyB0b29sTmFtZSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlucHV0U2NoZW1hIH0gPSB0b29sc1t0b29sTmFtZV07XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXNTY2hlbWEzKGlucHV0U2NoZW1hKS5qc29uU2NoZW1hO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc3lzdGVtLFxuICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAocmVwYWlyRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRvb2xDYWxsUmVwYWlyRXJyb3Ioe1xuICAgICAgICAgIGNhdXNlOiByZXBhaXJFcnJvcixcbiAgICAgICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXBhaXJlZFRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgZG9QYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IHJlcGFpcmVkVG9vbENhbGwsIHRvb2xzIH0pO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBwYXJzZWRJbnB1dCA9IGF3YWl0IHNhZmVQYXJzZUpTT04zKHsgdGV4dDogdG9vbENhbGwuaW5wdXQgfSk7XG4gICAgY29uc3QgaW5wdXQgPSBwYXJzZWRJbnB1dC5zdWNjZXNzID8gcGFyc2VkSW5wdXQudmFsdWUgOiB0b29sQ2FsbC5pbnB1dDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBpbnB1dCxcbiAgICAgIGR5bmFtaWM6IHRydWUsXG4gICAgICBpbnZhbGlkOiB0cnVlLFxuICAgICAgZXJyb3IsXG4gICAgICB0aXRsZTogKF9hMjEgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS50aXRsZSxcbiAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhXG4gICAgfTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VQcm92aWRlckV4ZWN1dGVkRHluYW1pY1Rvb2xDYWxsKHRvb2xDYWxsKSB7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gdG9vbENhbGwuaW5wdXQudHJpbSgpID09PSBcIlwiID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZToge30gfSA6IGF3YWl0IHNhZmVQYXJzZUpTT04zKHsgdGV4dDogdG9vbENhbGwuaW5wdXQgfSk7XG4gIGlmIChwYXJzZVJlc3VsdC5zdWNjZXNzID09PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbElucHV0RXJyb3Ioe1xuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgdG9vbElucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICBpbnB1dDogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICBkeW5hbWljOiB0cnVlLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGFcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGRvUGFyc2VUb29sQ2FsbCh7XG4gIHRvb2xDYWxsLFxuICB0b29sc1xufSkge1xuICBjb25zdCB0b29sTmFtZSA9IHRvb2xDYWxsLnRvb2xOYW1lO1xuICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICBpZiAodG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAmJiB0b29sQ2FsbC5keW5hbWljKSB7XG4gICAgICByZXR1cm4gYXdhaXQgcGFyc2VQcm92aWRlckV4ZWN1dGVkRHluYW1pY1Rvb2xDYWxsKHRvb2xDYWxsKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7XG4gICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2NoZW1hID0gYXNTY2hlbWEzKHRvb2wyLmlucHV0U2NoZW1hKTtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSB0b29sQ2FsbC5pbnB1dC50cmltKCkgPT09IFwiXCIgPyBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczMoeyB2YWx1ZToge30sIHNjaGVtYSB9KSA6IGF3YWl0IHNhZmVQYXJzZUpTT04zKHsgdGV4dDogdG9vbENhbGwuaW5wdXQsIHNjaGVtYSB9KTtcbiAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRUb29sSW5wdXRFcnJvcih7XG4gICAgICB0b29sTmFtZSxcbiAgICAgIHRvb2xJbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3JcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdG9vbDIudHlwZSA9PT0gXCJkeW5hbWljXCIgPyB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICBpbnB1dDogcGFyc2VSZXN1bHQudmFsdWUsXG4gICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCxcbiAgICBwcm92aWRlck1ldGFkYXRhOiB0b29sQ2FsbC5wcm92aWRlck1ldGFkYXRhLFxuICAgIGR5bmFtaWM6IHRydWUsXG4gICAgdGl0bGU6IHRvb2wyLnRpdGxlXG4gIH0gOiB7XG4gICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgIHRvb2xOYW1lLFxuICAgIGlucHV0OiBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICBwcm92aWRlckV4ZWN1dGVkOiB0b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkLFxuICAgIHByb3ZpZGVyTWV0YWRhdGE6IHRvb2xDYWxsLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgdGl0bGU6IHRvb2wyLnRpdGxlXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0ZXAtcmVzdWx0LnRzXG52YXIgRGVmYXVsdFN0ZXBSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb250ZW50LFxuICAgIGZpbmlzaFJlYXNvbixcbiAgICByYXdGaW5pc2hSZWFzb24sXG4gICAgdXNhZ2UsXG4gICAgd2FybmluZ3MsXG4gICAgcmVxdWVzdCxcbiAgICByZXNwb25zZSxcbiAgICBwcm92aWRlck1ldGFkYXRhXG4gIH0pIHtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gZmluaXNoUmVhc29uO1xuICAgIHRoaXMucmF3RmluaXNoUmVhc29uID0gcmF3RmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YTtcbiAgfVxuICBnZXQgdGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRleHRcIikubWFwKChwYXJ0KSA9PiBwYXJ0LnRleHQpLmpvaW4oXCJcIik7XG4gIH1cbiAgZ2V0IHJlYXNvbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInJlYXNvbmluZ1wiKTtcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFzb25pbmcubGVuZ3RoID09PSAwID8gdm9pZCAwIDogdGhpcy5yZWFzb25pbmcubWFwKChwYXJ0KSA9PiBwYXJ0LnRleHQpLmpvaW4oXCJcIik7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwiZmlsZVwiKS5tYXAoKHBhcnQpID0+IHBhcnQuZmlsZSk7XG4gIH1cbiAgZ2V0IHNvdXJjZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5maWx0ZXIoKHBhcnQpID0+IHBhcnQudHlwZSA9PT0gXCJzb3VyY2VcIik7XG4gIH1cbiAgZ2V0IHRvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmR5bmFtaWMgIT09IHRydWVcbiAgICApO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmR5bmFtaWMgPT09IHRydWVcbiAgICApO1xuICB9XG4gIGdldCB0b29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZW50LmZpbHRlcigocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpO1xuICB9XG4gIGdldCBzdGF0aWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy50b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgICAodG9vbFJlc3VsdCkgPT4gdG9vbFJlc3VsdC5keW5hbWljICE9PSB0cnVlXG4gICAgKTtcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLnRvb2xSZXN1bHRzLmZpbHRlcihcbiAgICAgICh0b29sUmVzdWx0KSA9PiB0b29sUmVzdWx0LmR5bmFtaWMgPT09IHRydWVcbiAgICApO1xuICB9XG59O1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9zdG9wLWNvbmRpdGlvbi50c1xuZnVuY3Rpb24gc3RlcENvdW50SXMoc3RlcENvdW50KSB7XG4gIHJldHVybiAoeyBzdGVwcyB9KSA9PiBzdGVwcy5sZW5ndGggPT09IHN0ZXBDb3VudDtcbn1cbmZ1bmN0aW9uIGhhc1Rvb2xDYWxsKHRvb2xOYW1lKSB7XG4gIHJldHVybiAoeyBzdGVwcyB9KSA9PiB7XG4gICAgdmFyIF9hMjEsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hMjEgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2Iuc29tZShcbiAgICAgICh0b29sQ2FsbCkgPT4gdG9vbENhbGwudG9vbE5hbWUgPT09IHRvb2xOYW1lXG4gICAgKSkgIT0gbnVsbCA/IF9jIDogZmFsc2U7XG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiBpc1N0b3BDb25kaXRpb25NZXQoe1xuICBzdG9wQ29uZGl0aW9ucyxcbiAgc3RlcHNcbn0pIHtcbiAgcmV0dXJuIChhd2FpdCBQcm9taXNlLmFsbChzdG9wQ29uZGl0aW9ucy5tYXAoKGNvbmRpdGlvbikgPT4gY29uZGl0aW9uKHsgc3RlcHMgfSkpKSkuc29tZSgocmVzdWx0KSA9PiByZXN1bHQpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC90by1yZXNwb25zZS1tZXNzYWdlcy50c1xuYXN5bmMgZnVuY3Rpb24gdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgY29udGVudDogaW5wdXRDb250ZW50LFxuICB0b29sc1xufSkge1xuICBjb25zdCByZXNwb25zZU1lc3NhZ2VzID0gW107XG4gIGNvbnN0IGNvbnRlbnQgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGlucHV0Q29udGVudCkge1xuICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoKHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIpICYmICFwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocGFydC50eXBlID09PSBcInRleHRcIiAmJiBwYXJ0LnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjpcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmlsZVwiOlxuICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgIGRhdGE6IHBhcnQuZmlsZS5iYXNlNjQsXG4gICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0LmZpbGUubWVkaWFUeXBlLFxuICAgICAgICAgIHByb3ZpZGVyT3B0aW9uczogcGFydC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjpcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICBpbnB1dDogcGFydC5pbnB1dCxcbiAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgdG9vbDogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3BhcnQudG9vbE5hbWVdLFxuICAgICAgICAgIG91dHB1dDogcGFydC5vdXRwdXQsXG4gICAgICAgICAgZXJyb3JNb2RlOiBcIm5vbmVcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbC1lcnJvclwiOiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1twYXJ0LnRvb2xOYW1lXSxcbiAgICAgICAgICBvdXRwdXQ6IHBhcnQuZXJyb3IsXG4gICAgICAgICAgZXJyb3JNb2RlOiBcImpzb25cIlxuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6XG4gICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsSWQsXG4gICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbC50b29sQ2FsbElkXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaCh7XG4gICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHRvb2xSZXN1bHRDb250ZW50ID0gW107XG4gIGZvciAoY29uc3QgcGFydCBvZiBpbnB1dENvbnRlbnQpIHtcbiAgICBpZiAoIShwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiKSB8fCBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICB0b29sOiB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbcGFydC50b29sTmFtZV0sXG4gICAgICBvdXRwdXQ6IHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiID8gcGFydC5vdXRwdXQgOiBwYXJ0LmVycm9yLFxuICAgICAgZXJyb3JNb2RlOiBwYXJ0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJ0ZXh0XCIgOiBcIm5vbmVcIlxuICAgIH0pO1xuICAgIHRvb2xSZXN1bHRDb250ZW50LnB1c2goe1xuICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICBvdXRwdXQsXG4gICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgfSk7XG4gIH1cbiAgaWYgKHRvb2xSZXN1bHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0Q29udGVudFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXNwb25zZU1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvdXRpbC9tZXJnZS1hYm9ydC1zaWduYWxzLnRzXG5mdW5jdGlvbiBtZXJnZUFib3J0U2lnbmFscyguLi5zaWduYWxzKSB7XG4gIGNvbnN0IHZhbGlkU2lnbmFscyA9IHNpZ25hbHMuZmlsdGVyKFxuICAgIChzaWduYWwpID0+IHNpZ25hbCAhPSBudWxsXG4gICk7XG4gIGlmICh2YWxpZFNpZ25hbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAodmFsaWRTaWduYWxzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWxpZFNpZ25hbHNbMF07XG4gIH1cbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgZm9yIChjb25zdCBzaWduYWwgb2YgdmFsaWRTaWduYWxzKSB7XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBjb250cm9sbGVyLmFib3J0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwiYWJvcnRcIixcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5hYm9ydChzaWduYWwucmVhc29uKTtcbiAgICAgIH0sXG4gICAgICB7IG9uY2U6IHRydWUgfVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3Ioe1xuICBwcmVmaXg6IFwiYWl0eHRcIixcbiAgc2l6ZTogMjRcbn0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVUZXh0KHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgdGltZW91dCxcbiAgaGVhZGVycyxcbiAgc3RvcFdoZW4gPSBzdGVwQ291bnRJcygxKSxcbiAgZXhwZXJpbWVudGFsX291dHB1dCxcbiAgb3V0cHV0ID0gZXhwZXJpbWVudGFsX291dHB1dCxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgYWN0aXZlVG9vbHMgPSBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9wcmVwYXJlU3RlcCxcbiAgcHJlcGFyZVN0ZXAgPSBleHBlcmltZW50YWxfcHJlcGFyZVN0ZXAsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF9kb3dubG9hZDogZG93bmxvYWQyLFxuICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgZXhwZXJpbWVudGFsX2luY2x1ZGU6IGluY2x1ZGUsXG4gIF9pbnRlcm5hbDogeyBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZCB9ID0ge30sXG4gIG9uU3RlcEZpbmlzaCxcbiAgb25GaW5pc2gsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBzdG9wQ29uZGl0aW9ucyA9IGFzQXJyYXkoc3RvcFdoZW4pO1xuICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwVGltZW91dE1zID0gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3Qgc3RlcEFib3J0Q29udHJvbGxlciA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IHZvaWQgMDtcbiAgY29uc3QgbWVyZ2VkQWJvcnRTaWduYWwgPSBtZXJnZUFib3J0U2lnbmFscyhcbiAgICBhYm9ydFNpZ25hbCxcbiAgICB0b3RhbFRpbWVvdXRNcyAhPSBudWxsID8gQWJvcnRTaWduYWwudGltZW91dCh0b3RhbFRpbWVvdXRNcykgOiB2b2lkIDAsXG4gICAgc3RlcEFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogc3RlcEFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsXG4gIH0pO1xuICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4MihcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICBzZXR0aW5nczogeyAuLi5jYWxsU2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLmdlbmVyYXRlVGV4dFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHRcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTIxLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaztcbiAgICAgICAgY29uc3QgaW5pdGlhbE1lc3NhZ2VzID0gaW5pdGlhbFByb21wdC5tZXNzYWdlcztcbiAgICAgICAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCB7IGFwcHJvdmVkVG9vbEFwcHJvdmFscywgZGVuaWVkVG9vbEFwcHJvdmFscyB9ID0gY29sbGVjdFRvb2xBcHByb3ZhbHMoeyBtZXNzYWdlczogaW5pdGlhbE1lc3NhZ2VzIH0pO1xuICAgICAgICBjb25zdCBsb2NhbEFwcHJvdmVkVG9vbEFwcHJvdmFscyA9IGFwcHJvdmVkVG9vbEFwcHJvdmFscy5maWx0ZXIoXG4gICAgICAgICAgKHRvb2xBcHByb3ZhbCkgPT4gIXRvb2xBcHByb3ZhbC50b29sQ2FsbC5wcm92aWRlckV4ZWN1dGVkXG4gICAgICAgICk7XG4gICAgICAgIGlmIChkZW5pZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDAgfHwgbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRvb2xPdXRwdXRzID0gYXdhaXQgZXhlY3V0ZVRvb2xzKHtcbiAgICAgICAgICAgIHRvb2xDYWxsczogbG9jYWxBcHByb3ZlZFRvb2xBcHByb3ZhbHMubWFwKFxuICAgICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgIG1lc3NhZ2VzOiBpbml0aWFsTWVzc2FnZXMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogbWVyZ2VkQWJvcnRTaWduYWwsXG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHRvb2xDb250ZW50ID0gW107XG4gICAgICAgICAgZm9yIChjb25zdCBvdXRwdXQyIG9mIHRvb2xPdXRwdXRzKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbE91dHB1dCA9IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG91dHB1dDIudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgaW5wdXQ6IG91dHB1dDIuaW5wdXQsXG4gICAgICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1tvdXRwdXQyLnRvb2xOYW1lXSxcbiAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IG91dHB1dDIub3V0cHV0IDogb3V0cHV0Mi5lcnJvcixcbiAgICAgICAgICAgICAgZXJyb3JNb2RlOiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJqc29uXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b29sQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvdXRwdXQyLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBvdXRwdXQyLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBvdXRwdXQ6IG1vZGVsT3V0cHV0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB0b29sQXBwcm92YWwgb2YgZGVuaWVkVG9vbEFwcHJvdmFscykge1xuICAgICAgICAgICAgdG9vbENvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXhlY3V0aW9uLWRlbmllZFwiLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UucmVhc29uLFxuICAgICAgICAgICAgICAgIC8vIEZvciBwcm92aWRlci1leGVjdXRlZCB0b29scywgaW5jbHVkZSBhcHByb3ZhbElkIHNvIHByb3ZpZGVyIGNhbiBjb3JyZWxhdGVcbiAgICAgICAgICAgICAgICAuLi50b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCAmJiB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbmFpOiB7XG4gICAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY29udGVudDogdG9vbENvbnRlbnRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscyA9IFtcbiAgICAgICAgICAuLi5hcHByb3ZlZFRvb2xBcHByb3ZhbHMsXG4gICAgICAgICAgLi4uZGVuaWVkVG9vbEFwcHJvdmFsc1xuICAgICAgICBdLmZpbHRlcigodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZCk7XG4gICAgICAgIGlmIChwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgY29udGVudDogcHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubWFwKFxuICAgICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiAoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmFsSWQsXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UucmVhc29uLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWxsU2V0dGluZ3MyID0gcHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyk7XG4gICAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgICAgbGV0IGNsaWVudFRvb2xDYWxscyA9IFtdO1xuICAgICAgICBsZXQgY2xpZW50VG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RlcHMgPSBbXTtcbiAgICAgICAgY29uc3QgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IHN0ZXBUaW1lb3V0SWQgPSBzdGVwVGltZW91dE1zICE9IG51bGwgPyBzZXRUaW1lb3V0KCgpID0+IHN0ZXBBYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgc3RlcFRpbWVvdXRNcykgOiB2b2lkIDA7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBJbnB1dE1lc3NhZ2VzID0gWy4uLmluaXRpYWxNZXNzYWdlcywgLi4ucmVzcG9uc2VNZXNzYWdlc107XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlU3RlcFJlc3VsdCA9IGF3YWl0IChwcmVwYXJlU3RlcCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXAoe1xuICAgICAgICAgICAgICBtb2RlbCxcbiAgICAgICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgICAgIHN0ZXBOdW1iZXI6IHN0ZXBzLmxlbmd0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwoXG4gICAgICAgICAgICAgIChfYTIxID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1vZGVsKSAhPSBudWxsID8gX2EyMSA6IG1vZGVsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICAgICAgc3lzdGVtOiAoX2IgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuc3lzdGVtKSAhPSBudWxsID8gX2IgOiBpbml0aWFsUHJvbXB0LnN5c3RlbSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlczogKF9jID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0Lm1lc3NhZ2VzKSAhPSBudWxsID8gX2MgOiBzdGVwSW5wdXRNZXNzYWdlc1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzdXBwb3J0ZWRVcmxzOiBhd2FpdCBzdGVwTW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCA9IChfZCA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5leHBlcmltZW50YWxfY29udGV4dCkgIT0gbnVsbCA/IF9kIDogZXhwZXJpbWVudGFsX2NvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLCB0b29sczogc3RlcFRvb2xzIH0gPSBhd2FpdCBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIHRvb2xDaG9pY2U6IChfZSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC50b29sQ2hvaWNlKSAhPSBudWxsID8gX2UgOiB0b29sQ2hvaWNlLFxuICAgICAgICAgICAgICBhY3RpdmVUb29sczogKF9mID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LmFjdGl2ZVRvb2xzKSAhPSBudWxsID8gX2YgOiBhY3RpdmVUb29sc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMjI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZVRleHQuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gbW9kZWw6XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5wcm92aWRlclwiOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9tcHQ6XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29scyA9PSBudWxsID8gdm9pZCAwIDogc3RlcFRvb2xzLm1hcCgodG9vbDIpID0+IEpTT04uc3RyaW5naWZ5KHRvb2wyKSlcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0ZXBUb29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENob2ljZSkgOiB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogc3RlcE1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogc3RlcE1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubWF4X3Rva2Vuc1wiOiBzZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IHNldHRpbmdzLnN0b3BTZXF1ZW5jZXMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiAoX2EyMiA9IHNldHRpbmdzLnRlbXBlcmF0dXJlKSAhPSBudWxsID8gX2EyMiA6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgICAgZm46IGFzeW5jIChzcGFuMikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EyMywgX2IyLCBfYzIsIF9kMiwgX2UyLCBfZjIsIF9nMiwgX2gyO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVwUHJvdmlkZXJPcHRpb25zID0gbWVyZ2VPYmplY3RzKFxuICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN0ZXBNb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MyLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdGVwVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENob2ljZTogc3RlcFRvb2xDaG9pY2UsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VGb3JtYXQ6IGF3YWl0IChvdXRwdXQgPT0gbnVsbCA/IHZvaWQgMCA6IG91dHB1dC5yZXNwb25zZUZvcm1hdCksXG4gICAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHN0ZXBQcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IChfYjIgPSAoX2EyMyA9IHJlc3VsdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjMuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kMiA9IChfYzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYzIudGltZXN0YW1wKSAhPSBudWxsID8gX2QyIDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mMiA9IChfZTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZTIubW9kZWxJZCkgIT0gbnVsbCA/IF9mMiA6IHN0ZXBNb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChfZzIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZzIuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoX2gyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2gyLmJvZHlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRleHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZXh0cmFjdFRleHRDb250ZW50KHJlc3VsdC5jb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhyZXN1bHQuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9vbENhbGxzID09IG51bGwgPyB2b2lkIDAgOiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IHJlc3BvbnNlRGF0YS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5wcm92aWRlck1ldGFkYXRhXCI6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0LnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmZpbmlzaFJlYXNvbi51bmlmaWVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UuaW5wdXRUb2tlbnMudG90YWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0LnVzYWdlLm91dHB1dFRva2Vucy50b3RhbFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IC4uLnJlc3VsdCwgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiXG4gICAgICAgICAgICAgICkubWFwKFxuICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3QgdG9vbEFwcHJvdmFsUmVxdWVzdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2Ygc3RlcFRvb2xDYWxscykge1xuICAgICAgICAgICAgICBpZiAodG9vbENhbGwuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5vbklucHV0QXZhaWxhYmxlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdG9vbDIub25JbnB1dEF2YWlsYWJsZSh7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYXdhaXQgaXNBcHByb3ZhbE5lZWRlZCh7XG4gICAgICAgICAgICAgICAgdG9vbDogdG9vbDIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgdG9vbEFwcHJvdmFsUmVxdWVzdHNbdG9vbENhbGwudG9vbENhbGxJZF0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW52YWxpZFRvb2xDYWxscyA9IHN0ZXBUb29sQ2FsbHMuZmlsdGVyKFxuICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLmludmFsaWQgJiYgdG9vbENhbGwuZHluYW1pY1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNsaWVudFRvb2xPdXRwdXRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIGludmFsaWRUb29sQ2FsbHMpIHtcbiAgICAgICAgICAgICAgY2xpZW50VG9vbE91dHB1dHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0LFxuICAgICAgICAgICAgICAgIGVycm9yOiBnZXRFcnJvck1lc3NhZ2U1KHRvb2xDYWxsLmVycm9yKSxcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xpZW50VG9vbENhbGxzID0gc3RlcFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gIXRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGllbnRUb29sT3V0cHV0cy5wdXNoKFxuICAgICAgICAgICAgICAgIC4uLmF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbHM6IGNsaWVudFRvb2xDYWxscy5maWx0ZXIoXG4gICAgICAgICAgICAgICAgICAgICh0b29sQ2FsbCkgPT4gIXRvb2xDYWxsLmludmFsaWQgJiYgdG9vbEFwcHJvdmFsUmVxdWVzdHNbdG9vbENhbGwudG9vbENhbGxJZF0gPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IG1lcmdlZEFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBzdGVwVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgIGlmICghdG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJwcm92aWRlclwiICYmIHRvb2wyLnN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzUmVzdWx0SW5SZXNwb25zZSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmNvbnRlbnQuc29tZShcbiAgICAgICAgICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiAmJiBwYXJ0LnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGlmICghaGFzUmVzdWx0SW5SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCkge1xuICAgICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgICAgICBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuZGVsZXRlKHBhcnQudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0ZXBDb250ZW50ID0gYXNDb250ZW50KHtcbiAgICAgICAgICAgICAgY29udGVudDogY3VycmVudE1vZGVsUmVzcG9uc2UuY29udGVudCxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sT3V0cHV0czogY2xpZW50VG9vbE91dHB1dHMsXG4gICAgICAgICAgICAgIHRvb2xBcHByb3ZhbFJlcXVlc3RzOiBPYmplY3QudmFsdWVzKHRvb2xBcHByb3ZhbFJlcXVlc3RzKSxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAuLi5hd2FpdCB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0ZXBDb250ZW50LFxuICAgICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgc3RlcFJlcXVlc3QgPSAoKF9nID0gaW5jbHVkZSA9PSBudWxsID8gdm9pZCAwIDogaW5jbHVkZS5yZXF1ZXN0Qm9keSkgIT0gbnVsbCA/IF9nIDogdHJ1ZSkgPyAoX2ggPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXF1ZXN0KSAhPSBudWxsID8gX2ggOiB7fSA6IHsgLi4uY3VycmVudE1vZGVsUmVzcG9uc2UucmVxdWVzdCwgYm9keTogdm9pZCAwIH07XG4gICAgICAgICAgICBjb25zdCBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgIC4uLmN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAvLyBkZWVwIGNsb25lIG1zZ3MgdG8gYXZvaWQgbXV0YXRpbmcgcGFzdCBtZXNzYWdlcyBpbiBtdWx0aS1zdGVwOlxuICAgICAgICAgICAgICBtZXNzYWdlczogc3RydWN0dXJlZENsb25lKHJlc3BvbnNlTWVzc2FnZXMpLFxuICAgICAgICAgICAgICAvLyBDb25kaXRpb25hbGx5IGluY2x1ZGUgcmVzcG9uc2UgYm9keTpcbiAgICAgICAgICAgICAgYm9keTogKChfaSA9IGluY2x1ZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluY2x1ZGUucmVzcG9uc2VCb2R5KSAhPSBudWxsID8gX2kgOiB0cnVlKSA/IChfaiA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ouYm9keSA6IHZvaWQgMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdGVwUmVzdWx0ID0gbmV3IERlZmF1bHRTdGVwUmVzdWx0KHtcbiAgICAgICAgICAgICAgY29udGVudDogc3RlcENvbnRlbnQsXG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgIHJhd0ZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLnJhdyxcbiAgICAgICAgICAgICAgdXNhZ2U6IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlKSxcbiAgICAgICAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IHN0ZXBSZXNwb25zZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgICAgICAgIHdhcm5pbmdzOiAoX2sgPSBjdXJyZW50TW9kZWxSZXNwb25zZS53YXJuaW5ncykgIT0gbnVsbCA/IF9rIDogW10sXG4gICAgICAgICAgICAgIHByb3ZpZGVyOiBzdGVwTW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIG1vZGVsOiBzdGVwTW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgICAgIGF3YWl0IChvblN0ZXBGaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uU3RlcEZpbmlzaChjdXJyZW50U3RlcFJlc3VsdCkpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoc3RlcFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChzdGVwVGltZW91dElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKFxuICAgICAgICAgIC8vIENvbnRpbnVlIGlmOlxuICAgICAgICAgIC8vIDEuIFRoZXJlIGFyZSBjbGllbnQgdG9vbCBjYWxscyB0aGF0IGhhdmUgYWxsIGJlZW4gZXhlY3V0ZWQsIE9SXG4gICAgICAgICAgLy8gMi4gVGhlcmUgYXJlIHBlbmRpbmcgZGVmZXJyZWQgcmVzdWx0cyBmcm9tIHByb3ZpZGVyLWV4ZWN1dGVkIHRvb2xzXG4gICAgICAgICAgKGNsaWVudFRvb2xDYWxscy5sZW5ndGggPiAwICYmIGNsaWVudFRvb2xPdXRwdXRzLmxlbmd0aCA9PT0gY2xpZW50VG9vbENhbGxzLmxlbmd0aCB8fCBwZW5kaW5nRGVmZXJyZWRUb29sQ2FsbHMuc2l6ZSA+IDApICYmIC8vIGNvbnRpbnVlIHVudGlsIGEgc3RvcCBjb25kaXRpb24gaXMgbWV0OlxuICAgICAgICAgICFhd2FpdCBpc1N0b3BDb25kaXRpb25NZXQoeyBzdG9wQ29uZGl0aW9ucywgc3RlcHMgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24udW5pZmllZCxcbiAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGV4dHJhY3RUZXh0Q29udGVudChjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBhc1Rvb2xDYWxscyhjdXJyZW50TW9kZWxSZXNwb25zZS5jb250ZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0b29sQ2FsbHMgPT0gbnVsbCA/IHZvaWQgMCA6IEpTT04uc3RyaW5naWZ5KHRvb2xDYWxscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAvLyBUT0RPIHJlbmFtZSB0ZWxlbWV0cnkgYXR0cmlidXRlcyB0byBpbnB1dFRva2VucyBhbmQgb3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2Uub3V0cHV0VG9rZW5zLnRvdGFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXAgPSBzdGVwc1tzdGVwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgdG90YWxVc2FnZSA9IHN0ZXBzLnJlZHVjZShcbiAgICAgICAgICAodG90YWxVc2FnZTIsIHN0ZXApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBhZGRMYW5ndWFnZU1vZGVsVXNhZ2UodG90YWxVc2FnZTIsIHN0ZXAudXNhZ2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5wdXRUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIG91dHB1dFRva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgdG90YWxUb2tlbnM6IHZvaWQgMCxcbiAgICAgICAgICAgIHJlYXNvbmluZ1Rva2Vuczogdm9pZCAwLFxuICAgICAgICAgICAgY2FjaGVkSW5wdXRUb2tlbnM6IHZvaWQgMFxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgZmluaXNoUmVhc29uOiBsYXN0U3RlcC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBsYXN0U3RlcC5yYXdGaW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGxhc3RTdGVwLnVzYWdlLFxuICAgICAgICAgIGNvbnRlbnQ6IGxhc3RTdGVwLmNvbnRlbnQsXG4gICAgICAgICAgdGV4dDogbGFzdFN0ZXAudGV4dCxcbiAgICAgICAgICByZWFzb25pbmdUZXh0OiBsYXN0U3RlcC5yZWFzb25pbmdUZXh0LFxuICAgICAgICAgIHJlYXNvbmluZzogbGFzdFN0ZXAucmVhc29uaW5nLFxuICAgICAgICAgIGZpbGVzOiBsYXN0U3RlcC5maWxlcyxcbiAgICAgICAgICBzb3VyY2VzOiBsYXN0U3RlcC5zb3VyY2VzLFxuICAgICAgICAgIHRvb2xDYWxsczogbGFzdFN0ZXAudG9vbENhbGxzLFxuICAgICAgICAgIHN0YXRpY1Rvb2xDYWxsczogbGFzdFN0ZXAuc3RhdGljVG9vbENhbGxzLFxuICAgICAgICAgIGR5bmFtaWNUb29sQ2FsbHM6IGxhc3RTdGVwLmR5bmFtaWNUb29sQ2FsbHMsXG4gICAgICAgICAgdG9vbFJlc3VsdHM6IGxhc3RTdGVwLnRvb2xSZXN1bHRzLFxuICAgICAgICAgIHN0YXRpY1Rvb2xSZXN1bHRzOiBsYXN0U3RlcC5zdGF0aWNUb29sUmVzdWx0cyxcbiAgICAgICAgICBkeW5hbWljVG9vbFJlc3VsdHM6IGxhc3RTdGVwLmR5bmFtaWNUb29sUmVzdWx0cyxcbiAgICAgICAgICByZXF1ZXN0OiBsYXN0U3RlcC5yZXF1ZXN0LFxuICAgICAgICAgIHJlc3BvbnNlOiBsYXN0U3RlcC5yZXNwb25zZSxcbiAgICAgICAgICB3YXJuaW5nczogbGFzdFN0ZXAud2FybmluZ3MsXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbGFzdFN0ZXAucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICBzdGVwcyxcbiAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgIH0pKTtcbiAgICAgICAgbGV0IHJlc29sdmVkT3V0cHV0O1xuICAgICAgICBpZiAobGFzdFN0ZXAuZmluaXNoUmVhc29uID09PSBcInN0b3BcIikge1xuICAgICAgICAgIGNvbnN0IG91dHB1dFNwZWNpZmljYXRpb24gPSBvdXRwdXQgIT0gbnVsbCA/IG91dHB1dCA6IHRleHQoKTtcbiAgICAgICAgICByZXNvbHZlZE91dHB1dCA9IGF3YWl0IG91dHB1dFNwZWNpZmljYXRpb24ucGFyc2VDb21wbGV0ZU91dHB1dChcbiAgICAgICAgICAgIHsgdGV4dDogbGFzdFN0ZXAudGV4dCB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXNwb25zZTogbGFzdFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHVzYWdlOiBsYXN0U3RlcC51c2FnZSxcbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBsYXN0U3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCh7XG4gICAgICAgICAgc3RlcHMsXG4gICAgICAgICAgdG90YWxVc2FnZSxcbiAgICAgICAgICBvdXRwdXQ6IHJlc29sdmVkT3V0cHV0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IHdyYXBHYXRld2F5RXJyb3IoZXJyb3IpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgbWVzc2FnZXMsXG4gIGFib3J0U2lnbmFsLFxuICBleHBlcmltZW50YWxfY29udGV4dFxufSkge1xuICBjb25zdCB0b29sT3V0cHV0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoXG4gICAgICBhc3luYyAodG9vbENhbGwpID0+IGV4ZWN1dGVUb29sQ2FsbCh7XG4gICAgICAgIHRvb2xDYWxsLFxuICAgICAgICB0b29scyxcbiAgICAgICAgdHJhY2VyLFxuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgIH0pXG4gICAgKVxuICApO1xuICByZXR1cm4gdG9vbE91dHB1dHMuZmlsdGVyKFxuICAgIChvdXRwdXQpID0+IG91dHB1dCAhPSBudWxsXG4gICk7XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlVGV4dFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuc3RlcHMgPSBvcHRpb25zLnN0ZXBzO1xuICAgIHRoaXMuX291dHB1dCA9IG9wdGlvbnMub3V0cHV0O1xuICAgIHRoaXMudG90YWxVc2FnZSA9IG9wdGlvbnMudG90YWxVc2FnZTtcbiAgfVxuICBnZXQgZmluYWxTdGVwKCkge1xuICAgIHJldHVybiB0aGlzLnN0ZXBzW3RoaXMuc3RlcHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmNvbnRlbnQ7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRleHQ7XG4gIH1cbiAgZ2V0IGZpbGVzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5maWxlcztcbiAgfVxuICBnZXQgcmVhc29uaW5nVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucmVhc29uaW5nVGV4dDtcbiAgfVxuICBnZXQgcmVhc29uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZWFzb25pbmc7XG4gIH1cbiAgZ2V0IHRvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudG9vbENhbGxzO1xuICB9XG4gIGdldCBzdGF0aWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnN0YXRpY1Rvb2xDYWxscztcbiAgfVxuICBnZXQgZHluYW1pY1Rvb2xDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZHluYW1pY1Rvb2xDYWxscztcbiAgfVxuICBnZXQgdG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBzdGF0aWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuc3RhdGljVG9vbFJlc3VsdHM7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sUmVzdWx0cygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzO1xuICB9XG4gIGdldCBzb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5zb3VyY2VzO1xuICB9XG4gIGdldCBmaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLmZpbmlzaFJlYXNvbjtcbiAgfVxuICBnZXQgcmF3RmluaXNoUmVhc29uKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yYXdGaW5pc2hSZWFzb247XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC53YXJuaW5ncztcbiAgfVxuICBnZXQgcHJvdmlkZXJNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAucHJvdmlkZXJNZXRhZGF0YTtcbiAgfVxuICBnZXQgcmVzcG9uc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnJlc3BvbnNlO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC5yZXF1ZXN0O1xuICB9XG4gIGdldCB1c2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudXNhZ2U7XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9vdXRwdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0O1xuICB9XG4gIGdldCBvdXRwdXQoKSB7XG4gICAgaWYgKHRoaXMuX291dHB1dCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9PdXRwdXRHZW5lcmF0ZWRFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0O1xuICB9XG59O1xuZnVuY3Rpb24gYXNUb29sQ2FsbHMoY29udGVudCkge1xuICBjb25zdCBwYXJ0cyA9IGNvbnRlbnQuZmlsdGVyKFxuICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCJcbiAgKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLm1hcCgodG9vbENhbGwpID0+ICh7XG4gICAgdG9vbENhbGxJZDogdG9vbENhbGwudG9vbENhbGxJZCxcbiAgICB0b29sTmFtZTogdG9vbENhbGwudG9vbE5hbWUsXG4gICAgaW5wdXQ6IHRvb2xDYWxsLmlucHV0XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGFzQ29udGVudCh7XG4gIGNvbnRlbnQsXG4gIHRvb2xDYWxscyxcbiAgdG9vbE91dHB1dHMsXG4gIHRvb2xBcHByb3ZhbFJlcXVlc3RzLFxuICB0b29sc1xufSkge1xuICBjb25zdCBjb250ZW50UGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBwYXJ0IG9mIGNvbnRlbnQpIHtcbiAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgIGNhc2UgXCJyZWFzb25pbmdcIjpcbiAgICAgIGNhc2UgXCJzb3VyY2VcIjpcbiAgICAgICAgY29udGVudFBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgZmlsZTogbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHBhcnQpLFxuICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICBjb250ZW50UGFydHMucHVzaChcbiAgICAgICAgICB0b29sQ2FsbHMuZmluZCgodG9vbENhbGwpID0+IHRvb2xDYWxsLnRvb2xDYWxsSWQgPT09IHBhcnQudG9vbENhbGxJZClcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICh0b29sQ2FsbDIpID0+IHRvb2xDYWxsMi50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1twYXJ0LnRvb2xOYW1lXTtcbiAgICAgICAgICBjb25zdCBzdXBwb3J0c0RlZmVycmVkUmVzdWx0cyA9ICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwicHJvdmlkZXJcIiAmJiB0b29sMi5zdXBwb3J0c0RlZmVycmVkUmVzdWx0cztcbiAgICAgICAgICBpZiAoIXN1cHBvcnRzRGVmZXJyZWRSZXN1bHRzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRvb2wgY2FsbCAke3BhcnQudG9vbENhbGxJZH0gbm90IGZvdW5kLmApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFydC5pc0Vycm9yKSB7XG4gICAgICAgICAgICBjb250ZW50UGFydHMucHVzaCh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBlcnJvcjogcGFydC5yZXN1bHQsXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgIGR5bmFtaWM6IHBhcnQuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRlbnRQYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICBkeW5hbWljOiBwYXJ0LmR5bmFtaWNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC5pc0Vycm9yKSB7XG4gICAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sLWVycm9yXCIsXG4gICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgIGVycm9yOiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHRydWUsXG4gICAgICAgICAgICBkeW5hbWljOiB0b29sQ2FsbC5keW5hbWljXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICBpbnB1dDogdG9vbENhbGwuaW5wdXQsXG4gICAgICAgICAgICBvdXRwdXQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGR5bmFtaWM6IHRvb2xDYWxsLmR5bmFtaWNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIjoge1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHRvb2xDYWxscy5maW5kKFxuICAgICAgICAgICh0b29sQ2FsbDIpID0+IHRvb2xDYWxsMi50b29sQ2FsbElkID09PSBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHRvb2xDYWxsID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29udGVudFBhcnRzLnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgYXBwcm92YWxJZDogcGFydC5hcHByb3ZhbElkLFxuICAgICAgICAgIHRvb2xDYWxsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFsuLi5jb250ZW50UGFydHMsIC4uLnRvb2xPdXRwdXRzLCAuLi50b29sQXBwcm92YWxSZXF1ZXN0c107XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG5pbXBvcnQge1xuICBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlNyxcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBjcmVhdGVJZEdlbmVyYXRvciBhcyBjcmVhdGVJZEdlbmVyYXRvcjIsXG4gIERlbGF5ZWRQcm9taXNlLFxuICBpc0Fib3J0RXJyb3IgYXMgaXNBYm9ydEVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdXRpbC9wcmVwYXJlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVIZWFkZXJzKGhlYWRlcnMsIGRlZmF1bHRIZWFkZXJzKSB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IG5ldyBIZWFkZXJzKGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRlZmF1bHRIZWFkZXJzKSkge1xuICAgIGlmICghcmVzcG9uc2VIZWFkZXJzLmhhcyhrZXkpKSB7XG4gICAgICByZXNwb25zZUhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzcG9uc2VIZWFkZXJzO1xufVxuXG4vLyBzcmMvdGV4dC1zdHJlYW0vY3JlYXRlLXRleHQtc3RyZWFtLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHRleHRTdHJlYW1cbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZSh0ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgIHN0YXR1czogc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICBcImNvbnRlbnQtdHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgIH0pXG4gIH0pO1xufVxuXG4vLyBzcmMvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICBjb25zdCBzdGF0dXNDb2RlID0gc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDA7XG4gIGlmIChzdGF0dXNUZXh0ICE9PSB2b2lkIDApIHtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzQ29kZSwgc3RhdHVzVGV4dCwgaGVhZGVycyk7XG4gIH0gZWxzZSB7XG4gICAgcmVzcG9uc2Uud3JpdGVIZWFkKHN0YXR1c0NvZGUsIGhlYWRlcnMpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgY29uc3QgcmVhZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnN0IGNhbkNvbnRpbnVlID0gcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgICBpZiAoIWNhbkNvbnRpbnVlKSB7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUzKSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZS5vbmNlKFwiZHJhaW5cIiwgcmVzb2x2ZTMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gc3JjL3RleHQtc3RyZWFtL3BpcGUtdGV4dC1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHRleHRTdHJlYW1cbn0pIHtcbiAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICByZXNwb25zZSxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCB7XG4gICAgICAgIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KS5lbnRyaWVzKClcbiAgICApLFxuICAgIHN0cmVhbTogdGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgfSk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9qc29uLXRvLXNzZS10cmFuc2Zvcm0tc3RyZWFtLnRzXG52YXIgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtID0gY2xhc3MgZXh0ZW5kcyBUcmFuc2Zvcm1TdHJlYW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0cmFuc2Zvcm0ocGFydCwgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkocGFydCl9XG5cbmApO1xuICAgICAgfSxcbiAgICAgIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFwiZGF0YTogW0RPTkVdXFxuXFxuXCIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vdWktbWVzc2FnZS1zdHJlYW0taGVhZGVycy50c1xudmFyIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMgPSB7XG4gIFwiY29udGVudC10eXBlXCI6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgXCJjYWNoZS1jb250cm9sXCI6IFwibm8tY2FjaGVcIixcbiAgY29ubmVjdGlvbjogXCJrZWVwLWFsaXZlXCIsXG4gIFwieC12ZXJjZWwtYWktdWktbWVzc2FnZS1zdHJlYW1cIjogXCJ2MVwiLFxuICBcIngtYWNjZWwtYnVmZmVyaW5nXCI6IFwibm9cIlxuICAvLyBkaXNhYmxlIG5naW54IGJ1ZmZlcmluZ1xufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2NyZWF0ZS11aS1tZXNzYWdlLXN0cmVhbS1yZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbSxcbiAgY29uc3VtZVNzZVN0cmVhbVxufSkge1xuICBsZXQgc3NlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBKc29uVG9Tc2VUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIGlmIChjb25zdW1lU3NlU3RyZWFtKSB7XG4gICAgY29uc3QgW3N0cmVhbTEsIHN0cmVhbTJdID0gc3NlU3RyZWFtLnRlZSgpO1xuICAgIHNzZVN0cmVhbSA9IHN0cmVhbTE7XG4gICAgY29uc3VtZVNzZVN0cmVhbSh7IHN0cmVhbTogc3RyZWFtMiB9KTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKHNzZVN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBoZWFkZXJzOiBwcmVwYXJlSGVhZGVycyhoZWFkZXJzLCBVSV9NRVNTQUdFX1NUUkVBTV9IRUFERVJTKVxuICB9KTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2dldC1yZXNwb25zZS11aS1tZXNzYWdlLWlkLnRzXG5mdW5jdGlvbiBnZXRSZXNwb25zZVVJTWVzc2FnZUlkKHtcbiAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgcmVzcG9uc2VNZXNzYWdlSWRcbn0pIHtcbiAgaWYgKG9yaWdpbmFsTWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgbGFzdE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2VzW29yaWdpbmFsTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpID09PSBcImFzc2lzdGFudFwiID8gbGFzdE1lc3NhZ2UuaWQgOiB0eXBlb2YgcmVzcG9uc2VNZXNzYWdlSWQgPT09IFwiZnVuY3Rpb25cIiA/IHJlc3BvbnNlTWVzc2FnZUlkKCkgOiByZXNwb25zZU1lc3NhZ2VJZDtcbn1cblxuLy8gc3JjL3VpL3Byb2Nlc3MtdWktbWVzc2FnZS1zdHJlYW0udHNcbmltcG9ydCB7IHZhbGlkYXRlVHlwZXMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWktbWVzc2FnZS1zdHJlYW0vdWktbWVzc2FnZS1jaHVua3MudHNcbmltcG9ydCB7IHogYXMgejcgfSBmcm9tIFwiem9kL3Y0XCI7XG5pbXBvcnQgeyBsYXp5U2NoZW1hLCB6b2RTY2hlbWEgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIHVpTWVzc2FnZUNodW5rU2NoZW1hID0gbGF6eVNjaGVtYShcbiAgKCkgPT4gem9kU2NoZW1hKFxuICAgIHo3LnVuaW9uKFtcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0ZXh0LXN0YXJ0XCIpLFxuICAgICAgICBpZDogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidGV4dC1kZWx0YVwiKSxcbiAgICAgICAgaWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBkZWx0YTogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidGV4dC1lbmRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJlcnJvclwiKSxcbiAgICAgICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwidG9vbC1pbnB1dC1zdGFydFwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LWRlbHRhXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgaW5wdXRUZXh0RGVsdGE6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LWF2YWlsYWJsZVwiKSxcbiAgICAgICAgdG9vbENhbGxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHRvb2xOYW1lOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgaW5wdXQ6IHo3LnVua25vd24oKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgZHluYW1pYzogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLWlucHV0LWVycm9yXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdG9vbE5hbWU6IHo3LnN0cmluZygpLFxuICAgICAgICBpbnB1dDogejcudW5rbm93bigpLFxuICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICBkeW5hbWljOiB6Ny5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgdGl0bGU6IHo3LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiKSxcbiAgICAgICAgYXBwcm92YWxJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLW91dHB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBvdXRwdXQ6IHo3LnVua25vd24oKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICBwcmVsaW1pbmFyeTogejcuYm9vbGVhbigpLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInRvb2wtb3V0cHV0LWVycm9yXCIpLFxuICAgICAgICB0b29sQ2FsbElkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgZXJyb3JUZXh0OiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejcuYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgIGR5bmFtaWM6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJ0b29sLW91dHB1dC1kZW5pZWRcIiksXG4gICAgICAgIHRvb2xDYWxsSWQ6IHo3LnN0cmluZygpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmctc3RhcnRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJyZWFzb25pbmctZGVsdGFcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgZGVsdGE6IHo3LnN0cmluZygpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInJlYXNvbmluZy1lbmRcIiksXG4gICAgICAgIGlkOiB6Ny5zdHJpbmcoKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzb3VyY2UtdXJsXCIpLFxuICAgICAgICBzb3VyY2VJZDogejcuc3RyaW5nKCksXG4gICAgICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgICAgIHRpdGxlOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcInNvdXJjZS1kb2N1bWVudFwiKSxcbiAgICAgICAgc291cmNlSWQ6IHo3LnN0cmluZygpLFxuICAgICAgICBtZWRpYVR5cGU6IHo3LnN0cmluZygpLFxuICAgICAgICB0aXRsZTogejcuc3RyaW5nKCksXG4gICAgICAgIGZpbGVuYW1lOiB6Ny5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgIH0pLFxuICAgICAgejcuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgdHlwZTogejcubGl0ZXJhbChcImZpbGVcIiksXG4gICAgICAgIHVybDogejcuc3RyaW5nKCksXG4gICAgICAgIG1lZGlhVHlwZTogejcuc3RyaW5nKCksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5jdXN0b20oXG4gICAgICAgICAgKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3RhcnRzV2l0aChcImRhdGEtXCIpLFxuICAgICAgICAgIHsgbWVzc2FnZTogJ1R5cGUgbXVzdCBzdGFydCB3aXRoIFwiZGF0YS1cIicgfVxuICAgICAgICApLFxuICAgICAgICBpZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgZGF0YTogejcudW5rbm93bigpLFxuICAgICAgICB0cmFuc2llbnQ6IHo3LmJvb2xlYW4oKS5vcHRpb25hbCgpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJzdGFydC1zdGVwXCIpXG4gICAgICB9KSxcbiAgICAgIHo3LnN0cmljdE9iamVjdCh7XG4gICAgICAgIHR5cGU6IHo3LmxpdGVyYWwoXCJmaW5pc2gtc3RlcFwiKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwic3RhcnRcIiksXG4gICAgICAgIG1lc3NhZ2VJZDogejcuc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwiZmluaXNoXCIpLFxuICAgICAgICBmaW5pc2hSZWFzb246IHo3LmVudW0oW1xuICAgICAgICAgIFwic3RvcFwiLFxuICAgICAgICAgIFwibGVuZ3RoXCIsXG4gICAgICAgICAgXCJjb250ZW50LWZpbHRlclwiLFxuICAgICAgICAgIFwidG9vbC1jYWxsc1wiLFxuICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICBcIm90aGVyXCJcbiAgICAgICAgXSkub3B0aW9uYWwoKSxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwiYWJvcnRcIiksXG4gICAgICAgIHJlYXNvbjogejcuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgICAgfSksXG4gICAgICB6Ny5zdHJpY3RPYmplY3Qoe1xuICAgICAgICB0eXBlOiB6Ny5saXRlcmFsKFwibWVzc2FnZS1tZXRhZGF0YVwiKSxcbiAgICAgICAgbWVzc2FnZU1ldGFkYXRhOiB6Ny51bmtub3duKClcbiAgICAgIH0pXG4gICAgXSlcbiAgKVxuKTtcbmZ1bmN0aW9uIGlzRGF0YVVJTWVzc2FnZUNodW5rKGNodW5rKSB7XG4gIHJldHVybiBjaHVuay50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKTtcbn1cblxuLy8gc3JjL3VpL3VpLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiBpc0RhdGFVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKTtcbn1cbmZ1bmN0aW9uIGlzVGV4dFVJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiO1xufVxuZnVuY3Rpb24gaXNGaWxlVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQudHlwZSA9PT0gXCJmaWxlXCI7XG59XG5mdW5jdGlvbiBpc1JlYXNvbmluZ1VJUGFydChwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nXCI7XG59XG5mdW5jdGlvbiBpc1N0YXRpY1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKTtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pY1Rvb2xVSVBhcnQocGFydCkge1xuICByZXR1cm4gcGFydC50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiO1xufVxuZnVuY3Rpb24gaXNUb29sVUlQYXJ0KHBhcnQpIHtcbiAgcmV0dXJuIGlzU3RhdGljVG9vbFVJUGFydChwYXJ0KSB8fCBpc0R5bmFtaWNUb29sVUlQYXJ0KHBhcnQpO1xufVxudmFyIGlzVG9vbE9yRHluYW1pY1Rvb2xVSVBhcnQgPSBpc1Rvb2xVSVBhcnQ7XG5mdW5jdGlvbiBnZXRTdGF0aWNUb29sTmFtZShwYXJ0KSB7XG4gIHJldHVybiBwYXJ0LnR5cGUuc3BsaXQoXCItXCIpLnNsaWNlKDEpLmpvaW4oXCItXCIpO1xufVxuZnVuY3Rpb24gZ2V0VG9vbE5hbWUocGFydCkge1xuICByZXR1cm4gaXNEeW5hbWljVG9vbFVJUGFydChwYXJ0KSA/IHBhcnQudG9vbE5hbWUgOiBnZXRTdGF0aWNUb29sTmFtZShwYXJ0KTtcbn1cbnZhciBnZXRUb29sT3JEeW5hbWljVG9vbE5hbWUgPSBnZXRUb29sTmFtZTtcblxuLy8gc3JjL3VpL3Byb2Nlc3MtdWktbWVzc2FnZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWluZ1VJTWVzc2FnZVN0YXRlKHtcbiAgbGFzdE1lc3NhZ2UsXG4gIG1lc3NhZ2VJZFxufSkge1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2U6IChsYXN0TWVzc2FnZSA9PSBudWxsID8gdm9pZCAwIDogbGFzdE1lc3NhZ2Uucm9sZSkgPT09IFwiYXNzaXN0YW50XCIgPyBsYXN0TWVzc2FnZSA6IHtcbiAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICBtZXRhZGF0YTogdm9pZCAwLFxuICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgIHBhcnRzOiBbXVxuICAgIH0sXG4gICAgYWN0aXZlVGV4dFBhcnRzOiB7fSxcbiAgICBhY3RpdmVSZWFzb25pbmdQYXJ0czoge30sXG4gICAgcGFydGlhbFRvb2xDYWxsczoge31cbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgZGF0YVBhcnRTY2hlbWFzLFxuICBydW5VcGRhdGVNZXNzYWdlSm9iLFxuICBvbkVycm9yLFxuICBvblRvb2xDYWxsLFxuICBvbkRhdGFcbn0pIHtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBhd2FpdCBydW5VcGRhdGVNZXNzYWdlSm9iKGFzeW5jICh7IHN0YXRlLCB3cml0ZSB9KSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VG9vbEludm9jYXRpb24odG9vbENhbGxJZCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb25zID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maWx0ZXIoaXNUb29sVUlQYXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gdG9vbEludm9jYXRpb25zLmZpbmQoXG4gICAgICAgICAgICAgIChpbnZvY2F0aW9uKSA9PiBpbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbEludm9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJ0b29sLWludm9jYXRpb25cIixcbiAgICAgICAgICAgICAgICBjaHVua0lkOiB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBObyB0b29sIGludm9jYXRpb24gZm91bmQgZm9yIHRvb2wgY2FsbCBJRCBcIiR7dG9vbENhbGxJZH1cIi5gXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2xJbnZvY2F0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUb29sUGFydChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EyMjtcbiAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBzdGF0ZS5tZXNzYWdlLnBhcnRzLmZpbmQoXG4gICAgICAgICAgICAgIChwYXJ0MikgPT4gaXNTdGF0aWNUb29sVUlQYXJ0KHBhcnQyKSAmJiBwYXJ0Mi50b29sQ2FsbElkID09PSBvcHRpb25zLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBhbnlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGFueVBhcnQgPSBwYXJ0O1xuICAgICAgICAgICAgaWYgKHBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBwYXJ0LnN0YXRlID0gb3B0aW9ucy5zdGF0ZTtcbiAgICAgICAgICAgICAgYW55UGFydC5pbnB1dCA9IGFueU9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQub3V0cHV0ID0gYW55T3B0aW9ucy5vdXRwdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQuZXJyb3JUZXh0ID0gYW55T3B0aW9ucy5lcnJvclRleHQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucmF3SW5wdXQgPSBhbnlPcHRpb25zLnJhd0lucHV0O1xuICAgICAgICAgICAgICBhbnlQYXJ0LnByZWxpbWluYXJ5ID0gYW55T3B0aW9ucy5wcmVsaW1pbmFyeTtcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGFueVBhcnQudGl0bGUgPSBvcHRpb25zLnRpdGxlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFueVBhcnQucHJvdmlkZXJFeGVjdXRlZCA9IChfYTIyID0gYW55T3B0aW9ucy5wcm92aWRlckV4ZWN1dGVkKSAhPSBudWxsID8gX2EyMiA6IHBhcnQucHJvdmlkZXJFeGVjdXRlZDtcbiAgICAgICAgICAgICAgaWYgKGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSA9IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBgdG9vbC0ke29wdGlvbnMudG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBvcHRpb25zLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGFueU9wdGlvbnMuaW5wdXQsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBhbnlPcHRpb25zLm91dHB1dCxcbiAgICAgICAgICAgICAgICByYXdJbnB1dDogYW55T3B0aW9ucy5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvclRleHQ6IGFueU9wdGlvbnMuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGFueU9wdGlvbnMucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogYW55T3B0aW9ucy5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAuLi5hbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IGFueU9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUR5bmFtaWNUb29sUGFydChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgX2EyMiwgX2IyO1xuICAgICAgICAgICAgY29uc3QgcGFydCA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmluZChcbiAgICAgICAgICAgICAgKHBhcnQyKSA9PiBwYXJ0Mi50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiICYmIHBhcnQyLnRvb2xDYWxsSWQgPT09IG9wdGlvbnMudG9vbENhbGxJZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGFueU9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3QgYW55UGFydCA9IHBhcnQ7XG4gICAgICAgICAgICBpZiAocGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHBhcnQuc3RhdGUgPSBvcHRpb25zLnN0YXRlO1xuICAgICAgICAgICAgICBhbnlQYXJ0LnRvb2xOYW1lID0gb3B0aW9ucy50b29sTmFtZTtcbiAgICAgICAgICAgICAgYW55UGFydC5pbnB1dCA9IGFueU9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQub3V0cHV0ID0gYW55T3B0aW9ucy5vdXRwdXQ7XG4gICAgICAgICAgICAgIGFueVBhcnQuZXJyb3JUZXh0ID0gYW55T3B0aW9ucy5lcnJvclRleHQ7XG4gICAgICAgICAgICAgIGFueVBhcnQucmF3SW5wdXQgPSAoX2EyMiA9IGFueU9wdGlvbnMucmF3SW5wdXQpICE9IG51bGwgPyBfYTIyIDogYW55UGFydC5yYXdJbnB1dDtcbiAgICAgICAgICAgICAgYW55UGFydC5wcmVsaW1pbmFyeSA9IGFueU9wdGlvbnMucHJlbGltaW5hcnk7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zLnRpdGxlICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBhbnlQYXJ0LnRpdGxlID0gb3B0aW9ucy50aXRsZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhbnlQYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPSAoX2IyID0gYW55T3B0aW9ucy5wcm92aWRlckV4ZWN1dGVkKSAhPSBudWxsID8gX2IyIDogcGFydC5wcm92aWRlckV4ZWN1dGVkO1xuICAgICAgICAgICAgICBpZiAoYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhID0gYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZHluYW1pYy10b29sXCIsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IG9wdGlvbnMudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3B0aW9ucy50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBvcHRpb25zLnN0YXRlLFxuICAgICAgICAgICAgICAgIGlucHV0OiBhbnlPcHRpb25zLmlucHV0LFxuICAgICAgICAgICAgICAgIG91dHB1dDogYW55T3B0aW9ucy5vdXRwdXQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBhbnlPcHRpb25zLmVycm9yVGV4dCxcbiAgICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogYW55T3B0aW9ucy5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBhbnlPcHRpb25zLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgdGl0bGU6IG9wdGlvbnMudGl0bGUsXG4gICAgICAgICAgICAgICAgLi4uYW55T3B0aW9ucy5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IGNhbGxQcm92aWRlck1ldGFkYXRhOiBhbnlPcHRpb25zLnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhc3luYyBmdW5jdGlvbiB1cGRhdGVNZXNzYWdlTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1lcmdlZE1ldGFkYXRhID0gc3RhdGUubWVzc2FnZS5tZXRhZGF0YSAhPSBudWxsID8gbWVyZ2VPYmplY3RzKHN0YXRlLm1lc3NhZ2UubWV0YWRhdGEsIG1ldGFkYXRhKSA6IG1ldGFkYXRhO1xuICAgICAgICAgICAgICBpZiAobWVzc2FnZU1ldGFkYXRhU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBtZXJnZWRNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgIHNjaGVtYTogbWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogXCJtZXNzYWdlLm1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eUlkOiBzdGF0ZS5tZXNzYWdlLmlkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5tZXRhZGF0YSA9IG1lcmdlZE1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcInN0cmVhbWluZ1wiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHN0YXRlLmFjdGl2ZVRleHRQYXJ0c1tjaHVuay5pZF0gPSB0ZXh0UGFydDtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHRleHRQYXJ0KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRleHRQYXJ0ID0gc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgaWYgKHRleHRQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgIGNodW5rSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHRleHQtZGVsdGEgZm9yIG1pc3NpbmcgdGV4dCBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInRleHQtc3RhcnRcIiBjaHVuayBpcyBzZW50IGJlZm9yZSBhbnkgXCJ0ZXh0LWRlbHRhXCIgY2h1bmtzLmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0ZXh0UGFydC50ZXh0ICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICB0ZXh0UGFydC5wcm92aWRlck1ldGFkYXRhID0gKF9hMjEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRleHQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdGV4dFBhcnQgPSBzdGF0ZS5hY3RpdmVUZXh0UGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBpZiAodGV4dFBhcnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwidGV4dC1lbmRcIixcbiAgICAgICAgICAgICAgICAgIGNodW5rSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFJlY2VpdmVkIHRleHQtZW5kIGZvciBtaXNzaW5nIHRleHQgcGFydCB3aXRoIElEIFwiJHtjaHVuay5pZH1cIi4gRW5zdXJlIGEgXCJ0ZXh0LXN0YXJ0XCIgY2h1bmsgaXMgc2VudCBiZWZvcmUgYW55IFwidGV4dC1lbmRcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnN0YXRlID0gXCJkb25lXCI7XG4gICAgICAgICAgICAgIHRleHRQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2IgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2IgOiB0ZXh0UGFydC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlVGV4dFBhcnRzW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLXN0YXJ0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhc29uaW5nUGFydCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogXCJzdHJlYW1pbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF0gPSByZWFzb25pbmdQYXJ0O1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2gocmVhc29uaW5nUGFydCk7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlYXNvbmluZ1BhcnQgPSBzdGF0ZS5hY3RpdmVSZWFzb25pbmdQYXJ0c1tjaHVuay5pZF07XG4gICAgICAgICAgICAgIGlmIChyZWFzb25pbmdQYXJ0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVUlNZXNzYWdlU3RyZWFtRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgY2h1bmtUeXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsuaWQsXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVjZWl2ZWQgcmVhc29uaW5nLWRlbHRhIGZvciBtaXNzaW5nIHJlYXNvbmluZyBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInJlYXNvbmluZy1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInJlYXNvbmluZy1kZWx0YVwiIGNodW5rcy5gXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC50ZXh0ICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICByZWFzb25pbmdQYXJ0LnByb3ZpZGVyTWV0YWRhdGEgPSAoX2MgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2MgOiByZWFzb25pbmdQYXJ0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICBjb25zdCByZWFzb25pbmdQYXJ0ID0gc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nUGFydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVJTWVzc2FnZVN0cmVhbUVycm9yKHtcbiAgICAgICAgICAgICAgICAgIGNodW5rVHlwZTogXCJyZWFzb25pbmctZW5kXCIsXG4gICAgICAgICAgICAgICAgICBjaHVua0lkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCByZWFzb25pbmctZW5kIGZvciBtaXNzaW5nIHJlYXNvbmluZyBwYXJ0IHdpdGggSUQgXCIke2NodW5rLmlkfVwiLiBFbnN1cmUgYSBcInJlYXNvbmluZy1zdGFydFwiIGNodW5rIGlzIHNlbnQgYmVmb3JlIGFueSBcInJlYXNvbmluZy1lbmRcIiBjaHVua3MuYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YSA9IChfZCA9IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfZCA6IHJlYXNvbmluZ1BhcnQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgcmVhc29uaW5nUGFydC5zdGF0ZSA9IFwiZG9uZVwiO1xuICAgICAgICAgICAgICBkZWxldGUgc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydHNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgc3RhdGUubWVzc2FnZS5wYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IGNodW5rLm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICB1cmw6IGNodW5rLnVybFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlLXVybFwiOiB7XG4gICAgICAgICAgICAgIHN0YXRlLm1lc3NhZ2UucGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtdXJsXCIsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGNodW5rLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIHVybDogY2h1bmsudXJsLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzb3VyY2UtZG9jdW1lbnRcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic291cmNlLWRvY3VtZW50XCIsXG4gICAgICAgICAgICAgICAgc291cmNlSWQ6IGNodW5rLnNvdXJjZUlkLFxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogY2h1bmsubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIHRpdGxlOiBjaHVuay50aXRsZSxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogY2h1bmsuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1zdGFydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IHN0YXRlLm1lc3NhZ2UucGFydHMuZmlsdGVyKGlzU3RhdGljVG9vbFVJUGFydCk7XG4gICAgICAgICAgICAgIHN0YXRlLnBhcnRpYWxUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0gPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgaW5kZXg6IHRvb2xJbnZvY2F0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgZHluYW1pYzogY2h1bmsuZHluYW1pYyxcbiAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGUsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LXN0cmVhbWluZ1wiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHZvaWQgMCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGUsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxUb29sQ2FsbCA9IHN0YXRlLnBhcnRpYWxUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF07XG4gICAgICAgICAgICAgIGlmIChwYXJ0aWFsVG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVSU1lc3NhZ2VTdHJlYW1FcnJvcih7XG4gICAgICAgICAgICAgICAgICBjaHVua1R5cGU6IFwidG9vbC1pbnB1dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgY2h1bmtJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZWNlaXZlZCB0b29sLWlucHV0LWRlbHRhIGZvciBtaXNzaW5nIHRvb2wgY2FsbCB3aXRoIElEIFwiJHtjaHVuay50b29sQ2FsbElkfVwiLiBFbnN1cmUgYSBcInRvb2wtaW5wdXQtc3RhcnRcIiBjaHVuayBpcyBzZW50IGJlZm9yZSBhbnkgXCJ0b29sLWlucHV0LWRlbHRhXCIgY2h1bmtzLmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSBjaHVuay5pbnB1dFRleHREZWx0YTtcbiAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZTogcGFydGlhbEFyZ3MgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oXG4gICAgICAgICAgICAgICAgcGFydGlhbFRvb2xDYWxsLnRleHRcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbC5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogcGFydGlhbFRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiaW5wdXQtc3RyZWFtaW5nXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogcGFydGlhbEFyZ3MsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogcGFydGlhbFRvb2xDYWxsLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0aWFsVG9vbENhbGwudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1zdHJlYW1pbmdcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0aWFsQXJncyxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0aWFsVG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWF2YWlsYWJsZVwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJpbnB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBjaHVuay5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IGNodW5rLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBjaHVuay50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcImlucHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogY2h1bmsudGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICBpZiAob25Ub29sQ2FsbCAmJiAhY2h1bmsucHJvdmlkZXJFeGVjdXRlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uVG9vbENhbGwoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lcnJvclwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5keW5hbWljKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiBjaHVuay5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6IFwib3V0cHV0LWVycm9yXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgcmF3SW5wdXQ6IGNodW5rLmlucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0VG9vbEludm9jYXRpb24oY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uLnN0YXRlID0gXCJhcHByb3ZhbC1yZXF1ZXN0ZWRcIjtcbiAgICAgICAgICAgICAgdG9vbEludm9jYXRpb24uYXBwcm92YWwgPSB7IGlkOiBjaHVuay5hcHByb3ZhbElkIH07XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0VG9vbEludm9jYXRpb24oY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIHRvb2xJbnZvY2F0aW9uLnN0YXRlID0gXCJvdXRwdXQtZGVuaWVkXCI7XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9uID0gZ2V0VG9vbEludm9jYXRpb24oY2h1bmsudG9vbENhbGxJZCk7XG4gICAgICAgICAgICAgIGlmICh0b29sSW52b2NhdGlvbi50eXBlID09PSBcImR5bmFtaWMtdG9vbFwiKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlRHluYW1pY1Rvb2xQYXJ0KHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEludm9jYXRpb24udG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtYXZhaWxhYmxlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbEludm9jYXRpb24uaW5wdXQsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQ6IGNodW5rLm91dHB1dCxcbiAgICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBjaHVuay5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IGNodW5rLnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICB0aXRsZTogdG9vbEludm9jYXRpb24udGl0bGVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVUb29sUGFydCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFN0YXRpY1Rvb2xOYW1lKHRvb2xJbnZvY2F0aW9uKSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIG91dHB1dDogY2h1bmsub3V0cHV0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHByZWxpbWluYXJ5OiBjaHVuay5wcmVsaW1pbmFyeSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sSW52b2NhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEludm9jYXRpb24gPSBnZXRUb29sSW52b2NhdGlvbihjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9uLnR5cGUgPT09IFwiZHluYW1pYy10b29sXCIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEeW5hbWljVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiB0b29sSW52b2NhdGlvbi50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIm91dHB1dC1lcnJvclwiLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnZvY2F0aW9uLmlucHV0LFxuICAgICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBjaHVuay5lcnJvclRleHQsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBjaHVuay5wcm92aWRlckV4ZWN1dGVkLFxuICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2xJbnZvY2F0aW9uLnRpdGxlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlVG9vbFBhcnQoe1xuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBnZXRTdGF0aWNUb29sTmFtZSh0b29sSW52b2NhdGlvbiksXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogXCJvdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIGlucHV0OiB0b29sSW52b2NhdGlvbi5pbnB1dCxcbiAgICAgICAgICAgICAgICAgIHJhd0lucHV0OiB0b29sSW52b2NhdGlvbi5yYXdJbnB1dCxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogY2h1bmsuZXJyb3JUZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogY2h1bmsucHJvdmlkZXJFeGVjdXRlZCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiB0b29sSW52b2NhdGlvbi50aXRsZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInN0YXJ0LXN0ZXBcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goeyB0eXBlOiBcInN0ZXAtc3RhcnRcIiB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoLXN0ZXBcIjoge1xuICAgICAgICAgICAgICBzdGF0ZS5hY3RpdmVUZXh0UGFydHMgPSB7fTtcbiAgICAgICAgICAgICAgc3RhdGUuYWN0aXZlUmVhc29uaW5nUGFydHMgPSB7fTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRcIjoge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLmlkID0gY2h1bmsubWVzc2FnZUlkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZU1lc3NhZ2VNZXRhZGF0YShjaHVuay5tZXNzYWdlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICBpZiAoY2h1bmsubWVzc2FnZUlkICE9IG51bGwgfHwgY2h1bmsubWVzc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5maW5pc2hSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhd2FpdCB1cGRhdGVNZXNzYWdlTWV0YWRhdGEoY2h1bmsubWVzc2FnZU1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgd3JpdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgYXdhaXQgdXBkYXRlTWVzc2FnZU1ldGFkYXRhKGNodW5rLm1lc3NhZ2VNZXRhZGF0YSk7XG4gICAgICAgICAgICAgIGlmIChjaHVuay5tZXNzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHdyaXRlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICBvbkVycm9yID09IG51bGwgPyB2b2lkIDAgOiBvbkVycm9yKG5ldyBFcnJvcihjaHVuay5lcnJvclRleHQpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgIGlmIChpc0RhdGFVSU1lc3NhZ2VDaHVuayhjaHVuaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGRhdGFQYXJ0U2NoZW1hcyA9PSBudWxsID8gdm9pZCAwIDogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBwYXJ0SWR4ID0gc3RhdGUubWVzc2FnZS5wYXJ0cy5maW5kSW5kZXgoXG4gICAgICAgICAgICAgICAgICAgIChwKSA9PiBcImlkXCIgaW4gcCAmJiBcImRhdGFcIiBpbiBwICYmIHAuaWQgPT09IGNodW5rLmlkICYmIHAudHlwZSA9PT0gY2h1bmsudHlwZVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdHVhbFBhcnRJZHggPSBwYXJ0SWR4ID49IDAgPyBwYXJ0SWR4IDogc3RhdGUubWVzc2FnZS5wYXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogZGF0YVBhcnRTY2hlbWFzW2NodW5rLnR5cGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlLnBhcnRzWyR7YWN0dWFsUGFydElkeH1dLmRhdGFgLFxuICAgICAgICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IGNodW5rLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgZW50aXR5SWQ6IGNodW5rLmlkXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ2h1bmsgPSBjaHVuaztcbiAgICAgICAgICAgICAgICBpZiAoZGF0YUNodW5rLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgICAgb25EYXRhID09IG51bGwgPyB2b2lkIDAgOiBvbkRhdGEoZGF0YUNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1VJUGFydCA9IGRhdGFDaHVuay5pZCAhPSBudWxsID8gc3RhdGUubWVzc2FnZS5wYXJ0cy5maW5kKFxuICAgICAgICAgICAgICAgICAgKGNodW5rQXJnKSA9PiBkYXRhQ2h1bmsudHlwZSA9PT0gY2h1bmtBcmcudHlwZSAmJiBkYXRhQ2h1bmsuaWQgPT09IGNodW5rQXJnLmlkXG4gICAgICAgICAgICAgICAgKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdVSVBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZXhpc3RpbmdVSVBhcnQuZGF0YSA9IGRhdGFDaHVuay5kYXRhO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzdGF0ZS5tZXNzYWdlLnBhcnRzLnB1c2goZGF0YUNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25EYXRhID09IG51bGwgPyB2b2lkIDAgOiBvbkRhdGEoZGF0YUNodW5rKTtcbiAgICAgICAgICAgICAgICB3cml0ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS1tZXNzYWdlLXN0cmVhbS9oYW5kbGUtdWktbWVzc2FnZS1zdHJlYW0tZmluaXNoLnRzXG5mdW5jdGlvbiBoYW5kbGVVSU1lc3NhZ2VTdHJlYW1GaW5pc2goe1xuICBtZXNzYWdlSWQsXG4gIG9yaWdpbmFsTWVzc2FnZXMgPSBbXSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIHN0cmVhbVxufSkge1xuICBsZXQgbGFzdE1lc3NhZ2UgPSBvcmlnaW5hbE1lc3NhZ2VzID09IG51bGwgPyB2b2lkIDAgOiBvcmlnaW5hbE1lc3NhZ2VzW29yaWdpbmFsTWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIGlmICgobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLnJvbGUpICE9PSBcImFzc2lzdGFudFwiKSB7XG4gICAgbGFzdE1lc3NhZ2UgPSB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XG4gIH1cbiAgbGV0IGlzQWJvcnRlZCA9IGZhbHNlO1xuICBjb25zdCBpZEluamVjdGVkU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInN0YXJ0XCIpIHtcbiAgICAgICAgICBjb25zdCBzdGFydENodW5rID0gY2h1bms7XG4gICAgICAgICAgaWYgKHN0YXJ0Q2h1bmsubWVzc2FnZUlkID09IG51bGwgJiYgbWVzc2FnZUlkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXJ0Q2h1bmsubWVzc2FnZUlkID0gbWVzc2FnZUlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJhYm9ydFwiKSB7XG4gICAgICAgICAgaXNBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG4gIGlmIChvbkZpbmlzaCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkSW5qZWN0ZWRTdHJlYW07XG4gIH1cbiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdHJlYW1pbmdVSU1lc3NhZ2VTdGF0ZSh7XG4gICAgbGFzdE1lc3NhZ2U6IGxhc3RNZXNzYWdlID8gc3RydWN0dXJlZENsb25lKGxhc3RNZXNzYWdlKSA6IHZvaWQgMCxcbiAgICBtZXNzYWdlSWQ6IG1lc3NhZ2VJZCAhPSBudWxsID8gbWVzc2FnZUlkIDogXCJcIlxuICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3RyZWFtXG4gIH0pO1xuICBjb25zdCBydW5VcGRhdGVNZXNzYWdlSm9iID0gYXN5bmMgKGpvYikgPT4ge1xuICAgIGF3YWl0IGpvYih7IHN0YXRlLCB3cml0ZTogKCkgPT4ge1xuICAgIH0gfSk7XG4gIH07XG4gIGxldCBmaW5pc2hDYWxsZWQgPSBmYWxzZTtcbiAgY29uc3QgY2FsbE9uRmluaXNoID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChmaW5pc2hDYWxsZWQgfHwgIW9uRmluaXNoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpbmlzaENhbGxlZCA9IHRydWU7XG4gICAgY29uc3QgaXNDb250aW51YXRpb24gPSBzdGF0ZS5tZXNzYWdlLmlkID09PSAobGFzdE1lc3NhZ2UgPT0gbnVsbCA/IHZvaWQgMCA6IGxhc3RNZXNzYWdlLmlkKTtcbiAgICBhd2FpdCBvbkZpbmlzaCh7XG4gICAgICBpc0Fib3J0ZWQsXG4gICAgICBpc0NvbnRpbnVhdGlvbixcbiAgICAgIHJlc3BvbnNlTWVzc2FnZTogc3RhdGUubWVzc2FnZSxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIC4uLmlzQ29udGludWF0aW9uID8gb3JpZ2luYWxNZXNzYWdlcy5zbGljZSgwLCAtMSkgOiBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBzdGF0ZS5tZXNzYWdlXG4gICAgICBdLFxuICAgICAgZmluaXNoUmVhc29uOiBzdGF0ZS5maW5pc2hSZWFzb25cbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgIHN0cmVhbTogaWRJbmplY3RlZFN0cmVhbSxcbiAgICBydW5VcGRhdGVNZXNzYWdlSm9iLFxuICAgIG9uRXJyb3JcbiAgfSkucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH0sXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGNhbmNlbCBpcyBzdGlsbCBuZXcgYW5kIG1pc3NpbmcgZnJvbSB0eXBlcyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNmb3JtU3RyZWFtI2Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBhd2FpdCBjYWxsT25GaW5pc2goKTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBmbHVzaCgpIHtcbiAgICAgICAgYXdhaXQgY2FsbE9uRmluaXNoKCk7XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL3BpcGUtdWktbWVzc2FnZS1zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgaGVhZGVycyxcbiAgc3RyZWFtLFxuICBjb25zdW1lU3NlU3RyZWFtXG59KSB7XG4gIGxldCBzc2VTdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2gobmV3IEpzb25Ub1NzZVRyYW5zZm9ybVN0cmVhbSgpKTtcbiAgaWYgKGNvbnN1bWVTc2VTdHJlYW0pIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSBzc2VTdHJlYW0udGVlKCk7XG4gICAgc3NlU3RyZWFtID0gc3RyZWFtMTtcbiAgICBjb25zdW1lU3NlU3RyZWFtKHsgc3RyZWFtOiBzdHJlYW0yIH0pO1xuICB9XG4gIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgcHJlcGFyZUhlYWRlcnMoaGVhZGVycywgVUlfTUVTU0FHRV9TVFJFQU1fSEVBREVSUykuZW50cmllcygpXG4gICAgKSxcbiAgICBzdHJlYW06IHNzZVN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSlcbiAgfSk7XG59XG5cbi8vIHNyYy91dGlsL2FzeW5jLWl0ZXJhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShzb3VyY2UpIHtcbiAgY29uc3Qgc3RyZWFtID0gc291cmNlLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oKSk7XG4gIHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLmdldFJlYWRlcigpO1xuICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGNsZWFudXAoY2FuY2VsU3RyZWFtKSB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGlmIChmaW5pc2hlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNhbmNlbFN0cmVhbSkge1xuICAgICAgICAgIGF3YWl0ICgoX2EyMSA9IHJlYWRlci5jYW5jZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwocmVhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLyoqXG4gICAgICAgKiBSZWFkcyB0aGUgbmV4dCBjaHVuayBmcm9tIHRoZSBzdHJlYW0uXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBuZXh0IEl0ZXJhdG9yUmVzdWx0LlxuICAgICAgICovXG4gICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIE1heSBiZSBjYWxsZWQgb24gZWFybHkgZXhpdCAoZS5nLiwgYnJlYWsgZnJvbSBmb3ItYXdhaXQpIG9yIGFmdGVyIGNvbXBsZXRpb24uXG4gICAgICAgKiBFbnN1cmVzIHRoZSBzdHJlYW0gaXMgY2FuY2VsbGVkIGFuZCByZXNvdXJjZXMgYXJlIHJlbGVhc2VkLlxuICAgICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byBhIGNvbXBsZXRlZCBJdGVyYXRvclJlc3VsdC5cbiAgICAgICAqL1xuICAgICAgYXN5bmMgcmV0dXJuKCkge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH07XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsZWQgb24gZWFybHkgZXhpdCB3aXRoIGVycm9yLlxuICAgICAgICogRW5zdXJlcyB0aGUgc3RyZWFtIGlzIGNhbmNlbGxlZCBhbmQgcmVzb3VyY2VzIGFyZSByZWxlYXNlZCwgdGhlbiByZXRocm93cyB0aGUgZXJyb3IuXG4gICAgICAgKiBAcGFyYW0gZXJyIFRoZSBlcnJvciB0byB0aHJvdy5cbiAgICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlamVjdHMgd2l0aCB0aGUgcHJvdmlkZWQgZXJyb3IuXG4gICAgICAgKi9cbiAgICAgIGFzeW5jIHRocm93KGVycikge1xuICAgICAgICBhd2FpdCBjbGVhbnVwKHRydWUpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cblxuLy8gc3JjL3V0aWwvY29uc3VtZS1zdHJlYW0udHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uRXJyb3Jcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICB0cnkge1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb25zdCB7IGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIG9uRXJyb3IgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRXJyb3IoZXJyb3IpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICB9XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTM7XG4gIGxldCByZWplY3Q7XG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICByZXNvbHZlMyA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHByb21pc2UsXG4gICAgcmVzb2x2ZTogcmVzb2x2ZTMsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHNyYy91dGlsL2NyZWF0ZS1zdGl0Y2hhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpIHtcbiAgbGV0IGlubmVyU3RyZWFtUmVhZGVycyA9IFtdO1xuICBsZXQgY29udHJvbGxlciA9IG51bGw7XG4gIGxldCBpc0Nsb3NlZCA9IGZhbHNlO1xuICBsZXQgd2FpdEZvck5ld1N0cmVhbSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gIGNvbnN0IHRlcm1pbmF0ZSA9ICgpID0+IHtcbiAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgaW5uZXJTdHJlYW1SZWFkZXJzLmZvckVhY2goKHJlYWRlcikgPT4gcmVhZGVyLmNhbmNlbCgpKTtcbiAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gIH07XG4gIGNvbnN0IHByb2Nlc3NQdWxsID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGF3YWl0IHdhaXRGb3JOZXdTdHJlYW0ucHJvbWlzZTtcbiAgICAgIHJldHVybiBwcm9jZXNzUHVsbCgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaW5uZXJTdHJlYW1SZWFkZXJzWzBdLnJlYWQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgICBpZiAoaW5uZXJTdHJlYW1SZWFkZXJzLmxlbmd0aCA9PT0gMCAmJiBpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhd2FpdCBwcm9jZXNzUHVsbCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIGlubmVyU3RyZWFtUmVhZGVycy5zaGlmdCgpO1xuICAgICAgdGVybWluYXRlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIHN0cmVhbTogbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0KGNvbnRyb2xsZXJQYXJhbSkge1xuICAgICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IHByb2Nlc3NQdWxsLFxuICAgICAgYXN5bmMgY2FuY2VsKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiBpbm5lclN0cmVhbVJlYWRlcnMpIHtcbiAgICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzID0gW107XG4gICAgICAgIGlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICBhZGRTdHJlYW06IChpbm5lclN0cmVhbSkgPT4ge1xuICAgICAgaWYgKGlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhZGQgaW5uZXIgc3RyZWFtOiBvdXRlciBzdHJlYW0gaXMgY2xvc2VkXCIpO1xuICAgICAgfVxuICAgICAgaW5uZXJTdHJlYW1SZWFkZXJzLnB1c2goaW5uZXJTdHJlYW0uZ2V0UmVhZGVyKCkpO1xuICAgICAgd2FpdEZvck5ld1N0cmVhbS5yZXNvbHZlKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHcmFjZWZ1bGx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBsZXQgdGhlIGlubmVyIHN0cmVhbXNcbiAgICAgKiBmaW5pc2ggcHJvY2Vzc2luZyBhbmQgdGhlbiBjbG9zZSB0aGUgb3V0ZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGNsb3NlOiAoKSA9PiB7XG4gICAgICBpc0Nsb3NlZCA9IHRydWU7XG4gICAgICB3YWl0Rm9yTmV3U3RyZWFtLnJlc29sdmUoKTtcbiAgICAgIGlmIChpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNsb3NlIHRoZSBvdXRlciBzdHJlYW0uIFRoaXMgd2lsbCBjYW5jZWwgYWxsIGlubmVyIHN0cmVhbXNcbiAgICAgKiBhbmQgY2xvc2UgdGhlIG91dGVyIHN0cmVhbS5cbiAgICAgKi9cbiAgICB0ZXJtaW5hdGVcbiAgfTtcbn1cblxuLy8gc3JjL3V0aWwvbm93LnRzXG5mdW5jdGlvbiBub3coKSB7XG4gIHZhciBfYTIxLCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYTIxID0gZ2xvYmFsVGhpcyA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEubm93KCkpICE9IG51bGwgPyBfYiA6IERhdGUubm93KCk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3J1bi10b29scy10cmFuc2Zvcm1hdGlvbi50c1xuaW1wb3J0IHtcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZTZcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0cmFjZXIsXG4gIHRlbGVtZXRyeSxcbiAgc3lzdGVtLFxuICBtZXNzYWdlcyxcbiAgYWJvcnRTaWduYWwsXG4gIHJlcGFpclRvb2xDYWxsLFxuICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbn0pIHtcbiAgbGV0IHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIGNvbnN0IHRvb2xSZXN1bHRzU3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG91dHN0YW5kaW5nVG9vbFJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCB0b29sSW5wdXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgdG9vbENhbGxzQnlUb29sQ2FsbElkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbGV0IGNhbkNsb3NlID0gZmFsc2U7XG4gIGxldCBmaW5pc2hDaHVuayA9IHZvaWQgMDtcbiAgZnVuY3Rpb24gYXR0ZW1wdENsb3NlKCkge1xuICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLnNpemUgPT09IDApIHtcbiAgICAgIGlmIChmaW5pc2hDaHVuayAhPSBudWxsKSB7XG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKGZpbmlzaENodW5rKTtcbiAgICAgIH1cbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3J3YXJkU3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjaHVua1R5cGUgPSBjaHVuay50eXBlO1xuICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmVhbS1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidGV4dC1zdGFydFwiOlxuICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOlxuICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjpcbiAgICAgICAgY2FzZSBcInJlYXNvbmluZy1zdGFydFwiOlxuICAgICAgICBjYXNlIFwicmVhc29uaW5nLWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJyZWFzb25pbmctZW5kXCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LXN0YXJ0XCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWVuZFwiOlxuICAgICAgICBjYXNlIFwic291cmNlXCI6XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgY2FzZSBcInJhd1wiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmlsZVwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZmlsZTogbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlV2l0aFR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBjaHVuay5kYXRhLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IGNodW5rLm1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICBmaW5pc2hDaHVuayA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24ucmF3LFxuICAgICAgICAgICAgdXNhZ2U6IGFzTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGNodW5rLnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIjoge1xuICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gdG9vbENhbGxzQnlUb29sQ2FsbElkLmdldChjaHVuay50b29sQ2FsbElkKTtcbiAgICAgICAgICBpZiAodG9vbENhbGwgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgVG9vbENhbGxOb3RGb3VuZEZvckFwcHJvdmFsRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogY2h1bmsuYXBwcm92YWxJZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICBhcHByb3ZhbElkOiBjaHVuay5hcHByb3ZhbElkLFxuICAgICAgICAgICAgdG9vbENhbGxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGwgPSBhd2FpdCBwYXJzZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgdG9vbENhbGw6IGNodW5rLFxuICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgcmVwYWlyVG9vbENhbGwsXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdG9vbENhbGxzQnlUb29sQ2FsbElkLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB0b29sQ2FsbCk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodG9vbENhbGwpO1xuICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmludmFsaWQpIHtcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZ2V0RXJyb3JNZXNzYWdlNih0b29sQ2FsbC5lcnJvciksXG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTogdG9vbENhbGwudGl0bGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9vbDIub25JbnB1dEF2YWlsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXRBdmFpbGFibGUoe1xuICAgICAgICAgICAgICAgIGlucHV0OiB0b29sQ2FsbC5pbnB1dCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF3YWl0IGlzQXBwcm92YWxOZWVkZWQoe1xuICAgICAgICAgICAgICB0b29sOiB0b29sMixcbiAgICAgICAgICAgICAgdG9vbENhbGwsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgYXBwcm92YWxJZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b29sSW5wdXRzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB0b29sQ2FsbC5pbnB1dCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsICYmIHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5hZGQodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgZXhlY3V0ZVRvb2xDYWxsKHtcbiAgICAgICAgICAgICAgICB0b29sQ2FsbCxcbiAgICAgICAgICAgICAgICB0b29scyxcbiAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICAgIG9uUHJlbGltaW5hcnlUb29sUmVzdWx0OiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUocmVzdWx0KTtcbiAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJlcnJvclwiLCBlcnJvciB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgIGlmIChjaHVuay5pc0Vycm9yKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1lcnJvclwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnB1dHMuZ2V0KGNodW5rLnRvb2xDYWxsSWQpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICAgICAgICBlcnJvcjogY2h1bmsucmVzdWx0LFxuICAgICAgICAgICAgICBkeW5hbWljOiBjaHVuay5keW5hbWljXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay50b29sQ2FsbElkLFxuICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHRvb2xJbnB1dHMuZ2V0KGNodW5rLnRvb2xDYWxsSWQpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IGNodW5rLnJlc3VsdCxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZHluYW1pYzogY2h1bmsuZHluYW1pY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5oYW5kbGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2goKSB7XG4gICAgICBjYW5DbG9zZSA9IHRydWU7XG4gICAgICBhdHRlbXB0Q2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBnZW5lcmF0b3JTdHJlYW0ucGlwZVRocm91Z2goZm9yd2FyZFN0cmVhbSkucGlwZVRvKFxuICAgICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgICB3cml0ZShjaHVuaykge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIF0pO1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS10ZXh0L3N0cmVhbS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMiA9IGNyZWF0ZUlkR2VuZXJhdG9yMih7XG4gIHByZWZpeDogXCJhaXR4dFwiLFxuICBzaXplOiAyNFxufSk7XG5mdW5jdGlvbiBzdHJlYW1UZXh0KHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICB0b29sQ2hvaWNlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICB0aW1lb3V0LFxuICBoZWFkZXJzLFxuICBzdG9wV2hlbiA9IHN0ZXBDb3VudElzKDEpLFxuICBleHBlcmltZW50YWxfb3V0cHV0LFxuICBvdXRwdXQgPSBleHBlcmltZW50YWxfb3V0cHV0LFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIHByZXBhcmVTdGVwLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyxcbiAgYWN0aXZlVG9vbHMgPSBleHBlcmltZW50YWxfYWN0aXZlVG9vbHMsXG4gIGV4cGVyaW1lbnRhbF9yZXBhaXJUb29sQ2FsbDogcmVwYWlyVG9vbENhbGwsXG4gIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gIGluY2x1ZGVSYXdDaHVua3MgPSBmYWxzZSxcbiAgb25DaHVuayxcbiAgb25FcnJvciA9ICh7IGVycm9yIH0pID0+IHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfSxcbiAgb25GaW5pc2gsXG4gIG9uQWJvcnQsXG4gIG9uU3RlcEZpbmlzaCxcbiAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gIGV4cGVyaW1lbnRhbF9pbmNsdWRlOiBpbmNsdWRlLFxuICBfaW50ZXJuYWw6IHsgbm93OiBub3cyID0gbm93LCBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZDIgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBjb25zdCB0b3RhbFRpbWVvdXRNcyA9IGdldFRvdGFsVGltZW91dE1zKHRpbWVvdXQpO1xuICBjb25zdCBzdGVwVGltZW91dE1zID0gZ2V0U3RlcFRpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3QgY2h1bmtUaW1lb3V0TXMgPSBnZXRDaHVua1RpbWVvdXRNcyh0aW1lb3V0KTtcbiAgY29uc3Qgc3RlcEFib3J0Q29udHJvbGxlciA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IHZvaWQgMDtcbiAgY29uc3QgY2h1bmtBYm9ydENvbnRyb2xsZXIgPSBjaHVua1RpbWVvdXRNcyAhPSBudWxsID8gbmV3IEFib3J0Q29udHJvbGxlcigpIDogdm9pZCAwO1xuICByZXR1cm4gbmV3IERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICBtb2RlbDogcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWwpLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWw6IG1lcmdlQWJvcnRTaWduYWxzKFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICB0b3RhbFRpbWVvdXRNcyAhPSBudWxsID8gQWJvcnRTaWduYWwudGltZW91dCh0b3RhbFRpbWVvdXRNcykgOiB2b2lkIDAsXG4gICAgICBzdGVwQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBzdGVwQWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgIGNodW5rQWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjaHVua0Fib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICApLFxuICAgIHN0ZXBUaW1lb3V0TXMsXG4gICAgc3RlcEFib3J0Q29udHJvbGxlcixcbiAgICBjaHVua1RpbWVvdXRNcyxcbiAgICBjaHVua0Fib3J0Q29udHJvbGxlcixcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHRvb2xzLFxuICAgIHRvb2xDaG9pY2UsXG4gICAgdHJhbnNmb3JtczogYXNBcnJheSh0cmFuc2Zvcm0pLFxuICAgIGFjdGl2ZVRvb2xzLFxuICAgIHJlcGFpclRvb2xDYWxsLFxuICAgIHN0b3BDb25kaXRpb25zOiBhc0FycmF5KHN0b3BXaGVuKSxcbiAgICBvdXRwdXQsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHByZXBhcmVTdGVwLFxuICAgIGluY2x1ZGVSYXdDaHVua3MsXG4gICAgb25DaHVuayxcbiAgICBvbkVycm9yLFxuICAgIG9uRmluaXNoLFxuICAgIG9uQWJvcnQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIG5vdzogbm93MixcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyLFxuICAgIGluY2x1ZGVcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVPdXRwdXRUcmFuc2Zvcm1TdHJlYW0ob3V0cHV0KSB7XG4gIGxldCBmaXJzdFRleHRDaHVua0lkID0gdm9pZCAwO1xuICBsZXQgdGV4dDIgPSBcIlwiO1xuICBsZXQgdGV4dENodW5rID0gXCJcIjtcbiAgbGV0IHRleHRQcm92aWRlck1ldGFkYXRhID0gdm9pZCAwO1xuICBsZXQgbGFzdFB1Ymxpc2hlZEpzb24gPSBcIlwiO1xuICBmdW5jdGlvbiBwdWJsaXNoVGV4dENodW5rKHtcbiAgICBjb250cm9sbGVyLFxuICAgIHBhcnRpYWxPdXRwdXQgPSB2b2lkIDBcbiAgfSkge1xuICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICBwYXJ0OiB7XG4gICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICBpZDogZmlyc3RUZXh0Q2h1bmtJZCxcbiAgICAgICAgdGV4dDogdGV4dENodW5rLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiB0ZXh0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIHBhcnRpYWxPdXRwdXRcbiAgICB9KTtcbiAgICB0ZXh0Q2h1bmsgPSBcIlwiO1xuICB9XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTIxO1xuICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiZmluaXNoLXN0ZXBcIiAmJiB0ZXh0Q2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICBwdWJsaXNoVGV4dENodW5rKHsgY29udHJvbGxlciB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIiAmJiBjaHVuay50eXBlICE9PSBcInRleHQtc3RhcnRcIiAmJiBjaHVuay50eXBlICE9PSBcInRleHQtZW5kXCIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgcGFydDogY2h1bmssIHBhcnRpYWxPdXRwdXQ6IHZvaWQgMCB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGZpcnN0VGV4dENodW5rSWQgPT0gbnVsbCkge1xuICAgICAgICBmaXJzdFRleHRDaHVua0lkID0gY2h1bmsuaWQ7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rLmlkICE9PSBmaXJzdFRleHRDaHVua0lkKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtc3RhcnRcIikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyBwYXJ0OiBjaHVuaywgcGFydGlhbE91dHB1dDogdm9pZCAwIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiKSB7XG4gICAgICAgIGlmICh0ZXh0Q2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHB1Ymxpc2hUZXh0Q2h1bmsoeyBjb250cm9sbGVyIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHBhcnQ6IGNodW5rLCBwYXJ0aWFsT3V0cHV0OiB2b2lkIDAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRleHQyICs9IGNodW5rLnRleHQ7XG4gICAgICB0ZXh0Q2h1bmsgKz0gY2h1bmsudGV4dDtcbiAgICAgIHRleHRQcm92aWRlck1ldGFkYXRhID0gKF9hMjEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IHRleHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb3V0cHV0LnBhcnNlUGFydGlhbE91dHB1dCh7IHRleHQ6IHRleHQyIH0pO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRKc29uID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnBhcnRpYWwpO1xuICAgICAgICBpZiAoY3VycmVudEpzb24gIT09IGxhc3RQdWJsaXNoZWRKc29uKSB7XG4gICAgICAgICAgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIsIHBhcnRpYWxPdXRwdXQ6IHJlc3VsdC5wYXJ0aWFsIH0pO1xuICAgICAgICAgIGxhc3RQdWJsaXNoZWRKc29uID0gY3VycmVudEpzb247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRTdHJlYW1UZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBzdGVwVGltZW91dE1zLFxuICAgIHN0ZXBBYm9ydENvbnRyb2xsZXIsXG4gICAgY2h1bmtUaW1lb3V0TXMsXG4gICAgY2h1bmtBYm9ydENvbnRyb2xsZXIsXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICB0b29scyxcbiAgICB0b29sQ2hvaWNlLFxuICAgIHRyYW5zZm9ybXMsXG4gICAgYWN0aXZlVG9vbHMsXG4gICAgcmVwYWlyVG9vbENhbGwsXG4gICAgc3RvcENvbmRpdGlvbnMsXG4gICAgb3V0cHV0LFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICBwcmVwYXJlU3RlcCxcbiAgICBpbmNsdWRlUmF3Q2h1bmtzLFxuICAgIG5vdzogbm93MixcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICBvbkNodW5rLFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgb25BYm9ydCxcbiAgICBvblN0ZXBGaW5pc2gsXG4gICAgZXhwZXJpbWVudGFsX2NvbnRleHQsXG4gICAgZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBpbmNsdWRlXG4gIH0pIHtcbiAgICB0aGlzLl90b3RhbFVzYWdlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fZmluaXNoUmVhc29uID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fcmF3RmluaXNoUmVhc29uID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgdGhpcy5fc3RlcHMgPSBuZXcgRGVsYXllZFByb21pc2UoKTtcbiAgICB0aGlzLm91dHB1dFNwZWNpZmljYXRpb24gPSBvdXRwdXQ7XG4gICAgdGhpcy5pbmNsdWRlUmF3Q2h1bmtzID0gaW5jbHVkZVJhd0NodW5rcztcbiAgICB0aGlzLnRvb2xzID0gdG9vbHM7XG4gICAgbGV0IHN0ZXBGaW5pc2g7XG4gICAgbGV0IHJlY29yZGVkQ29udGVudCA9IFtdO1xuICAgIGNvbnN0IHJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgIGxldCByZWNvcmRlZEZpbmlzaFJlYXNvbiA9IHZvaWQgMDtcbiAgICBsZXQgcmVjb3JkZWRSYXdGaW5pc2hSZWFzb24gPSB2b2lkIDA7XG4gICAgbGV0IHJlY29yZGVkVG90YWxVc2FnZSA9IHZvaWQgMDtcbiAgICBsZXQgcmVjb3JkZWRSZXF1ZXN0ID0ge307XG4gICAgbGV0IHJlY29yZGVkV2FybmluZ3MgPSBbXTtcbiAgICBjb25zdCByZWNvcmRlZFN0ZXBzID0gW107XG4gICAgY29uc3QgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBsZXQgcm9vdFNwYW47XG4gICAgbGV0IGFjdGl2ZVRleHRDb250ZW50ID0ge307XG4gICAgbGV0IGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnQgPSB7fTtcbiAgICBjb25zdCBldmVudFByb2Nlc3NvciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHZhciBfYTIxLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBjb25zdCB7IHBhcnQgfSA9IGNodW5rO1xuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIiB8fCBwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nLWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInNvdXJjZVwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1pbnB1dC1zdGFydFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWlucHV0LWRlbHRhXCIgfHwgcGFydC50eXBlID09PSBcInJhd1wiKSB7XG4gICAgICAgICAgYXdhaXQgKG9uQ2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQ2h1bmsoeyBjaHVuazogcGFydCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgYXdhaXQgb25FcnJvcih7IGVycm9yOiB3cmFwR2F0ZXdheUVycm9yKHBhcnQuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidGV4dC1zdGFydFwiKSB7XG4gICAgICAgICAgYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF0gPSB7XG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGNvbnN0IGFjdGl2ZVRleHQgPSBhY3RpdmVUZXh0Q29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlVGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICBwYXJ0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgdGV4dCBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVUZXh0LnRleHQgKz0gcGFydC50ZXh0O1xuICAgICAgICAgIGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YSA9IChfYTIxID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IGFjdGl2ZVRleHQucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZW5kXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVUZXh0ID0gYWN0aXZlVGV4dENvbnRlbnRbcGFydC5pZF07XG4gICAgICAgICAgaWYgKGFjdGl2ZVRleHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHRleHQgcGFydCAke3BhcnQuaWR9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFydGlhbE91dHB1dDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlVGV4dC5wcm92aWRlck1ldGFkYXRhID0gKF9iID0gcGFydC5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2IgOiBhY3RpdmVUZXh0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgZGVsZXRlIGFjdGl2ZVRleHRDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nLXN0YXJ0XCIpIHtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdID0ge1xuICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmdcIixcbiAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKGFjdGl2ZVJlYXNvbmluZ0NvbnRlbnRbcGFydC5pZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nLWRlbHRhXCIpIHtcbiAgICAgICAgICBjb25zdCBhY3RpdmVSZWFzb25pbmcgPSBhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICAgIGlmIChhY3RpdmVSZWFzb25pbmcgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgcGFydDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBlcnJvcjogYHJlYXNvbmluZyBwYXJ0ICR7cGFydC5pZH0gbm90IGZvdW5kYFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwYXJ0aWFsT3V0cHV0OiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmcudGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2MgPSBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfYyA6IGFjdGl2ZVJlYXNvbmluZy5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwicmVhc29uaW5nLWVuZFwiKSB7XG4gICAgICAgICAgY29uc3QgYWN0aXZlUmVhc29uaW5nID0gYWN0aXZlUmVhc29uaW5nQ29udGVudFtwYXJ0LmlkXTtcbiAgICAgICAgICBpZiAoYWN0aXZlUmVhc29uaW5nID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHBhcnQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGByZWFzb25pbmcgcGFydCAke3BhcnQuaWR9IG5vdCBmb3VuZGBcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFydGlhbE91dHB1dDogdm9pZCAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWN0aXZlUmVhc29uaW5nLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2QgPSBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEpICE9IG51bGwgPyBfZCA6IGFjdGl2ZVJlYXNvbmluZy5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgIGRlbGV0ZSBhY3RpdmVSZWFzb25pbmdDb250ZW50W3BhcnQuaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2goeyB0eXBlOiBcImZpbGVcIiwgZmlsZTogcGFydC5maWxlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRvb2wtY2FsbFwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiICYmICFwYXJ0LnByZWxpbWluYXJ5KSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIikge1xuICAgICAgICAgIHJlY29yZGVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1lcnJvclwiKSB7XG4gICAgICAgICAgcmVjb3JkZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJzdGFydC1zdGVwXCIpIHtcbiAgICAgICAgICByZWNvcmRlZENvbnRlbnQgPSBbXTtcbiAgICAgICAgICBhY3RpdmVSZWFzb25pbmdDb250ZW50ID0ge307XG4gICAgICAgICAgYWN0aXZlVGV4dENvbnRlbnQgPSB7fTtcbiAgICAgICAgICByZWNvcmRlZFJlcXVlc3QgPSBwYXJ0LnJlcXVlc3Q7XG4gICAgICAgICAgcmVjb3JkZWRXYXJuaW5ncyA9IHBhcnQud2FybmluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnQudHlwZSA9PT0gXCJmaW5pc2gtc3RlcFwiKSB7XG4gICAgICAgICAgY29uc3Qgc3RlcE1lc3NhZ2VzID0gYXdhaXQgdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHJlY29yZGVkQ29udGVudCxcbiAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSBuZXcgRGVmYXVsdFN0ZXBSZXN1bHQoe1xuICAgICAgICAgICAgY29udGVudDogcmVjb3JkZWRDb250ZW50LFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBwYXJ0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHJhd0ZpbmlzaFJlYXNvbjogcGFydC5yYXdGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICB1c2FnZTogcGFydC51c2FnZSxcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZWNvcmRlZFdhcm5pbmdzLFxuICAgICAgICAgICAgcmVxdWVzdDogcmVjb3JkZWRSZXF1ZXN0LFxuICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgLi4ucGFydC5yZXNwb25zZSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5yZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMsIC4uLnN0ZXBNZXNzYWdlc11cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhd2FpdCAob25TdGVwRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvblN0ZXBGaW5pc2goY3VycmVudFN0ZXBSZXN1bHQpKTtcbiAgICAgICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgICAgICB3YXJuaW5nczogcmVjb3JkZWRXYXJuaW5ncyxcbiAgICAgICAgICAgIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVjb3JkZWRTdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgICByZWNvcmRlZFJlc3BvbnNlTWVzc2FnZXMucHVzaCguLi5zdGVwTWVzc2FnZXMpO1xuICAgICAgICAgIHN0ZXBGaW5pc2gucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwiZmluaXNoXCIpIHtcbiAgICAgICAgICByZWNvcmRlZFRvdGFsVXNhZ2UgPSBwYXJ0LnRvdGFsVXNhZ2U7XG4gICAgICAgICAgcmVjb3JkZWRGaW5pc2hSZWFzb24gPSBwYXJ0LmZpbmlzaFJlYXNvbjtcbiAgICAgICAgICByZWNvcmRlZFJhd0ZpbmlzaFJlYXNvbiA9IHBhcnQucmF3RmluaXNoUmVhc29uO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChyZWNvcmRlZFN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpID8gYWJvcnRTaWduYWwucmVhc29uIDogbmV3IE5vT3V0cHV0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG91dHB1dCBnZW5lcmF0ZWQuIENoZWNrIHRoZSBzdHJlYW0gZm9yIGVycm9ycy5cIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLl9maW5pc2hSZWFzb24ucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHNlbGYuX3Jhd0ZpbmlzaFJlYXNvbi5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fdG90YWxVc2FnZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc2VsZi5fc3RlcHMucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmluaXNoUmVhc29uID0gcmVjb3JkZWRGaW5pc2hSZWFzb24gIT0gbnVsbCA/IHJlY29yZGVkRmluaXNoUmVhc29uIDogXCJvdGhlclwiO1xuICAgICAgICAgIGNvbnN0IHRvdGFsVXNhZ2UgPSByZWNvcmRlZFRvdGFsVXNhZ2UgIT0gbnVsbCA/IHJlY29yZGVkVG90YWxVc2FnZSA6IGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKTtcbiAgICAgICAgICBzZWxmLl9maW5pc2hSZWFzb24ucmVzb2x2ZShmaW5pc2hSZWFzb24pO1xuICAgICAgICAgIHNlbGYuX3Jhd0ZpbmlzaFJlYXNvbi5yZXNvbHZlKHJlY29yZGVkUmF3RmluaXNoUmVhc29uKTtcbiAgICAgICAgICBzZWxmLl90b3RhbFVzYWdlLnJlc29sdmUodG90YWxVc2FnZSk7XG4gICAgICAgICAgc2VsZi5fc3RlcHMucmVzb2x2ZShyZWNvcmRlZFN0ZXBzKTtcbiAgICAgICAgICBjb25zdCBmaW5hbFN0ZXAgPSByZWNvcmRlZFN0ZXBzW3JlY29yZGVkU3RlcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgYXdhaXQgKG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7XG4gICAgICAgICAgICBmaW5pc2hSZWFzb246IGZpbmFsU3RlcC5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICByYXdGaW5pc2hSZWFzb246IGZpbmFsU3RlcC5yYXdGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICB0b3RhbFVzYWdlLFxuICAgICAgICAgICAgdXNhZ2U6IGZpbmFsU3RlcC51c2FnZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGZpbmFsU3RlcC5jb250ZW50LFxuICAgICAgICAgICAgdGV4dDogZmluYWxTdGVwLnRleHQsXG4gICAgICAgICAgICByZWFzb25pbmdUZXh0OiBmaW5hbFN0ZXAucmVhc29uaW5nVGV4dCxcbiAgICAgICAgICAgIHJlYXNvbmluZzogZmluYWxTdGVwLnJlYXNvbmluZyxcbiAgICAgICAgICAgIGZpbGVzOiBmaW5hbFN0ZXAuZmlsZXMsXG4gICAgICAgICAgICBzb3VyY2VzOiBmaW5hbFN0ZXAuc291cmNlcyxcbiAgICAgICAgICAgIHRvb2xDYWxsczogZmluYWxTdGVwLnRvb2xDYWxscyxcbiAgICAgICAgICAgIHN0YXRpY1Rvb2xDYWxsczogZmluYWxTdGVwLnN0YXRpY1Rvb2xDYWxscyxcbiAgICAgICAgICAgIGR5bmFtaWNUb29sQ2FsbHM6IGZpbmFsU3RlcC5keW5hbWljVG9vbENhbGxzLFxuICAgICAgICAgICAgdG9vbFJlc3VsdHM6IGZpbmFsU3RlcC50b29sUmVzdWx0cyxcbiAgICAgICAgICAgIHN0YXRpY1Rvb2xSZXN1bHRzOiBmaW5hbFN0ZXAuc3RhdGljVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICBkeW5hbWljVG9vbFJlc3VsdHM6IGZpbmFsU3RlcC5keW5hbWljVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICByZXF1ZXN0OiBmaW5hbFN0ZXAucmVxdWVzdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiBmaW5hbFN0ZXAucmVzcG9uc2UsXG4gICAgICAgICAgICB3YXJuaW5nczogZmluYWxTdGVwLndhcm5pbmdzLFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZmluYWxTdGVwLnByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwcyxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJvb3RTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gZmluYWxTdGVwLnRleHQgfSxcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMjE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKF9hMjEgPSBmaW5hbFN0ZXAudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5sZW5ndGgpID8gSlNPTi5zdHJpbmdpZnkoZmluYWxTdGVwLnRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBmaW5hbFN0ZXAucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiB0b3RhbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2Uub3V0cHV0VG9rZW5zXCI6IHRvdGFsVXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG90YWxUb2tlbnNcIjogdG90YWxVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiB0b3RhbFVzYWdlLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNhY2hlZElucHV0VG9rZW5zXCI6IHRvdGFsVXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJvb3RTcGFuLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RpdGNoYWJsZVN0cmVhbSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLmFkZFN0cmVhbSA9IHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtO1xuICAgIHRoaXMuY2xvc2VTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLmNsb3NlO1xuICAgIGNvbnN0IHJlYWRlciA9IHN0aXRjaGFibGVTdHJlYW0uc3RyZWFtLmdldFJlYWRlcigpO1xuICAgIGxldCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInN0YXJ0XCIgfSk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgICAgIG9uQWJvcnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uQWJvcnQoeyBzdGVwczogcmVjb3JkZWRTdGVwcyB9KTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJhYm9ydFwiLFxuICAgICAgICAgICAgLy8gVGhlIGByZWFzb25gIGlzIHVzdWFsbHkgb2YgdHlwZSBET01FeGNlcHRpb24sIGJ1dCBpdCBjYW4gYWxzbyBiZSBvZiBhbnkgdHlwZSxcbiAgICAgICAgICAgIC8vIHNvIHdlIHVzZSBnZXRFcnJvck1lc3NhZ2UgZm9yIHNlcmlhbGl6YXRpb24gYmVjYXVzZSBpdCBpcyBhbHJlYWR5IGRlc2lnbmVkIHRvIGFjY2VwdCB2YWx1ZXMgb2YgdGhlIHVua25vd24gdHlwZS5cbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Fib3J0U2lnbmFsL3JlYXNvblxuICAgICAgICAgICAgLi4uKGFib3J0U2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5yZWFzb24pICE9PSB2b2lkIDAgPyB7IHJlYXNvbjogZ2V0RXJyb3JNZXNzYWdlNyhhYm9ydFNpZ25hbC5yZWFzb24pIH0gOiB7fVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFib3J0U2lnbmFsID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGlmIChpc0Fib3J0RXJyb3IyKGVycm9yKSAmJiAoYWJvcnRTaWduYWwgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5jYW5jZWwocmVhc29uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zZm9ybSBvZiB0cmFuc2Zvcm1zKSB7XG4gICAgICBzdHJlYW0gPSBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIHRyYW5zZm9ybSh7XG4gICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgc3RvcFN0cmVhbSgpIHtcbiAgICAgICAgICAgIHN0aXRjaGFibGVTdHJlYW0udGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZU91dHB1dFRyYW5zZm9ybVN0cmVhbShvdXRwdXQgIT0gbnVsbCA/IG91dHB1dCA6IHRleHQoKSkpLnBpcGVUaHJvdWdoKGV2ZW50UHJvY2Vzc29yKTtcbiAgICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICAgICAgYWJvcnRTaWduYWxcbiAgICB9KTtcbiAgICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIG1vZGVsLFxuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLnN0cmVhbVRleHRcIixcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1UZXh0XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgXCJhaS5wcm9tcHRcIjoge1xuICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRyYWNlcixcbiAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgIGZuOiBhc3luYyAocm9vdFNwYW5BcmcpID0+IHtcbiAgICAgICAgcm9vdFNwYW4gPSByb290U3BhbkFyZztcbiAgICAgICAgY29uc3QgaW5pdGlhbFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBpbml0aWFsTWVzc2FnZXMgPSBpbml0aWFsUHJvbXB0Lm1lc3NhZ2VzO1xuICAgICAgICBjb25zdCBpbml0aWFsUmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICAgICAgICBjb25zdCB7IGFwcHJvdmVkVG9vbEFwcHJvdmFscywgZGVuaWVkVG9vbEFwcHJvdmFscyB9ID0gY29sbGVjdFRvb2xBcHByb3ZhbHMoeyBtZXNzYWdlczogaW5pdGlhbE1lc3NhZ2VzIH0pO1xuICAgICAgICBpZiAoZGVuaWVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwIHx8IGFwcHJvdmVkVG9vbEFwcHJvdmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMgPSBbXG4gICAgICAgICAgICAuLi5hcHByb3ZlZFRvb2xBcHByb3ZhbHMsXG4gICAgICAgICAgICAuLi5kZW5pZWRUb29sQXBwcm92YWxzXG4gICAgICAgICAgXS5maWx0ZXIoKHRvb2xBcHByb3ZhbCkgPT4gdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQpO1xuICAgICAgICAgIGNvbnN0IGxvY2FsQXBwcm92ZWRUb29sQXBwcm92YWxzID0gYXBwcm92ZWRUb29sQXBwcm92YWxzLmZpbHRlcihcbiAgICAgICAgICAgICh0b29sQXBwcm92YWwpID0+ICF0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgbG9jYWxEZW5pZWRUb29sQXBwcm92YWxzID0gZGVuaWVkVG9vbEFwcHJvdmFscy5maWx0ZXIoXG4gICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiAhdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnN0IGRlbmllZFByb3ZpZGVyRXhlY3V0ZWRUb29sQXBwcm92YWxzID0gZGVuaWVkVG9vbEFwcHJvdmFscy5maWx0ZXIoXG4gICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiB0b29sQXBwcm92YWwudG9vbENhbGwucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICk7XG4gICAgICAgICAgbGV0IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgICBjb25zdCB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5hZGRTdHJlYW0odG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW0pO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xBcHByb3ZhbCBvZiBbXG4gICAgICAgICAgICAgIC4uLmxvY2FsRGVuaWVkVG9vbEFwcHJvdmFscyxcbiAgICAgICAgICAgICAgLi4uZGVuaWVkUHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHNcbiAgICAgICAgICAgIF0pIHtcbiAgICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sQXBwcm92YWwudG9vbENhbGwudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xOYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgICAgICBsb2NhbEFwcHJvdmVkVG9vbEFwcHJvdmFscy5tYXAoYXN5bmMgKHRvb2xBcHByb3ZhbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVUb29sQ2FsbCh7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbDogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLFxuICAgICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlczogaW5pdGlhbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dCxcbiAgICAgICAgICAgICAgICAgIG9uUHJlbGltaW5hcnlUb29sUmVzdWx0OiAocmVzdWx0MikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdDIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiB0b29sRXhlY3V0aW9uU3RlcFN0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgdG9vbE91dHB1dHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAocHJvdmlkZXJFeGVjdXRlZFRvb2xBcHByb3ZhbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBpbml0aWFsUmVzcG9uc2VNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInRvb2xcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBwcm92aWRlckV4ZWN1dGVkVG9vbEFwcHJvdmFscy5tYXAoXG4gICAgICAgICAgICAgICAgICAodG9vbEFwcHJvdmFsKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgYXBwcm92YWxJZDogdG9vbEFwcHJvdmFsLmFwcHJvdmFsUmVzcG9uc2UuYXBwcm92YWxJZCxcbiAgICAgICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLmFwcHJvdmVkLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvb2xPdXRwdXRzLmxlbmd0aCA+IDAgfHwgbG9jYWxEZW5pZWRUb29sQXBwcm92YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgY29uc3QgbG9jYWxUb29sQ29udGVudCA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dDIgb2YgdG9vbE91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFRvb2xDb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogb3V0cHV0Mi50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IG91dHB1dDIudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICBvdXRwdXQ6IGF3YWl0IGNyZWF0ZVRvb2xNb2RlbE91dHB1dCh7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IG91dHB1dDIudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG91dHB1dDIuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2w6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1tvdXRwdXQyLnRvb2xOYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IG91dHB1dDIub3V0cHV0IDogb3V0cHV0Mi5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNb2RlOiBvdXRwdXQyLnR5cGUgPT09IFwidG9vbC1lcnJvclwiID8gXCJqc29uXCIgOiBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xBcHByb3ZhbCBvZiBsb2NhbERlbmllZFRvb2xBcHByb3ZhbHMpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFRvb2xDb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICB0b29sTmFtZTogdG9vbEFwcHJvdmFsLnRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgb3V0cHV0OiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXhlY3V0aW9uLWRlbmllZFwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IHRvb2xBcHByb3ZhbC5hcHByb3ZhbFJlc3BvbnNlLnJlYXNvblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxvY2FsVG9vbENvbnRlbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRvb2xFeGVjdXRpb25TdGVwU3RyZWFtQ29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogdG9vbEV4ZWN1dGlvblN0ZXBTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlY29yZGVkUmVzcG9uc2VNZXNzYWdlcy5wdXNoKC4uLmluaXRpYWxSZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgYXN5bmMgZnVuY3Rpb24gc3RyZWFtU3RlcCh7XG4gICAgICAgICAgY3VycmVudFN0ZXAsXG4gICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcyxcbiAgICAgICAgICB1c2FnZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgY29uc3QgaW5jbHVkZVJhd0NodW5rczIgPSBzZWxmLmluY2x1ZGVSYXdDaHVua3M7XG4gICAgICAgICAgY29uc3Qgc3RlcFRpbWVvdXRJZCA9IHN0ZXBUaW1lb3V0TXMgIT0gbnVsbCA/IHNldFRpbWVvdXQoKCkgPT4gc3RlcEFib3J0Q29udHJvbGxlci5hYm9ydCgpLCBzdGVwVGltZW91dE1zKSA6IHZvaWQgMDtcbiAgICAgICAgICBsZXQgY2h1bmtUaW1lb3V0SWQgPSB2b2lkIDA7XG4gICAgICAgICAgZnVuY3Rpb24gcmVzZXRDaHVua1RpbWVvdXQoKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtUaW1lb3V0TXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoY2h1bmtUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChjaHVua1RpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2h1bmtUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgICAgICgpID0+IGNodW5rQWJvcnRDb250cm9sbGVyLmFib3J0KCksXG4gICAgICAgICAgICAgICAgY2h1bmtUaW1lb3V0TXNcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2xlYXJDaHVua1RpbWVvdXQoKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmtUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoY2h1bmtUaW1lb3V0SWQpO1xuICAgICAgICAgICAgICBjaHVua1RpbWVvdXRJZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2xlYXJTdGVwVGltZW91dCgpIHtcbiAgICAgICAgICAgIGlmIChzdGVwVGltZW91dElkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0ZXBUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RlcEZpbmlzaCA9IG5ldyBEZWxheWVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgY29uc3Qgc3RlcElucHV0TWVzc2FnZXMgPSBbLi4uaW5pdGlhbE1lc3NhZ2VzLCAuLi5yZXNwb25zZU1lc3NhZ2VzXTtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVTdGVwUmVzdWx0ID0gYXdhaXQgKHByZXBhcmVTdGVwID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcCh7XG4gICAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICAgICAgICBzdGVwczogcmVjb3JkZWRTdGVwcyxcbiAgICAgICAgICAgICAgc3RlcE51bWJlcjogcmVjb3JkZWRTdGVwcy5sZW5ndGgsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBNb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKFxuICAgICAgICAgICAgICAoX2EyMSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tb2RlbCkgIT0gbnVsbCA/IF9hMjEgOiBtb2RlbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICAgIHN5c3RlbTogKF9iID0gcHJlcGFyZVN0ZXBSZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVTdGVwUmVzdWx0LnN5c3RlbSkgIT0gbnVsbCA/IF9iIDogaW5pdGlhbFByb21wdC5zeXN0ZW0sXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IChfYyA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5tZXNzYWdlcykgIT0gbnVsbCA/IF9jIDogc3RlcElucHV0TWVzc2FnZXNcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgc3RlcE1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2hvaWNlOiBzdGVwVG9vbENob2ljZSwgdG9vbHM6IHN0ZXBUb29scyB9ID0gYXdhaXQgcHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7XG4gICAgICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgICAgICB0b29sQ2hvaWNlOiAoX2QgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQudG9vbENob2ljZSkgIT0gbnVsbCA/IF9kIDogdG9vbENob2ljZSxcbiAgICAgICAgICAgICAgYWN0aXZlVG9vbHM6IChfZSA9IHByZXBhcmVTdGVwUmVzdWx0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlU3RlcFJlc3VsdC5hY3RpdmVUb29scykgIT0gbnVsbCA/IF9lIDogYWN0aXZlVG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHQgPSAoX2YgPSBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQuZXhwZXJpbWVudGFsX2NvbnRleHQpICE9IG51bGwgPyBfZiA6IGV4cGVyaW1lbnRhbF9jb250ZXh0O1xuICAgICAgICAgICAgY29uc3Qgc3RlcFByb3ZpZGVyT3B0aW9ucyA9IG1lcmdlT2JqZWN0cyhcbiAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBwcmVwYXJlU3RlcFJlc3VsdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZVN0ZXBSZXN1bHQucHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICByZXN1bHQ6IHsgc3RyZWFtOiBzdHJlYW0yLCByZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgICAgICAgIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICAgKCkgPT4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtVGV4dC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIG1vZGVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLm1vZGVsLnByb3ZpZGVyXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5tb2RlbC5pZFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgLy8gcHJvbXB0OlxuICAgICAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0cmluZ2lmeUZvclRlbGVtZXRyeShwcm9tcHRNZXNzYWdlcylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIGxhbmd1YWdlIG1vZGVsIGxldmVsIHRvb2xzOlxuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IHN0ZXBUb29scy5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LnRvb2xDaG9pY2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBzdGVwVG9vbENob2ljZSAhPSBudWxsID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IHN0ZXBNb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBzdGVwTW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnN0b3Bfc2VxdWVuY2VzXCI6IGNhbGxTZXR0aW5ncy5zdG9wU2VxdWVuY2VzLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBjYWxsU2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBzdGVwTW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiBzdGVwVG9vbHMsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xDaG9pY2U6IHN0ZXBUb29sQ2hvaWNlLFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUZvcm1hdDogYXdhaXQgKG91dHB1dCA9PSBudWxsID8gdm9pZCAwIDogb3V0cHV0LnJlc3BvbnNlRm9ybWF0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvbXB0OiBwcm9tcHRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBzdGVwUHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZVJhd0NodW5rczogaW5jbHVkZVJhd0NodW5rczJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBzdHJlYW1XaXRoVG9vbFJlc3VsdHMgPSBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICAgICAgbWVzc2FnZXM6IHN0ZXBJbnB1dE1lc3NhZ2VzLFxuICAgICAgICAgICAgICByZXBhaXJUb29sQ2FsbCxcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9jb250ZXh0LFxuICAgICAgICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzdGVwUmVxdWVzdCA9ICgoX2cgPSBpbmNsdWRlID09IG51bGwgPyB2b2lkIDAgOiBpbmNsdWRlLnJlcXVlc3RCb2R5KSAhPSBudWxsID8gX2cgOiB0cnVlKSA/IHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fSA6IHsgLi4ucmVxdWVzdCwgYm9keTogdm9pZCAwIH07XG4gICAgICAgICAgICBjb25zdCBzdGVwVG9vbENhbGxzID0gW107XG4gICAgICAgICAgICBjb25zdCBzdGVwVG9vbE91dHB1dHMgPSBbXTtcbiAgICAgICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVRvb2xDYWxsVG9vbE5hbWVzID0ge307XG4gICAgICAgICAgICBsZXQgc3RlcEZpbmlzaFJlYXNvbiA9IFwib3RoZXJcIjtcbiAgICAgICAgICAgIGxldCBzdGVwUmF3RmluaXNoUmVhc29uID0gdm9pZCAwO1xuICAgICAgICAgICAgbGV0IHN0ZXBVc2FnZSA9IGNyZWF0ZU51bGxMYW5ndWFnZU1vZGVsVXNhZ2UoKTtcbiAgICAgICAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBhY3RpdmVUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHNlbGYuYWRkU3RyZWFtKFxuICAgICAgICAgICAgICBzdHJlYW1XaXRoVG9vbFJlc3VsdHMucGlwZVRocm91Z2goXG4gICAgICAgICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hMjIsIF9iMiwgX2MyLCBfZDIsIF9lMjtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXRDaHVua1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwic3RyZWFtLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5ncyA9IGNodW5rLndhcm5pbmdzO1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcEZpcnN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtc1RvRmlyc3RDaHVuayA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wTXM7XG4gICAgICAgICAgICAgICAgICAgICAgc3RlcEZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0YXJ0LXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IHdhcm5pbmdzICE9IG51bGwgPyB3YXJuaW5ncyA6IFtdXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1lbmRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuZGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVUZXh0ICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicmVhc29uaW5nLWVuZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctZGVsdGFcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJyZWFzb25pbmctZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaHVuay5kZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY2h1bmsucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2h1bmsucHJlbGltaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFRvb2xPdXRwdXRzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWVycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwVG9vbE91dHB1dHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IChfYTIyID0gY2h1bmsuaWQpICE9IG51bGwgPyBfYTIyIDogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYjIgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYjIgOiBzdGVwUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MyID0gY2h1bmsubW9kZWxJZCkgIT0gbnVsbCA/IF9jMiA6IHN0ZXBSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFJhd0ZpbmlzaFJlYXNvbiA9IGNodW5rLnJhd0ZpbmlzaFJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBQcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaW5pc2ggPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpbmlzaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmluaXNoXCI6IG1zVG9GaW5pc2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuYXZnT3V0cHV0VG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqICgoX2QyID0gc3RlcFVzYWdlLm91dHB1dFRva2VucykgIT0gbnVsbCA/IF9kMiA6IDApIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdID0gY2h1bmsudG9vbE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1tjaHVuay50b29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi5vbklucHV0U3RhcnQpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdG9vbDIub25JbnB1dFN0YXJ0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBjaHVuay5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogc3RlcElucHV0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pYzogKF9lMiA9IGNodW5rLmR5bmFtaWMpICE9IG51bGwgPyBfZTIgOiAodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLnR5cGUpID09PSBcImR5bmFtaWNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50aXRsZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtZW5kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhY3RpdmVUb29sQ2FsbFRvb2xOYW1lc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWlucHV0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gYWN0aXZlVG9vbENhbGxUb29sTmFtZXNbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9vbDIgPSB0b29scyA9PSBudWxsID8gdm9pZCAwIDogdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIub25JbnB1dERlbHRhKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRvb2wyLm9uSW5wdXREZWx0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRUZXh0RGVsdGE6IGNodW5rLmRlbHRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBzdGVwSW5wdXRNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gXCJlcnJvclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2x1ZGVSYXdDaHVua3MyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFRvb2xDYWxsc0pzb24gPSBzdGVwVG9vbENhbGxzLmxlbmd0aCA+IDAgPyBKU09OLnN0cmluZ2lmeShzdGVwVG9vbENhbGxzKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGFjdGl2ZVRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShzdGVwUHJvdmlkZXJNZXRhZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiBzdGVwVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogc3RlcFVzYWdlLm91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnRvdGFsVG9rZW5zXCI6IHN0ZXBVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiBzdGVwVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogc3RlcFVzYWdlLmNhY2hlZElucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiBzdGVwUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHN0ZXBVc2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoLXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBzdGVwUmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29tYmluZWRVc2FnZSA9IGFkZExhbmd1YWdlTW9kZWxVc2FnZShcbiAgICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICBzdGVwVXNhZ2VcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RlcEZpbmlzaC5wcm9taXNlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbGllbnRUb29sQ2FsbHMgPSBzdGVwVG9vbENhbGxzLmZpbHRlcihcbiAgICAgICAgICAgICAgICAgICAgICAodG9vbENhbGwpID0+IHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xpZW50VG9vbE91dHB1dHMgPSBzdGVwVG9vbE91dHB1dHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICh0b29sT3V0cHV0KSA9PiB0b29sT3V0cHV0LnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWVcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sQ2FsbCBvZiBzdGVwVG9vbENhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsLnByb3ZpZGVyRXhlY3V0ZWQgIT09IHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiB0b29sc1t0b29sQ2FsbC50b29sTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIudHlwZSkgPT09IFwicHJvdmlkZXJcIiAmJiB0b29sMi5zdXBwb3J0c0RlZmVycmVkUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzUmVzdWx0SW5TdGVwID0gc3RlcFRvb2xPdXRwdXRzLnNvbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChvdXRwdXQyKSA9PiAob3V0cHV0Mi50eXBlID09PSBcInRvb2wtcmVzdWx0XCIgfHwgb3V0cHV0Mi50eXBlID09PSBcInRvb2wtZXJyb3JcIikgJiYgb3V0cHV0Mi50b29sQ2FsbElkID09PSB0b29sQ2FsbC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNSZXN1bHRJblN0ZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0RlZmVycmVkVG9vbENhbGxzLnNldCh0b29sQ2FsbC50b29sQ2FsbElkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG91dHB1dDIgb2Ygc3RlcFRvb2xPdXRwdXRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLXJlc3VsdFwiIHx8IG91dHB1dDIudHlwZSA9PT0gXCJ0b29sLWVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5kZWxldGUob3V0cHV0Mi50b29sQ2FsbElkKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2xlYXJTdGVwVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhckNodW5rVGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ29udGludWUgaWY6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gMS4gVGhlcmUgYXJlIGNsaWVudCB0b29sIGNhbGxzIHRoYXQgaGF2ZSBhbGwgYmVlbiBleGVjdXRlZCwgT1JcbiAgICAgICAgICAgICAgICAgICAgICAvLyAyLiBUaGVyZSBhcmUgcGVuZGluZyBkZWZlcnJlZCByZXN1bHRzIGZyb20gcHJvdmlkZXItZXhlY3V0ZWQgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAoY2xpZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgY2xpZW50VG9vbE91dHB1dHMubGVuZ3RoID09PSBjbGllbnRUb29sQ2FsbHMubGVuZ3RoIHx8IHBlbmRpbmdEZWZlcnJlZFRvb2xDYWxscy5zaXplID4gMCkgJiYgLy8gY29udGludWUgdW50aWwgYSBzdG9wIGNvbmRpdGlvbiBpcyBtZXQ6XG4gICAgICAgICAgICAgICAgICAgICAgIWF3YWl0IGlzU3RvcENvbmRpdGlvbk1ldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wQ29uZGl0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBzOiByZWNvcmRlZFN0ZXBzXG4gICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXdhaXQgdG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0cmFuc2Zvcm1lZCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbWVzc2FnZXMgZm9yIHRoZSBuZXh0IHN0ZXA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkZWRTdGVwc1tyZWNvcmRlZFN0ZXBzLmxlbmd0aCAtIDFdLmNvbnRlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3RyZWFtU3RlcCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBjdXJyZW50U3RlcCArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHVzYWdlOiBjb21iaW5lZFVzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3RmluaXNoUmVhc29uOiBzdGVwUmF3RmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxVc2FnZTogY29tYmluZWRVc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY2xvc2VTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsZWFyU3RlcFRpbWVvdXQoKTtcbiAgICAgICAgICAgIGNsZWFyQ2h1bmtUaW1lb3V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHN0cmVhbVN0ZXAoe1xuICAgICAgICAgIGN1cnJlbnRTdGVwOiAwLFxuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IGluaXRpYWxSZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICAgIHVzYWdlOiBjcmVhdGVOdWxsTGFuZ3VhZ2VNb2RlbFVzYWdlKClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICBzZWxmLmFkZFN0cmVhbShcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImVycm9yXCIsIGVycm9yIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBzZWxmLmNsb3NlU3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHN0ZXBzKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9zdGVwcy5wcm9taXNlO1xuICB9XG4gIGdldCBmaW5hbFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcHMudGhlbigoc3RlcHMpID0+IHN0ZXBzW3N0ZXBzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBnZXQgY29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5jb250ZW50KTtcbiAgfVxuICBnZXQgd2FybmluZ3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAud2FybmluZ3MpO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnByb3ZpZGVyTWV0YWRhdGEpO1xuICB9XG4gIGdldCB0ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRleHQpO1xuICB9XG4gIGdldCByZWFzb25pbmdUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlYXNvbmluZ1RleHQpO1xuICB9XG4gIGdldCByZWFzb25pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAucmVhc29uaW5nKTtcbiAgfVxuICBnZXQgc291cmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5zb3VyY2VzKTtcbiAgfVxuICBnZXQgZmlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZmlsZXMpO1xuICB9XG4gIGdldCB0b29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudG9vbENhbGxzKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbENhbGxzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnN0YXRpY1Rvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IGR5bmFtaWNUb29sQ2FsbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZHluYW1pY1Rvb2xDYWxscyk7XG4gIH1cbiAgZ2V0IHRvb2xSZXN1bHRzKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnRvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgc3RhdGljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuc3RhdGljVG9vbFJlc3VsdHMpO1xuICB9XG4gIGdldCBkeW5hbWljVG9vbFJlc3VsdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAuZHluYW1pY1Rvb2xSZXN1bHRzKTtcbiAgfVxuICBnZXQgdXNhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTdGVwLnRoZW4oKHN0ZXApID0+IHN0ZXAudXNhZ2UpO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiBzdGVwLnJlcXVlc3QpO1xuICB9XG4gIGdldCByZXNwb25zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5maW5hbFN0ZXAudGhlbigoc3RlcCkgPT4gc3RlcC5yZXNwb25zZSk7XG4gIH1cbiAgZ2V0IHRvdGFsVXNhZ2UoKSB7XG4gICAgdGhpcy5jb25zdW1lU3RyZWFtKCk7XG4gICAgcmV0dXJuIHRoaXMuX3RvdGFsVXNhZ2UucHJvbWlzZTtcbiAgfVxuICBnZXQgZmluaXNoUmVhc29uKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9maW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICBnZXQgcmF3RmluaXNoUmVhc29uKCkge1xuICAgIHRoaXMuY29uc3VtZVN0cmVhbSgpO1xuICAgIHJldHVybiB0aGlzLl9yYXdGaW5pc2hSZWFzb24ucHJvbWlzZTtcbiAgfVxuICAvKipcbiAgICogU3BsaXQgb3V0IGEgbmV3IHN0cmVhbSBmcm9tIHRoZSBvcmlnaW5hbCBzdHJlYW0uXG4gICAqIFRoZSBvcmlnaW5hbCBzdHJlYW0gaXMgcmVwbGFjZWQgdG8gYWxsb3cgZm9yIGZ1cnRoZXIgc3BsaXR0aW5nLFxuICAgKiBzaW5jZSB3ZSBkbyBub3Qga25vdyBob3cgbWFueSB0aW1lcyB0aGUgc3RyZWFtIHdpbGwgYmUgc3BsaXQuXG4gICAqXG4gICAqIE5vdGU6IHRoaXMgbGVhZHMgdG8gYnVmZmVyaW5nIHRoZSBzdHJlYW0gY29udGVudCBvbiB0aGUgc2VydmVyLlxuICAgKiBIb3dldmVyLCB0aGUgTExNIHJlc3VsdHMgYXJlIGV4cGVjdGVkIHRvIGJlIHNtYWxsIGVub3VnaCB0byBub3QgY2F1c2UgaXNzdWVzLlxuICAgKi9cbiAgdGVlU3RyZWFtKCkge1xuICAgIGNvbnN0IFtzdHJlYW0xLCBzdHJlYW0yXSA9IHRoaXMuYmFzZVN0cmVhbS50ZWUoKTtcbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKHsgcGFydCB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAocGFydC50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFydC50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShcbiAgICAgIHRoaXMudGVlU3RyZWFtKCkucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybSh7IHBhcnQgfSwgY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGFzeW5jIGNvbnN1bWVTdHJlYW0ob3B0aW9ucykge1xuICAgIHZhciBfYTIxO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjb25zdW1lU3RyZWFtKHtcbiAgICAgICAgc3RyZWFtOiB0aGlzLmZ1bGxTdHJlYW0sXG4gICAgICAgIG9uRXJyb3I6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMub25FcnJvclxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIChfYTIxID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5jYWxsKG9wdGlvbnMsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGV4cGVyaW1lbnRhbF9wYXJ0aWFsT3V0cHV0U3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRpYWxPdXRwdXRTdHJlYW07XG4gIH1cbiAgZ2V0IHBhcnRpYWxPdXRwdXRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLnRlZVN0cmVhbSgpLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oeyBwYXJ0aWFsT3V0cHV0IH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0aWFsT3V0cHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHBhcnRpYWxPdXRwdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBlbGVtZW50U3RyZWFtKCkge1xuICAgIHZhciBfYTIxLCBfYiwgX2M7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gKF9hMjEgPSB0aGlzLm91dHB1dFNwZWNpZmljYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNyZWF0ZUVsZW1lbnRTdHJlYW1UcmFuc2Zvcm0oKTtcbiAgICBpZiAodHJhbnNmb3JtID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjIoe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBgZWxlbWVudCBzdHJlYW1zIGluICR7KF9jID0gKF9iID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkgIT0gbnVsbCA/IF9jIDogXCJ0ZXh0XCJ9IG1vZGVgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy50ZWVTdHJlYW0oKS5waXBlVGhyb3VnaCh0cmFuc2Zvcm0pKTtcbiAgfVxuICBnZXQgb3V0cHV0KCkge1xuICAgIHJldHVybiB0aGlzLmZpbmFsU3RlcC50aGVuKChzdGVwKSA9PiB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IChfYTIxID0gdGhpcy5vdXRwdXRTcGVjaWZpY2F0aW9uKSAhPSBudWxsID8gX2EyMSA6IHRleHQoKTtcbiAgICAgIHJldHVybiBvdXRwdXQucGFyc2VDb21wbGV0ZU91dHB1dChcbiAgICAgICAgeyB0ZXh0OiBzdGVwLnRleHQgfSxcbiAgICAgICAge1xuICAgICAgICAgIHJlc3BvbnNlOiBzdGVwLnJlc3BvbnNlLFxuICAgICAgICAgIHVzYWdlOiBzdGVwLnVzYWdlLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcC5maW5pc2hSZWFzb25cbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICB0b1VJTWVzc2FnZVN0cmVhbSh7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyA9IHRydWUsXG4gICAgc2VuZFNvdXJjZXMgPSBmYWxzZSxcbiAgICBzZW5kU3RhcnQgPSB0cnVlLFxuICAgIHNlbmRGaW5pc2ggPSB0cnVlLFxuICAgIG9uRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2U3XG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZUlkID0gZ2VuZXJhdGVNZXNzYWdlSWQgIT0gbnVsbCA/IGdldFJlc3BvbnNlVUlNZXNzYWdlSWQoe1xuICAgICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZUlkOiBnZW5lcmF0ZU1lc3NhZ2VJZFxuICAgIH0pIDogdm9pZCAwO1xuICAgIGNvbnN0IGlzRHluYW1pYyA9IChwYXJ0KSA9PiB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGNvbnN0IHRvb2wyID0gKF9hMjEgPSB0aGlzLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMVtwYXJ0LnRvb2xOYW1lXTtcbiAgICAgIGlmICh0b29sMiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBwYXJ0LmR5bmFtaWM7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHRvb2wyID09IG51bGwgPyB2b2lkIDAgOiB0b29sMi50eXBlKSA9PT0gXCJkeW5hbWljXCIgPyB0cnVlIDogdm9pZCAwO1xuICAgIH07XG4gICAgY29uc3QgYmFzZVN0cmVhbSA9IHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm06IGFzeW5jIChwYXJ0LCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWVzc2FnZU1ldGFkYXRhVmFsdWUgPSBtZXNzYWdlTWV0YWRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VNZXRhZGF0YSh7IHBhcnQgfSk7XG4gICAgICAgICAgY29uc3QgcGFydFR5cGUgPSBwYXJ0LnR5cGU7XG4gICAgICAgICAgc3dpdGNoIChwYXJ0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWVuZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWVuZFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyZWFzb25pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICBpZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICAgIGRlbHRhOiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZy1lbmRcIjoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLWVuZFwiLFxuICAgICAgICAgICAgICAgIGlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQuZmlsZS5tZWRpYVR5cGUsXG4gICAgICAgICAgICAgICAgdXJsOiBgZGF0YToke3BhcnQuZmlsZS5tZWRpYVR5cGV9O2Jhc2U2NCwke3BhcnQuZmlsZS5iYXNlNjR9YFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic291cmNlXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHNlbmRTb3VyY2VzICYmIHBhcnQuc291cmNlVHlwZSA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInNvdXJjZS11cmxcIixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgdXJsOiBwYXJ0LnVybCxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2VuZFNvdXJjZXMgJiYgcGFydC5zb3VyY2VUeXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzb3VyY2UtZG9jdW1lbnRcIixcbiAgICAgICAgICAgICAgICAgIHNvdXJjZUlkOiBwYXJ0LmlkLFxuICAgICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICAgIHRpdGxlOiBwYXJ0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgZmlsZW5hbWU6IHBhcnQuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5wcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtaW5wdXQtc3RhcnRcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQuaWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlckV4ZWN1dGVkICE9IG51bGwgPyB7IHByb3ZpZGVyRXhlY3V0ZWQ6IHBhcnQucHJvdmlkZXJFeGVjdXRlZCB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge30sXG4gICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAuLi5wYXJ0LnRpdGxlICE9IG51bGwgPyB7IHRpdGxlOiBwYXJ0LnRpdGxlIH0gOiB7fVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWlucHV0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC5pZCxcbiAgICAgICAgICAgICAgICBpbnB1dFRleHREZWx0YTogcGFydC5kZWx0YVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgaWYgKHBhcnQuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtaW5wdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIGVycm9yVGV4dDogb25FcnJvcihwYXJ0LmVycm9yKSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQudGl0bGUgIT0gbnVsbCA/IHsgdGl0bGU6IHBhcnQudGl0bGUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1pbnB1dC1hdmFpbGFibGVcIixcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lOiBwYXJ0LnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgIT0gbnVsbCA/IHsgcHJvdmlkZXJFeGVjdXRlZDogcGFydC5wcm92aWRlckV4ZWN1dGVkIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9LFxuICAgICAgICAgICAgICAgICAgLi4uZHluYW1pYyAhPSBudWxsID8geyBkeW5hbWljIH0gOiB7fSxcbiAgICAgICAgICAgICAgICAgIC4uLnBhcnQudGl0bGUgIT0gbnVsbCA/IHsgdGl0bGU6IHBhcnQudGl0bGUgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgIGFwcHJvdmFsSWQ6IHBhcnQuYXBwcm92YWxJZCxcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsLnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtcmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgY29uc3QgZHluYW1pYyA9IGlzRHluYW1pYyhwYXJ0KTtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtb3V0cHV0LWF2YWlsYWJsZVwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHBhcnQub3V0cHV0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJlbGltaW5hcnkgIT0gbnVsbCA/IHsgcHJlbGltaW5hcnk6IHBhcnQucHJlbGltaW5hcnkgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtZXJyb3JcIjoge1xuICAgICAgICAgICAgICBjb25zdCBkeW5hbWljID0gaXNEeW5hbWljKHBhcnQpO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1vdXRwdXQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPSBudWxsID8geyBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgfSA6IHt9LFxuICAgICAgICAgICAgICAgIC4uLmR5bmFtaWMgIT0gbnVsbCA/IHsgZHluYW1pYyB9IDoge31cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2wtb3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLW91dHB1dC1kZW5pZWRcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKHBhcnQuZXJyb3IpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydC1zdGVwXCIgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaC1zdGVwXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2gtc3RlcFwiIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzdGFydFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGFydFwiLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZU1lc3NhZ2VJZCAhPSBudWxsID8geyBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkIH0gOiB7fVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgICAgIGlmIChzZW5kRmluaXNoKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IHBhcnQuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgLi4ubWVzc2FnZU1ldGFkYXRhVmFsdWUgIT0gbnVsbCA/IHsgbWVzc2FnZU1ldGFkYXRhOiBtZXNzYWdlTWV0YWRhdGFWYWx1ZSB9IDoge31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJhYm9ydFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vbC1pbnB1dC1lbmRcIjoge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJyYXdcIjoge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gcGFydFR5cGU7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBjaHVuayB0eXBlOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1lc3NhZ2VNZXRhZGF0YVZhbHVlICE9IG51bGwgJiYgcGFydFR5cGUgIT09IFwic3RhcnRcIiAmJiBwYXJ0VHlwZSAhPT0gXCJmaW5pc2hcIikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlLW1ldGFkYXRhXCIsXG4gICAgICAgICAgICAgIG1lc3NhZ2VNZXRhZGF0YTogbWVzc2FnZU1ldGFkYXRhVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgICAgICAgc3RyZWFtOiBiYXNlU3RyZWFtLFxuICAgICAgICBtZXNzYWdlSWQ6IHJlc3BvbnNlTWVzc2FnZUlkICE9IG51bGwgPyByZXNwb25zZU1lc3NhZ2VJZCA6IGdlbmVyYXRlTWVzc2FnZUlkID09IG51bGwgPyB2b2lkIDAgOiBnZW5lcmF0ZU1lc3NhZ2VJZCgpLFxuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHBpcGVVSU1lc3NhZ2VTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG4gICAgb3JpZ2luYWxNZXNzYWdlcyxcbiAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICBvbkZpbmlzaCxcbiAgICBtZXNzYWdlTWV0YWRhdGEsXG4gICAgc2VuZFJlYXNvbmluZyxcbiAgICBzZW5kU291cmNlcyxcbiAgICBzZW5kRmluaXNoLFxuICAgIHNlbmRTdGFydCxcbiAgICBvbkVycm9yLFxuICAgIC4uLmluaXRcbiAgfSA9IHt9KSB7XG4gICAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIHNlbmRGaW5pc2gsXG4gICAgICAgIHNlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHRvVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgZ2VuZXJhdGVNZXNzYWdlSWQsXG4gICAgb25GaW5pc2gsXG4gICAgbWVzc2FnZU1ldGFkYXRhLFxuICAgIHNlbmRSZWFzb25pbmcsXG4gICAgc2VuZFNvdXJjZXMsXG4gICAgc2VuZEZpbmlzaCxcbiAgICBzZW5kU3RhcnQsXG4gICAgb25FcnJvcixcbiAgICAuLi5pbml0XG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSh7XG4gICAgICBzdHJlYW06IHRoaXMudG9VSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICBvcmlnaW5hbE1lc3NhZ2VzLFxuICAgICAgICBnZW5lcmF0ZU1lc3NhZ2VJZCxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG1lc3NhZ2VNZXRhZGF0YSxcbiAgICAgICAgc2VuZFJlYXNvbmluZyxcbiAgICAgICAgc2VuZFNvdXJjZXMsXG4gICAgICAgIHNlbmRGaW5pc2gsXG4gICAgICAgIHNlbmRTdGFydCxcbiAgICAgICAgb25FcnJvclxuICAgICAgfSksXG4gICAgICAuLi5pbml0XG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0U3RyZWFtUmVzcG9uc2Uoe1xuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzcmMvYWdlbnQvdG9vbC1sb29wLWFnZW50LnRzXG52YXIgVG9vbExvb3BBZ2VudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2V0dGluZ3MpIHtcbiAgICB0aGlzLnZlcnNpb24gPSBcImFnZW50LXYxXCI7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaWQgb2YgdGhlIGFnZW50LlxuICAgKi9cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLnNldHRpbmdzLmlkO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdG9vbHMgdGhhdCB0aGUgYWdlbnQgY2FuIHVzZS5cbiAgICovXG4gIGdldCB0b29scygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR0aW5ncy50b29scztcbiAgfVxuICBhc3luYyBwcmVwYXJlQ2FsbChvcHRpb25zKSB7XG4gICAgdmFyIF9hMjEsIF9iLCBfYywgX2Q7XG4gICAgY29uc3QgeyBvblN0ZXBGaW5pc2g6IF9zZXR0aW5nc09uU3RlcEZpbmlzaCwgLi4uc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2sgfSA9IHRoaXMuc2V0dGluZ3M7XG4gICAgY29uc3QgYmFzZUNhbGxBcmdzID0ge1xuICAgICAgLi4uc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2ssXG4gICAgICBzdG9wV2hlbjogKF9hMjEgPSB0aGlzLnNldHRpbmdzLnN0b3BXaGVuKSAhPSBudWxsID8gX2EyMSA6IHN0ZXBDb3VudElzKDIwKSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICAgIGNvbnN0IHByZXBhcmVkQ2FsbEFyZ3MgPSAoX2QgPSBhd2FpdCAoKF9jID0gKF9iID0gdGhpcy5zZXR0aW5ncykucHJlcGFyZUNhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKFxuICAgICAgX2IsXG4gICAgICBiYXNlQ2FsbEFyZ3NcbiAgICApKSkgIT0gbnVsbCA/IF9kIDogYmFzZUNhbGxBcmdzO1xuICAgIGNvbnN0IHsgaW5zdHJ1Y3Rpb25zLCBtZXNzYWdlcywgcHJvbXB0LCAuLi5jYWxsQXJncyB9ID0gcHJlcGFyZWRDYWxsQXJncztcbiAgICByZXR1cm4ge1xuICAgICAgLi4uY2FsbEFyZ3MsXG4gICAgICAvLyByZXN0b3JlIHByb21wdCB0eXBlc1xuICAgICAgLi4ueyBzeXN0ZW06IGluc3RydWN0aW9ucywgbWVzc2FnZXMsIHByb21wdCB9XG4gICAgfTtcbiAgfVxuICBtZXJnZU9uU3RlcEZpbmlzaENhbGxiYWNrcyhtZXRob2RDYWxsYmFjaykge1xuICAgIGNvbnN0IGNvbnN0cnVjdG9yQ2FsbGJhY2sgPSB0aGlzLnNldHRpbmdzLm9uU3RlcEZpbmlzaDtcbiAgICBpZiAobWV0aG9kQ2FsbGJhY2sgJiYgY29uc3RydWN0b3JDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGFzeW5jIChzdGVwUmVzdWx0KSA9PiB7XG4gICAgICAgIGF3YWl0IGNvbnN0cnVjdG9yQ2FsbGJhY2soc3RlcFJlc3VsdCk7XG4gICAgICAgIGF3YWl0IG1ldGhvZENhbGxiYWNrKHN0ZXBSZXN1bHQpO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZENhbGxiYWNrICE9IG51bGwgPyBtZXRob2RDYWxsYmFjayA6IGNvbnN0cnVjdG9yQ2FsbGJhY2s7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBvdXRwdXQgZnJvbSB0aGUgYWdlbnQgKG5vbi1zdHJlYW1pbmcpLlxuICAgKi9cbiAgYXN5bmMgZ2VuZXJhdGUoe1xuICAgIGFib3J0U2lnbmFsLFxuICAgIHRpbWVvdXQsXG4gICAgb25TdGVwRmluaXNoLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHJldHVybiBnZW5lcmF0ZVRleHQoe1xuICAgICAgLi4uYXdhaXQgdGhpcy5wcmVwYXJlQ2FsbChvcHRpb25zKSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgdGltZW91dCxcbiAgICAgIG9uU3RlcEZpbmlzaDogdGhpcy5tZXJnZU9uU3RlcEZpbmlzaENhbGxiYWNrcyhvblN0ZXBGaW5pc2gpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0cmVhbXMgYW4gb3V0cHV0IGZyb20gdGhlIGFnZW50IChzdHJlYW1pbmcpLlxuICAgKi9cbiAgYXN5bmMgc3RyZWFtKHtcbiAgICBhYm9ydFNpZ25hbCxcbiAgICB0aW1lb3V0LFxuICAgIGV4cGVyaW1lbnRhbF90cmFuc2Zvcm0sXG4gICAgb25TdGVwRmluaXNoLFxuICAgIC4uLm9wdGlvbnNcbiAgfSkge1xuICAgIHJldHVybiBzdHJlYW1UZXh0KHtcbiAgICAgIC4uLmF3YWl0IHRoaXMucHJlcGFyZUNhbGwob3B0aW9ucyksXG4gICAgICBhYm9ydFNpZ25hbCxcbiAgICAgIHRpbWVvdXQsXG4gICAgICBleHBlcmltZW50YWxfdHJhbnNmb3JtLFxuICAgICAgb25TdGVwRmluaXNoOiB0aGlzLm1lcmdlT25TdGVwRmluaXNoQ2FsbGJhY2tzKG9uU3RlcEZpbmlzaClcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL2NyZWF0ZS11aS1tZXNzYWdlLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYyxcbiAgZ2V0RXJyb3JNZXNzYWdlIGFzIGdldEVycm9yTWVzc2FnZThcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGNyZWF0ZVVJTWVzc2FnZVN0cmVhbSh7XG4gIGV4ZWN1dGUsXG4gIG9uRXJyb3IgPSBnZXRFcnJvck1lc3NhZ2U4LFxuICBvcmlnaW5hbE1lc3NhZ2VzLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuY1xufSkge1xuICBsZXQgY29udHJvbGxlcjtcbiAgY29uc3Qgb25nb2luZ1N0cmVhbVByb21pc2VzID0gW107XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlckFyZykge1xuICAgICAgY29udHJvbGxlciA9IGNvbnRyb2xsZXJBcmc7XG4gICAgfVxuICB9KTtcbiAgZnVuY3Rpb24gc2FmZUVucXVldWUoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBleGVjdXRlKHtcbiAgICAgIHdyaXRlcjoge1xuICAgICAgICB3cml0ZShwYXJ0KSB7XG4gICAgICAgICAgc2FmZUVucXVldWUocGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lcmdlKHN0cmVhbUFyZykge1xuICAgICAgICAgIG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtQXJnLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBzYWZlRW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIHNhZmVFbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKGVycm9yKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvclxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5wdXNoKFxuICAgICAgICByZXN1bHQuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgc2FmZUVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKGVycm9yKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgc2FmZUVucXVldWUoe1xuICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgZXJyb3JUZXh0OiBvbkVycm9yKGVycm9yKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHdhaXRGb3JTdHJlYW1zID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUzKSA9PiB7XG4gICAgd2hpbGUgKG9uZ29pbmdTdHJlYW1Qcm9taXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCBvbmdvaW5nU3RyZWFtUHJvbWlzZXMuc2hpZnQoKTtcbiAgICB9XG4gICAgcmVzb2x2ZTMoKTtcbiAgfSk7XG4gIHdhaXRGb3JTdHJlYW1zLmZpbmFsbHkoKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaGFuZGxlVUlNZXNzYWdlU3RyZWFtRmluaXNoKHtcbiAgICBzdHJlYW0sXG4gICAgbWVzc2FnZUlkOiBnZW5lcmF0ZUlkMigpLFxuICAgIG9yaWdpbmFsTWVzc2FnZXMsXG4gICAgb25GaW5pc2gsXG4gICAgb25FcnJvclxuICB9KTtcbn1cblxuLy8gc3JjL3VpLW1lc3NhZ2Utc3RyZWFtL3JlYWQtdWktbWVzc2FnZS1zdHJlYW0udHNcbmZ1bmN0aW9uIHJlYWRVSU1lc3NhZ2VTdHJlYW0oe1xuICBtZXNzYWdlLFxuICBzdHJlYW0sXG4gIG9uRXJyb3IsXG4gIHRlcm1pbmF0ZU9uRXJyb3IgPSBmYWxzZVxufSkge1xuICB2YXIgX2EyMTtcbiAgbGV0IGNvbnRyb2xsZXI7XG4gIGxldCBoYXNFcnJvcmVkID0gZmFsc2U7XG4gIGNvbnN0IG91dHB1dFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICBjb250cm9sbGVyID0gY29udHJvbGxlclBhcmFtO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgIG1lc3NhZ2VJZDogKF9hMjEgPSBtZXNzYWdlID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlLmlkKSAhPSBudWxsID8gX2EyMSA6IFwiXCIsXG4gICAgbGFzdE1lc3NhZ2U6IG1lc3NhZ2VcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZUVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgb25FcnJvciA9PSBudWxsID8gdm9pZCAwIDogb25FcnJvcihlcnJvcik7XG4gICAgaWYgKCFoYXNFcnJvcmVkICYmIHRlcm1pbmF0ZU9uRXJyb3IpIHtcbiAgICAgIGhhc0Vycm9yZWQgPSB0cnVlO1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuICBjb25zdW1lU3RyZWFtKHtcbiAgICBzdHJlYW06IHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgc3RyZWFtLFxuICAgICAgcnVuVXBkYXRlTWVzc2FnZUpvYihqb2IpIHtcbiAgICAgICAgcmV0dXJuIGpvYih7XG4gICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgd3JpdGU6ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuZW5xdWV1ZShzdHJ1Y3R1cmVkQ2xvbmUoc3RhdGUubWVzc2FnZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogaGFuZGxlRXJyb3JcbiAgICB9KSxcbiAgICBvbkVycm9yOiBoYW5kbGVFcnJvclxuICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICBpZiAoIWhhc0Vycm9yZWQpIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbShvdXRwdXRTdHJlYW0pO1xufVxuXG4vLyBzcmMvdWkvY29udmVydC10by1tb2RlbC1tZXNzYWdlcy50c1xuaW1wb3J0IHtcbiAgaXNOb25OdWxsYWJsZVxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTW9kZWxNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucykge1xuICBjb25zdCBtb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUluY29tcGxldGVUb29sQ2FsbHMpIHtcbiAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLm1lc3NhZ2UsXG4gICAgICBwYXJ0czogbWVzc2FnZS5wYXJ0cy5maWx0ZXIoXG4gICAgICAgIChwYXJ0KSA9PiAhaXNUb29sVUlQYXJ0KHBhcnQpIHx8IHBhcnQuc3RhdGUgIT09IFwiaW5wdXQtc3RyZWFtaW5nXCIgJiYgcGFydC5zdGF0ZSAhPT0gXCJpbnB1dC1hdmFpbGFibGVcIlxuICAgICAgKVxuICAgIH0pKTtcbiAgfVxuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvbnN0IHRleHRQYXJ0cyA9IG1lc3NhZ2UucGFydHMuZmlsdGVyKFxuICAgICAgICAgIChwYXJ0KSA9PiBwYXJ0LnR5cGUgPT09IFwidGV4dFwiXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTWV0YWRhdGEgPSB0ZXh0UGFydHMucmVkdWNlKChhY2MsIHBhcnQpID0+IHtcbiAgICAgICAgICBpZiAocGFydC5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLmFjYywgLi4ucGFydC5wcm92aWRlck1ldGFkYXRhIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHRleHRQYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQudGV4dCkuam9pbihcIlwiKSxcbiAgICAgICAgICAuLi5PYmplY3Qua2V5cyhwcm92aWRlck1ldGFkYXRhKS5sZW5ndGggPiAwID8geyBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJ1c2VyXCI6IHtcbiAgICAgICAgbW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLnBhcnRzLm1hcCgocGFydCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hMjE7XG4gICAgICAgICAgICBpZiAoaXNUZXh0VUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0ZpbGVVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IHBhcnQubWVkaWFUeXBlLFxuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGRhdGE6IHBhcnQudXJsLFxuICAgICAgICAgICAgICAgIC4uLnBhcnQucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQucHJvdmlkZXJNZXRhZGF0YSB9IDoge31cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RhdGFVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYTIxID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5jb252ZXJ0RGF0YVBhcnQpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwoXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBwYXJ0XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuZmlsdGVyKGlzTm9uTnVsbGFibGUpXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgICAgbGV0IGJsb2NrID0gW107XG4gICAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKCkge1xuICAgICAgICAgICAgdmFyIF9hMjEsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGlmIChibG9jay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGJsb2NrKSB7XG4gICAgICAgICAgICAgIGlmIChpc1RleHRVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICAgICAgICAgICAgICAuLi5wYXJ0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNGaWxlVUlQYXJ0KHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgICAgICAgbWVkaWFUeXBlOiBwYXJ0Lm1lZGlhVHlwZSxcbiAgICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBwYXJ0LmZpbGVuYW1lLFxuICAgICAgICAgICAgICAgICAgZGF0YTogcGFydC51cmxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1JlYXNvbmluZ1VJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZ1wiLFxuICAgICAgICAgICAgICAgICAgdGV4dDogcGFydC50ZXh0LFxuICAgICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1Rvb2xVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGdldFRvb2xOYW1lKHBhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0LnN0YXRlICE9PSBcImlucHV0LXN0cmVhbWluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICBjb250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIiA/IChfYTIxID0gcGFydC5pbnB1dCkgIT0gbnVsbCA/IF9hMjEgOiBcInJhd0lucHV0XCIgaW4gcGFydCA/IHBhcnQucmF3SW5wdXQgOiB2b2lkIDAgOiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiBwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCA/IHsgcHJvdmlkZXJPcHRpb25zOiBwYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAocGFydC5hcHByb3ZhbCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWFwcHJvdmFsLXJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiBwYXJ0LmFwcHJvdmFsLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LnByb3ZpZGVyRXhlY3V0ZWQgPT09IHRydWUgJiYgcGFydC5zdGF0ZSAhPT0gXCJhcHByb3ZhbC1yZXNwb25kZWRcIiAmJiAocGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgcGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtZXJyb3JcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogcGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogYXdhaXQgY3JlYXRlVG9vbE1vZGVsT3V0cHV0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiID8gcGFydC5lcnJvclRleHQgOiBwYXJ0Lm91dHB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYlt0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1vZGU6IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBcImpzb25cIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgLi4ucGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0RhdGFVSVBhcnQocGFydCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhUGFydCA9IChfYyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udmVydERhdGFQYXJ0KSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICBwYXJ0XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YVBhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgY29udGVudC5wdXNoKGRhdGFQYXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwYXJ0OiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdG9vbFBhcnRzID0gYmxvY2suZmlsdGVyKFxuICAgICAgICAgICAgICAocGFydCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTIyO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1Rvb2xVSVBhcnQocGFydCkgJiYgKHBhcnQucHJvdmlkZXJFeGVjdXRlZCAhPT0gdHJ1ZSB8fCAoKF9hMjIgPSBwYXJ0LmFwcHJvdmFsKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMi5hcHByb3ZlZCkgIT0gbnVsbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodG9vbFBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQyID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sUGFydCBvZiB0b29sUGFydHMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICgoKF9kID0gdG9vbFBhcnQuYXBwcm92YWwpID09IG51bGwgPyB2b2lkIDAgOiBfZC5hcHByb3ZlZCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50Mi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZhbElkOiB0b29sUGFydC5hcHByb3ZhbC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBhcHByb3ZlZDogdG9vbFBhcnQuYXBwcm92YWwuYXBwcm92ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiB0b29sUGFydC5hcHByb3ZhbC5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogdG9vbFBhcnQucHJvdmlkZXJFeGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmICh0b29sUGFydC5wcm92aWRlckV4ZWN1dGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc3dpdGNoICh0b29sUGFydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwib3V0cHV0LWRlbmllZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sUGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbE5hbWU6IGdldFRvb2xOYW1lKHRvb2xQYXJ0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImVycm9yLXRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IChfZSA9IHRvb2xQYXJ0LmFwcHJvdmFsLnJlYXNvbikgIT0gbnVsbCA/IF9lIDogXCJUb29sIGV4ZWN1dGlvbiBkZW5pZWQuXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50b29sUGFydC5jYWxsUHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck9wdGlvbnM6IHRvb2xQYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvdXRwdXQtZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm91dHB1dC1hdmFpbGFibGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gZ2V0VG9vbE5hbWUodG9vbFBhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQyLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdG9vbFBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBhd2FpdCBjcmVhdGVUb29sTW9kZWxPdXRwdXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbElkOiB0b29sUGFydC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogdG9vbFBhcnQuaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyB0b29sUGFydC5lcnJvclRleHQgOiB0b29sUGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2w6IChfZiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZlt0b29sTmFtZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTW9kZTogdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgPyBcInRleHRcIiA6IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRvb2xQYXJ0LmNhbGxQcm92aWRlck1ldGFkYXRhICE9IG51bGwgPyB7IHByb3ZpZGVyT3B0aW9uczogdG9vbFBhcnQuY2FsbFByb3ZpZGVyTWV0YWRhdGEgfSA6IHt9XG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIG1vZGVsTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50MlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibG9jayA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgbWVzc2FnZS5wYXJ0cykge1xuICAgICAgICAgICAgaWYgKGlzVGV4dFVJUGFydChwYXJ0KSB8fCBpc1JlYXNvbmluZ1VJUGFydChwYXJ0KSB8fCBpc0ZpbGVVSVBhcnQocGFydCkgfHwgaXNUb29sVUlQYXJ0KHBhcnQpIHx8IGlzRGF0YVVJUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICBibG9jay5wdXNoKHBhcnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NCbG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBwcm9jZXNzQmxvY2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1lc3NhZ2Uucm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb2RlbE1lc3NhZ2VzO1xufVxuXG4vLyBzcmMvdWkvdmFsaWRhdGUtdWktbWVzc2FnZXMudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgbGF6eVNjaGVtYSBhcyBsYXp5U2NoZW1hMixcbiAgdmFsaWRhdGVUeXBlcyBhcyB2YWxpZGF0ZVR5cGVzMixcbiAgem9kU2NoZW1hIGFzIHpvZFNjaGVtYTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IHogYXMgejggfSBmcm9tIFwiem9kL3Y0XCI7XG52YXIgdWlNZXNzYWdlc1NjaGVtYSA9IGxhenlTY2hlbWEyKFxuICAoKSA9PiB6b2RTY2hlbWEyKFxuICAgIHo4LmFycmF5KFxuICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgaWQ6IHo4LnN0cmluZygpLFxuICAgICAgICByb2xlOiB6OC5lbnVtKFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIl0pLFxuICAgICAgICBtZXRhZGF0YTogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgIHBhcnRzOiB6OC5hcnJheShcbiAgICAgICAgICB6OC51bmlvbihbXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwidGV4dFwiKSxcbiAgICAgICAgICAgICAgdGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5lbnVtKFtcInN0cmVhbWluZ1wiLCBcImRvbmVcIl0pLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwicmVhc29uaW5nXCIpLFxuICAgICAgICAgICAgICB0ZXh0OiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmVudW0oW1wic3RyZWFtaW5nXCIsIFwiZG9uZVwiXSkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJzb3VyY2UtdXJsXCIpLFxuICAgICAgICAgICAgICBzb3VyY2VJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHVybDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRpdGxlOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInNvdXJjZS1kb2N1bWVudFwiKSxcbiAgICAgICAgICAgICAgc291cmNlSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBtZWRpYVR5cGU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0aXRsZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImZpbGVcIiksXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICB1cmw6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcInN0ZXAtc3RhcnRcIilcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcImRhdGEtXCIpLFxuICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZGF0YTogejgudW5rbm93bigpXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiaW5wdXQtc3RyZWFtaW5nXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJpbnB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJhcHByb3ZhbC1yZXF1ZXN0ZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LmxpdGVyYWwoXCJkeW5hbWljLXRvb2xcIiksXG4gICAgICAgICAgICAgIHRvb2xOYW1lOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiYXBwcm92YWwtcmVzcG9uZGVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejgubGl0ZXJhbChcImR5bmFtaWMtdG9vbFwiKSxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1lcnJvclwiKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgcmF3SW5wdXQ6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5saXRlcmFsKFwiZHluYW1pYy10b29sXCIpLFxuICAgICAgICAgICAgICB0b29sTmFtZTogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1kZW5pZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbChmYWxzZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiaW5wdXQtc3RyZWFtaW5nXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgY2FsbFByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJpbnB1dC1hdmFpbGFibGVcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5uZXZlcigpLm9wdGlvbmFsKClcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJhcHByb3ZhbC1yZXF1ZXN0ZWRcIiksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogejgubmV2ZXIoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHo4Lm9iamVjdCh7XG4gICAgICAgICAgICAgIHR5cGU6IHo4LnN0cmluZygpLnN0YXJ0c1dpdGgoXCJ0b29sLVwiKSxcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIHN0YXRlOiB6OC5saXRlcmFsKFwiYXBwcm92YWwtcmVzcG9uZGVkXCIpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBhcHByb3ZhbDogejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBpZDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgYXBwcm92ZWQ6IHo4LmJvb2xlYW4oKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgejgub2JqZWN0KHtcbiAgICAgICAgICAgICAgdHlwZTogejguc3RyaW5nKCkuc3RhcnRzV2l0aChcInRvb2wtXCIpLFxuICAgICAgICAgICAgICB0b29sQ2FsbElkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgc3RhdGU6IHo4LmxpdGVyYWwoXCJvdXRwdXQtYXZhaWxhYmxlXCIpLFxuICAgICAgICAgICAgICBwcm92aWRlckV4ZWN1dGVkOiB6OC5ib29sZWFuKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgaW5wdXQ6IHo4LnVua25vd24oKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejgubmV2ZXIoKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBjYWxsUHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBwcmVsaW1pbmFyeTogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1lcnJvclwiKSxcbiAgICAgICAgICAgICAgcHJvdmlkZXJFeGVjdXRlZDogejguYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGlucHV0OiB6OC51bmtub3duKCksXG4gICAgICAgICAgICAgIHJhd0lucHV0OiB6OC51bmtub3duKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgb3V0cHV0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGVycm9yVGV4dDogejguc3RyaW5nKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbCh0cnVlKSxcbiAgICAgICAgICAgICAgICByZWFzb246IHo4LnN0cmluZygpLm9wdGlvbmFsKClcbiAgICAgICAgICAgICAgfSkub3B0aW9uYWwoKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICB0eXBlOiB6OC5zdHJpbmcoKS5zdGFydHNXaXRoKFwidG9vbC1cIiksXG4gICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IHo4LnN0cmluZygpLFxuICAgICAgICAgICAgICBzdGF0ZTogejgubGl0ZXJhbChcIm91dHB1dC1kZW5pZWRcIiksXG4gICAgICAgICAgICAgIHByb3ZpZGVyRXhlY3V0ZWQ6IHo4LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICAgICAgICAgICAgICBpbnB1dDogejgudW5rbm93bigpLFxuICAgICAgICAgICAgICBvdXRwdXQ6IHo4Lm5ldmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgICAgZXJyb3JUZXh0OiB6OC5uZXZlcigpLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGNhbGxQcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG4gICAgICAgICAgICAgIGFwcHJvdmFsOiB6OC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgIGlkOiB6OC5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBhcHByb3ZlZDogejgubGl0ZXJhbChmYWxzZSksXG4gICAgICAgICAgICAgICAgcmVhc29uOiB6OC5zdHJpbmcoKS5vcHRpb25hbCgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIF0pXG4gICAgICAgICkubm9uZW1wdHkoXCJNZXNzYWdlIG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgcGFydFwiKVxuICAgICAgfSlcbiAgICApLm5vbmVtcHR5KFwiTWVzc2FnZXMgYXJyYXkgbXVzdCBub3QgYmUgZW1wdHlcIilcbiAgKVxuKTtcbmFzeW5jIGZ1bmN0aW9uIHNhZmVWYWxpZGF0ZVVJTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgbWV0YWRhdGFTY2hlbWEsXG4gIGRhdGFTY2hlbWFzLFxuICB0b29sc1xufSkge1xuICB0cnkge1xuICAgIGlmIChtZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgICAgcGFyYW1ldGVyOiBcIm1lc3NhZ2VzXCIsXG4gICAgICAgICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgcGFyYW1ldGVyIG11c3QgYmUgcHJvdmlkZWRcIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGVkTWVzc2FnZXMgPSBhd2FpdCB2YWxpZGF0ZVR5cGVzMih7XG4gICAgICB2YWx1ZTogbWVzc2FnZXMsXG4gICAgICBzY2hlbWE6IHVpTWVzc2FnZXNTY2hlbWFcbiAgICB9KTtcbiAgICBpZiAobWV0YWRhdGFTY2hlbWEpIHtcbiAgICAgIGZvciAoY29uc3QgW21zZ0lkeCwgbWVzc2FnZV0gb2YgdmFsaWRhdGVkTWVzc2FnZXMuZW50cmllcygpKSB7XG4gICAgICAgIGF3YWl0IHZhbGlkYXRlVHlwZXMyKHtcbiAgICAgICAgICB2YWx1ZTogbWVzc2FnZS5tZXRhZGF0YSxcbiAgICAgICAgICBzY2hlbWE6IG1ldGFkYXRhU2NoZW1hLFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIGZpZWxkOiBgbWVzc2FnZXNbJHttc2dJZHh9XS5tZXRhZGF0YWAsXG4gICAgICAgICAgICBlbnRpdHlJZDogbWVzc2FnZS5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhU2NoZW1hcyB8fCB0b29scykge1xuICAgICAgZm9yIChjb25zdCBbbXNnSWR4LCBtZXNzYWdlXSBvZiB2YWxpZGF0ZWRNZXNzYWdlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBbcGFydElkeCwgcGFydF0gb2YgbWVzc2FnZS5wYXJ0cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBpZiAoZGF0YVNjaGVtYXMgJiYgcGFydC50eXBlLnN0YXJ0c1dpdGgoXCJkYXRhLVwiKSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YVBhcnQgPSBwYXJ0O1xuICAgICAgICAgICAgY29uc3QgZGF0YU5hbWUgPSBkYXRhUGFydC50eXBlLnNsaWNlKDUpO1xuICAgICAgICAgICAgY29uc3QgZGF0YVNjaGVtYSA9IGRhdGFTY2hlbWFzW2RhdGFOYW1lXTtcbiAgICAgICAgICAgIGlmICghZGF0YVNjaGVtYSkge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGRhdGFQYXJ0LmRhdGEsXG4gICAgICAgICAgICAgICAgICBjYXVzZTogYE5vIGRhdGEgc2NoZW1hIGZvdW5kIGZvciBkYXRhIHBhcnQgJHtkYXRhTmFtZX1gLFxuICAgICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZDogYG1lc3NhZ2VzWyR7bXNnSWR4fV0ucGFydHNbJHtwYXJ0SWR4fV0uZGF0YWAsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IGRhdGFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBlbnRpdHlJZDogZGF0YVBhcnQuaWRcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICB2YWx1ZTogZGF0YVBhcnQuZGF0YSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBkYXRhU2NoZW1hLFxuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLmRhdGFgLFxuICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IGRhdGFOYW1lLFxuICAgICAgICAgICAgICAgIGVudGl0eUlkOiBkYXRhUGFydC5pZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvb2xzICYmIHBhcnQudHlwZS5zdGFydHNXaXRoKFwidG9vbC1cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xQYXJ0ID0gcGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xOYW1lID0gdG9vbFBhcnQudHlwZS5zbGljZSg1KTtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0b29sMikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjMoe1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgICAgY2F1c2U6IGBObyB0b29sIHNjaGVtYSBmb3VuZCBmb3IgdG9vbCBwYXJ0ICR7dG9vbE5hbWV9YCxcbiAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLmlucHV0YCxcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5TmFtZTogdG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eUlkOiB0b29sUGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b29sUGFydC5zdGF0ZSA9PT0gXCJpbnB1dC1hdmFpbGFibGVcIiB8fCB0b29sUGFydC5zdGF0ZSA9PT0gXCJvdXRwdXQtYXZhaWxhYmxlXCIgfHwgdG9vbFBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgJiYgdG9vbFBhcnQuaW5wdXQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZVR5cGVzMih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHRvb2xQYXJ0LmlucHV0LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogdG9vbDIuaW5wdXRTY2hlbWEsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLmlucHV0YCxcbiAgICAgICAgICAgICAgICAgIGVudGl0eU5hbWU6IHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgZW50aXR5SWQ6IHRvb2xQYXJ0LnRvb2xDYWxsSWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvb2xQYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiAmJiB0b29sMi5vdXRwdXRTY2hlbWEpIHtcbiAgICAgICAgICAgICAgYXdhaXQgdmFsaWRhdGVUeXBlczIoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0b29sUGFydC5vdXRwdXQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiB0b29sMi5vdXRwdXRTY2hlbWEsXG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgZmllbGQ6IGBtZXNzYWdlc1ske21zZ0lkeH1dLnBhcnRzWyR7cGFydElkeH1dLm91dHB1dGAsXG4gICAgICAgICAgICAgICAgICBlbnRpdHlOYW1lOiB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgIGVudGl0eUlkOiB0b29sUGFydC50b29sQ2FsbElkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICBkYXRhOiB2YWxpZGF0ZWRNZXNzYWdlc1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZXJyID0gZXJyb3I7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IGVyclxuICAgIH07XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gIG1lc3NhZ2VzLFxuICBtZXRhZGF0YVNjaGVtYSxcbiAgZGF0YVNjaGVtYXMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2FmZVZhbGlkYXRlVUlNZXNzYWdlcyh7XG4gICAgbWVzc2FnZXMsXG4gICAgbWV0YWRhdGFTY2hlbWEsXG4gICAgZGF0YVNjaGVtYXMsXG4gICAgdG9vbHNcbiAgfSk7XG4gIGlmICghcmVzcG9uc2Uuc3VjY2VzcylcbiAgICB0aHJvdyByZXNwb25zZS5lcnJvcjtcbiAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG59XG5cbi8vIHNyYy9hZ2VudC9jcmVhdGUtYWdlbnQtdWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVBZ2VudFVJU3RyZWFtKHtcbiAgYWdlbnQsXG4gIHVpTWVzc2FnZXMsXG4gIG9wdGlvbnMsXG4gIGFib3J0U2lnbmFsLFxuICB0aW1lb3V0LFxuICBleHBlcmltZW50YWxfdHJhbnNmb3JtLFxuICBvblN0ZXBGaW5pc2gsXG4gIC4uLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnNcbn0pIHtcbiAgY29uc3QgdmFsaWRhdGVkTWVzc2FnZXMgPSBhd2FpdCB2YWxpZGF0ZVVJTWVzc2FnZXMoe1xuICAgIG1lc3NhZ2VzOiB1aU1lc3NhZ2VzLFxuICAgIHRvb2xzOiBhZ2VudC50b29sc1xuICB9KTtcbiAgY29uc3QgbW9kZWxNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb01vZGVsTWVzc2FnZXModmFsaWRhdGVkTWVzc2FnZXMsIHtcbiAgICB0b29sczogYWdlbnQudG9vbHNcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFnZW50LnN0cmVhbSh7XG4gICAgcHJvbXB0OiBtb2RlbE1lc3NhZ2VzLFxuICAgIG9wdGlvbnMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgdGltZW91dCxcbiAgICBleHBlcmltZW50YWxfdHJhbnNmb3JtLFxuICAgIG9uU3RlcEZpbmlzaFxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdC50b1VJTWVzc2FnZVN0cmVhbSh1aU1lc3NhZ2VTdHJlYW1PcHRpb25zKTtcbn1cblxuLy8gc3JjL2FnZW50L2NyZWF0ZS1hZ2VudC11aS1zdHJlYW0tcmVzcG9uc2UudHNcbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUFnZW50VUlTdHJlYW1SZXNwb25zZSh7XG4gIGhlYWRlcnMsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgY29uc3VtZVNzZVN0cmVhbSxcbiAgLi4ub3B0aW9uc1xufSkge1xuICByZXR1cm4gY3JlYXRlVUlNZXNzYWdlU3RyZWFtUmVzcG9uc2Uoe1xuICAgIGhlYWRlcnMsXG4gICAgc3RhdHVzLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY29uc3VtZVNzZVN0cmVhbSxcbiAgICBzdHJlYW06IGF3YWl0IGNyZWF0ZUFnZW50VUlTdHJlYW0ob3B0aW9ucylcbiAgfSk7XG59XG5cbi8vIHNyYy9hZ2VudC9waXBlLWFnZW50LXVpLXN0cmVhbS10by1yZXNwb25zZS50c1xuYXN5bmMgZnVuY3Rpb24gcGlwZUFnZW50VUlTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgcmVzcG9uc2UsXG4gIGhlYWRlcnMsXG4gIHN0YXR1cyxcbiAgc3RhdHVzVGV4dCxcbiAgY29uc3VtZVNzZVN0cmVhbSxcbiAgLi4ub3B0aW9uc1xufSkge1xuICBwaXBlVUlNZXNzYWdlU3RyZWFtVG9SZXNwb25zZSh7XG4gICAgcmVzcG9uc2UsXG4gICAgaGVhZGVycyxcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzVGV4dCxcbiAgICBjb25zdW1lU3NlU3RyZWFtLFxuICAgIHN0cmVhbTogYXdhaXQgY3JlYXRlQWdlbnRVSVN0cmVhbShvcHRpb25zKVxuICB9KTtcbn1cblxuLy8gc3JjL2VtYmVkL2VtYmVkLnRzXG5pbXBvcnQgeyB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXgzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIGVtYmVkKHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICB2YWx1ZSxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUVtYmVkZGluZ01vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDMoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgc2V0dGluZ3M6IHsgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZW1iZWRcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgXCJhaS52YWx1ZVwiOiB7IGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgfVxuICAgICAgfVxuICAgIH0pLFxuICAgIHRyYWNlcixcbiAgICBmbjogYXN5bmMgKHNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHsgZW1iZWRkaW5nLCB1c2FnZSwgd2FybmluZ3MsIHJlc3BvbnNlLCBwcm92aWRlck1ldGFkYXRhIH0gPSBhd2FpdCByZXRyeShcbiAgICAgICAgKCkgPT4gKFxuICAgICAgICAgIC8vIG5lc3RlZCBzcGFucyB0byBhbGlnbiB3aXRoIHRoZSBlbWJlZE1hbnkgdGVsZW1ldHJ5IGRhdGE6XG4gICAgICAgICAgcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWQuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHsgaW5wdXQ6ICgpID0+IFtKU09OLnN0cmluZ2lmeSh2YWx1ZSldIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTIxO1xuICAgICAgICAgICAgICBjb25zdCBtb2RlbFJlc3BvbnNlID0gYXdhaXQgbW9kZWwuZG9FbWJlZCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBbdmFsdWVdLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nMiA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5nc1swXTtcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMjEgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2EyMSA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoZW1iZWRkaW5nMykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nMylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZzogZW1iZWRkaW5nMixcbiAgICAgICAgICAgICAgICB1c2FnZTogdXNhZ2UyLFxuICAgICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICByZXNwb25zZTogbW9kZWxSZXNwb25zZS5yZXNwb25zZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ1wiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGxvZ1dhcm5pbmdzKHsgd2FybmluZ3MsIHByb3ZpZGVyOiBtb2RlbC5wcm92aWRlciwgbW9kZWw6IG1vZGVsLm1vZGVsSWQgfSk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBlbWJlZGRpbmcsXG4gICAgICAgIHVzYWdlLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG4gICAgdGhpcy5lbWJlZGRpbmcgPSBvcHRpb25zLmVtYmVkZGluZztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIHNyYy9lbWJlZC9lbWJlZC1tYW55LnRzXG5pbXBvcnQgeyB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvc3BsaXQtYXJyYXkudHNcbmZ1bmN0aW9uIHNwbGl0QXJyYXkoYXJyYXkyLCBjaHVua1NpemUpIHtcbiAgaWYgKGNodW5rU2l6ZSA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY2h1bmtTaXplIG11c3QgYmUgZ3JlYXRlciB0aGFuIDBcIik7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkyLmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheTIuc2xpY2UoaSwgaSArIGNodW5rU2l6ZSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHNyYy9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbDogbW9kZWxBcmcsXG4gIHZhbHVlcyxcbiAgbWF4UGFyYWxsZWxDYWxscyA9IEluZmluaXR5LFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgcHJvdmlkZXJPcHRpb25zLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnlcbn0pIHtcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlRW1iZWRkaW5nTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgaGVhZGVyc1dpdGhVc2VyQWdlbnQgPSB3aXRoVXNlckFnZW50U3VmZml4NChcbiAgICBoZWFkZXJzICE9IG51bGwgPyBoZWFkZXJzIDoge30sXG4gICAgYGFpLyR7VkVSU0lPTn1gXG4gICk7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudCxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZE1hbnlcIixcbiAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgIHRlbGVtZXRyeSxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHsgb3BlcmF0aW9uSWQ6IFwiYWkuZW1iZWRNYW55XCIsIHRlbGVtZXRyeSB9KSxcbiAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiB2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gSlNPTi5zdHJpbmdpZnkodmFsdWUpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMjE7XG4gICAgICBjb25zdCBbbWF4RW1iZWRkaW5nc1BlckNhbGwsIHN1cHBvcnRzUGFyYWxsZWxDYWxsc10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgIG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgICBtb2RlbC5zdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgICAgIF0pO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwgfHwgbWF4RW1iZWRkaW5nc1BlckNhbGwgPT09IEluZmluaXR5KSB7XG4gICAgICAgIGNvbnN0IHsgZW1iZWRkaW5nczogZW1iZWRkaW5nczIsIHVzYWdlLCB3YXJuaW5nczogd2FybmluZ3MyLCByZXNwb25zZSwgcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YTIgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMjI7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmdzMyA9IG1vZGVsUmVzcG9uc2UuZW1iZWRkaW5ncztcbiAgICAgICAgICAgICAgY29uc3QgdXNhZ2UyID0gKF9hMjIgPSBtb2RlbFJlc3BvbnNlLnVzYWdlKSAhPSBudWxsID8gX2EyMiA6IHsgdG9rZW5zOiBOYU4gfTtcbiAgICAgICAgICAgICAgZG9FbWJlZFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZylcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MzLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgd2FybmluZ3M6IG1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBtb2RlbFJlc3BvbnNlLnJlc3BvbnNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5nczIsXG4gICAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMixcbiAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MyLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEyLFxuICAgICAgICAgIHJlc3BvbnNlczogW3Jlc3BvbnNlXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlQ2h1bmtzID0gc3BsaXRBcnJheSh2YWx1ZXMsIG1heEVtYmVkZGluZ3NQZXJDYWxsKTtcbiAgICAgIGNvbnN0IGVtYmVkZGluZ3MgPSBbXTtcbiAgICAgIGNvbnN0IHdhcm5pbmdzID0gW107XG4gICAgICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgICAgIGxldCB0b2tlbnMgPSAwO1xuICAgICAgbGV0IHByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICBjb25zdCBwYXJhbGxlbENodW5rcyA9IHNwbGl0QXJyYXkoXG4gICAgICAgIHZhbHVlQ2h1bmtzLFxuICAgICAgICBzdXBwb3J0c1BhcmFsbGVsQ2FsbHMgPyBtYXhQYXJhbGxlbENhbGxzIDogMVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgcGFyYWxsZWxDaHVuayBvZiBwYXJhbGxlbENodW5rcykge1xuICAgICAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgcGFyYWxsZWxDaHVuay5tYXAoKGNodW5rKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcmV0cnkoKCkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNodW5rLm1hcCgodmFsdWUpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKGRvRW1iZWRTcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICB2YXIgX2EyMjtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgICAgICAgICAgICAgICBwcm92aWRlck9wdGlvbnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczIgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgICAgICBjb25zdCB1c2FnZSA9IChfYTIyID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMjIgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MyLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3M6IG1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICBlbWJlZGRpbmdzLnB1c2goLi4ucmVzdWx0LmVtYmVkZGluZ3MpO1xuICAgICAgICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKTtcbiAgICAgICAgICByZXNwb25zZXMucHVzaChyZXN1bHQucmVzcG9uc2UpO1xuICAgICAgICAgIHRva2VucyArPSByZXN1bHQudXNhZ2UudG9rZW5zO1xuICAgICAgICAgIGlmIChyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkge1xuICAgICAgICAgICAgaWYgKCFwcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSB7IC4uLnJlc3VsdC5wcm92aWRlck1ldGFkYXRhIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtwcm92aWRlck5hbWUsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgICAgICByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgLi4uKF9hMjEgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0pICE9IG51bGwgPyBfYTIxIDoge30sXG4gICAgICAgICAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5ncy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnRva2Vuc1wiOiB0b2tlbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgbG9nV2FybmluZ3Moe1xuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZE1hbnlSZXN1bHQoe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIGVtYmVkZGluZ3MsXG4gICAgICAgIHVzYWdlOiB7IHRva2VucyB9LFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2VzXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZE1hbnlSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlcyA9IG9wdGlvbnMudmFsdWVzO1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IG9wdGlvbnMuZW1iZWRkaW5ncztcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLWltYWdlL2dlbmVyYXRlLWltYWdlLnRzXG5pbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5IGFzIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXk0LFxuICB3aXRoVXNlckFnZW50U3VmZml4IGFzIHdpdGhVc2VyQWdlbnRTdWZmaXg1XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlKHtcbiAgbW9kZWw6IG1vZGVsQXJnLFxuICBwcm9tcHQ6IHByb21wdEFyZyxcbiAgbiA9IDEsXG4gIG1heEltYWdlc1BlckNhbGwsXG4gIHNpemUsXG4gIGFzcGVjdFJhdGlvLFxuICBzZWVkLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTIxLCBfYjtcbiAgY29uc3QgbW9kZWwgPSByZXNvbHZlSW1hZ2VNb2RlbChtb2RlbEFyZyk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDUoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCB7IHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0ID0gKF9hMjEgPSBtYXhJbWFnZXNQZXJDYWxsICE9IG51bGwgPyBtYXhJbWFnZXNQZXJDYWxsIDogYXdhaXQgaW52b2tlTW9kZWxNYXhJbWFnZXNQZXJDYWxsKG1vZGVsKSkgIT0gbnVsbCA/IF9hMjEgOiAxO1xuICBjb25zdCBjYWxsQ291bnQgPSBNYXRoLmNlaWwobiAvIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdCk7XG4gIGNvbnN0IGNhbGxJbWFnZUNvdW50cyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IGNhbGxDb3VudCB9LCAoXywgaSkgPT4ge1xuICAgIGlmIChpIDwgY2FsbENvdW50IC0gMSkge1xuICAgICAgcmV0dXJuIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluZGVyID0gbiAlIG1heEltYWdlc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICByZXR1cm4gcmVtYWluZGVyID09PSAwID8gbWF4SW1hZ2VzUGVyQ2FsbFdpdGhEZWZhdWx0IDogcmVtYWluZGVyO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGNhbGxJbWFnZUNvdW50cy5tYXAoXG4gICAgICBhc3luYyAoY2FsbEltYWdlQ291bnQpID0+IHJldHJ5KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBwcm9tcHQsIGZpbGVzLCBtYXNrIH0gPSBub3JtYWxpemVQcm9tcHQocHJvbXB0QXJnKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIHByb21wdCxcbiAgICAgICAgICBmaWxlcyxcbiAgICAgICAgICBtYXNrLFxuICAgICAgICAgIG46IGNhbGxJbWFnZUNvdW50LFxuICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICAgICAgc2VlZCxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyT3B0aW9ucyAhPSBudWxsID8gcHJvdmlkZXJPcHRpb25zIDoge31cbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgIClcbiAgKTtcbiAgY29uc3QgaW1hZ2VzID0gW107XG4gIGNvbnN0IHdhcm5pbmdzID0gW107XG4gIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICBjb25zdCBwcm92aWRlck1ldGFkYXRhID0ge307XG4gIGxldCB0b3RhbFVzYWdlID0ge1xuICAgIGlucHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgb3V0cHV0VG9rZW5zOiB2b2lkIDAsXG4gICAgdG90YWxUb2tlbnM6IHZvaWQgMFxuICB9O1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaW1hZ2VzLnB1c2goXG4gICAgICAuLi5yZXN1bHQuaW1hZ2VzLm1hcChcbiAgICAgICAgKGltYWdlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hMjI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZSh7XG4gICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgIG1lZGlhVHlwZTogKF9hMjIgPSBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgICAgICBkYXRhOiBpbWFnZSxcbiAgICAgICAgICAgICAgc2lnbmF0dXJlczogaW1hZ2VNZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgICAgICB9KSkgIT0gbnVsbCA/IF9hMjIgOiBcImltYWdlL3BuZ1wiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKTtcbiAgICBpZiAocmVzdWx0LnVzYWdlICE9IG51bGwpIHtcbiAgICAgIHRvdGFsVXNhZ2UgPSBhZGRJbWFnZU1vZGVsVXNhZ2UodG90YWxVc2FnZSwgcmVzdWx0LnVzYWdlKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5wcm92aWRlck1ldGFkYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IFtwcm92aWRlck5hbWUsIG1ldGFkYXRhXSBvZiBPYmplY3QuZW50cmllcyhyZXN1bHQucHJvdmlkZXJNZXRhZGF0YSkpIHtcbiAgICAgICAgaWYgKHByb3ZpZGVyTmFtZSA9PT0gXCJnYXRld2F5XCIpIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50RW50cnkgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV07XG4gICAgICAgICAgaWYgKGN1cnJlbnRFbnRyeSAhPSBudWxsICYmIHR5cGVvZiBjdXJyZW50RW50cnkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IHtcbiAgICAgICAgICAgICAgLi4uY3VycmVudEVudHJ5LFxuICAgICAgICAgICAgICAuLi5tZXRhZGF0YVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdID0gbWV0YWRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGltYWdlc1ZhbHVlID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlcztcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbWFnZXNWYWx1ZSkgJiYgaW1hZ2VzVmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlcztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKF9iID0gcHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdKSAhPSBudWxsID8gX2IgOiBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7IGltYWdlczogW10gfTtcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0uaW1hZ2VzLnB1c2goXG4gICAgICAgICAgICAuLi5yZXN1bHQucHJvdmlkZXJNZXRhZGF0YVtwcm92aWRlck5hbWVdLmltYWdlc1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzcG9uc2VzLnB1c2gocmVzdWx0LnJlc3BvbnNlKTtcbiAgfVxuICBsb2dXYXJuaW5ncyh7IHdhcm5pbmdzLCBwcm92aWRlcjogbW9kZWwucHJvdmlkZXIsIG1vZGVsOiBtb2RlbC5tb2RlbElkIH0pO1xuICBpZiAoIWltYWdlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgTm9JbWFnZUdlbmVyYXRlZEVycm9yKHsgcmVzcG9uc2VzIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlSW1hZ2VSZXN1bHQoe1xuICAgIGltYWdlcyxcbiAgICB3YXJuaW5ncyxcbiAgICByZXNwb25zZXMsXG4gICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICB1c2FnZTogdG90YWxVc2FnZVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVJbWFnZVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuaW1hZ2VzID0gb3B0aW9ucy5pbWFnZXM7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gIH1cbiAgZ2V0IGltYWdlKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlc1swXTtcbiAgfVxufTtcbmFzeW5jIGZ1bmN0aW9uIGludm9rZU1vZGVsTWF4SW1hZ2VzUGVyQ2FsbChtb2RlbCkge1xuICBjb25zdCBpc0Z1bmN0aW9uID0gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbCBpbnN0YW5jZW9mIEZ1bmN0aW9uO1xuICBpZiAoIWlzRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbDtcbiAgfVxuICByZXR1cm4gbW9kZWwubWF4SW1hZ2VzUGVyQ2FsbCh7XG4gICAgbW9kZWxJZDogbW9kZWwubW9kZWxJZFxuICB9KTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb21wdChwcm9tcHQpIHtcbiAgaWYgKHR5cGVvZiBwcm9tcHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4geyBwcm9tcHQsIGZpbGVzOiB2b2lkIDAsIG1hc2s6IHZvaWQgMCB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgcHJvbXB0OiBwcm9tcHQudGV4dCxcbiAgICBmaWxlczogcHJvbXB0LmltYWdlcy5tYXAodG9JbWFnZU1vZGVsVjNGaWxlKSxcbiAgICBtYXNrOiBwcm9tcHQubWFzayA/IHRvSW1hZ2VNb2RlbFYzRmlsZShwcm9tcHQubWFzaykgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvSW1hZ2VNb2RlbFYzRmlsZShkYXRhQ29udGVudCkge1xuICBpZiAodHlwZW9mIGRhdGFDb250ZW50ID09PSBcInN0cmluZ1wiICYmIGRhdGFDb250ZW50LnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICB1cmw6IGRhdGFDb250ZW50XG4gICAgfTtcbiAgfVxuICBpZiAodHlwZW9mIGRhdGFDb250ZW50ID09PSBcInN0cmluZ1wiICYmIGRhdGFDb250ZW50LnN0YXJ0c1dpdGgoXCJkYXRhOlwiKSkge1xuICAgIGNvbnN0IHsgbWVkaWFUeXBlOiBkYXRhVXJsTWVkaWFUeXBlLCBiYXNlNjRDb250ZW50IH0gPSBzcGxpdERhdGFVcmwoZGF0YUNvbnRlbnQpO1xuICAgIGlmIChiYXNlNjRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHVpbnQ4RGF0YTIgPSBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NChiYXNlNjRDb250ZW50KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBkYXRhOiB1aW50OERhdGEyLFxuICAgICAgICBtZWRpYVR5cGU6IGRhdGFVcmxNZWRpYVR5cGUgfHwgZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICBkYXRhOiB1aW50OERhdGEyLFxuICAgICAgICAgIHNpZ25hdHVyZXM6IGltYWdlTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgICB9KSB8fCBcImltYWdlL3BuZ1wiXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBjb25zdCB1aW50OERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoZGF0YUNvbnRlbnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgIGRhdGE6IHVpbnQ4RGF0YSxcbiAgICBtZWRpYVR5cGU6IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICBkYXRhOiB1aW50OERhdGEsXG4gICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICB9KSB8fCBcImltYWdlL3BuZ1wiXG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1pbWFnZS9pbmRleC50c1xudmFyIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZUltYWdlID0gZ2VuZXJhdGVJbWFnZTtcblxuLy8gc3JjL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMyxcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4NlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ2VuZXJhdGUtdGV4dC9leHRyYWN0LXJlYXNvbmluZy1jb250ZW50LnRzXG5mdW5jdGlvbiBleHRyYWN0UmVhc29uaW5nQ29udGVudChjb250ZW50KSB7XG4gIGNvbnN0IHBhcnRzID0gY29udGVudC5maWx0ZXIoXG4gICAgKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50eXBlID09PSBcInJlYXNvbmluZ1wiXG4gICk7XG4gIHJldHVybiBwYXJ0cy5sZW5ndGggPT09IDAgPyB2b2lkIDAgOiBwYXJ0cy5tYXAoKGNvbnRlbnQyKSA9PiBjb250ZW50Mi50ZXh0KS5qb2luKFwiXFxuXCIpO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yNCxcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSBhcyBhc1NjaGVtYTQsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzNFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIG5vU2NoZW1hT3V0cHV0U3RyYXRlZ3kgPSB7XG4gIHR5cGU6IFwibm8tc2NoZW1hXCIsXG4gIGpzb25TY2hlbWE6IGFzeW5jICgpID0+IHZvaWQgMCxcbiAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHsgcGFydGlhbDogdmFsdWUsIHRleHREZWx0YSB9IH07XG4gIH0sXG4gIGFzeW5jIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUsIGNvbnRleHQyKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2b2lkIDAgPyB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiTm8gb2JqZWN0IGdlbmVyYXRlZDogcmVzcG9uc2UgZGlkIG5vdCBtYXRjaCBzY2hlbWEuXCIsXG4gICAgICAgIHRleHQ6IGNvbnRleHQyLnRleHQsXG4gICAgICAgIHJlc3BvbnNlOiBjb250ZXh0Mi5yZXNwb25zZSxcbiAgICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgICBmaW5pc2hSZWFzb246IGNvbnRleHQyLmZpbmlzaFJlYXNvblxuICAgICAgfSlcbiAgICB9IDogeyBzdWNjZXNzOiB0cnVlLCB2YWx1ZSB9O1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjMoe1xuICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gbm8tc2NoZW1hIG1vZGVcIlxuICAgIH0pO1xuICB9XG59O1xudmFyIG9iamVjdE91dHB1dFN0cmF0ZWd5ID0gKHNjaGVtYSkgPT4gKHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAganNvblNjaGVtYTogYXN5bmMgKCkgPT4gYXdhaXQgc2NoZW1hLmpzb25TY2hlbWEsXG4gIGFzeW5jIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICBwYXJ0aWFsOiB2YWx1ZSxcbiAgICAgICAgdGV4dERlbHRhXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgYXN5bmMgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlczQoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcjMoe1xuICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gb2JqZWN0IG1vZGVcIlxuICAgIH0pO1xuICB9XG59KTtcbnZhciBhcnJheU91dHB1dFN0cmF0ZWd5ID0gKHNjaGVtYSkgPT4ge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFycmF5IG9mIGVsZW1lbnRzLCBzaW5jZSBtb3N0IExMTXMgd2lsbCBub3RcbiAgICAvLyBiZSBhYmxlIHRvIGdlbmVyYXRlIGFuIGFycmF5IGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBhcnJheXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyBncmFtbWFyLWd1aWRlZCBnZW5lcmF0aW9uXG4gICAganNvblNjaGVtYTogYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgeyAkc2NoZW1hLCAuLi5pdGVtU2NoZW1hIH0gPSBhd2FpdCBzY2hlbWEuanNvblNjaGVtYTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICBlbGVtZW50czogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiBpdGVtU2NoZW1hIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZWQ6IFtcImVsZW1lbnRzXCJdLFxuICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICAgIH07XG4gICAgfSxcbiAgICBhc3luYyB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoe1xuICAgICAgdmFsdWUsXG4gICAgICBsYXRlc3RPYmplY3QsXG4gICAgICBpc0ZpcnN0RGVsdGEsXG4gICAgICBpc0ZpbmFsRGVsdGFcbiAgICB9KSB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYW4gYXJyYXkgb2YgZWxlbWVudHNcIlxuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBpbnB1dEFycmF5ID0gdmFsdWUuZWxlbWVudHM7XG4gICAgICBjb25zdCByZXN1bHRBcnJheSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBpbnB1dEFycmF5W2ldO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzYWZlVmFsaWRhdGVUeXBlczQoeyB2YWx1ZTogZWxlbWVudCwgc2NoZW1hIH0pO1xuICAgICAgICBpZiAoaSA9PT0gaW5wdXRBcnJheS5sZW5ndGggLSAxICYmICFpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRBcnJheS5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaXNoZWRFbGVtZW50Q291bnQgPSAoX2EyMSA9IGxhdGVzdE9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogbGF0ZXN0T2JqZWN0Lmxlbmd0aCkgIT0gbnVsbCA/IF9hMjEgOiAwO1xuICAgICAgbGV0IHRleHREZWx0YSA9IFwiXCI7XG4gICAgICBpZiAoaXNGaXJzdERlbHRhKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIltcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwdWJsaXNoZWRFbGVtZW50Q291bnQgPiAwKSB7XG4gICAgICAgIHRleHREZWx0YSArPSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHRleHREZWx0YSArPSByZXN1bHRBcnJheS5zbGljZShwdWJsaXNoZWRFbGVtZW50Q291bnQpLm1hcCgoZWxlbWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZWxlbWVudCkpLmpvaW4oXCIsXCIpO1xuICAgICAgaWYgKGlzRmluYWxEZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJdXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHBhcnRpYWw6IHJlc3VsdEFycmF5LFxuICAgICAgICAgIHRleHREZWx0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlbGVtZW50c1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpbnB1dEFycmF5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNhZmVWYWxpZGF0ZVR5cGVzNCh7IHZhbHVlOiBlbGVtZW50LCBzY2hlbWEgfSk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogaW5wdXRBcnJheSB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbShvcmlnaW5hbFN0cmVhbSkge1xuICAgICAgbGV0IHB1Ymxpc2hlZEVsZW1lbnRzID0gMDtcbiAgICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgICBvcmlnaW5hbFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5MiA9IGNodW5rLm9iamVjdDtcbiAgICAgICAgICAgICAgICAgIGZvciAoOyBwdWJsaXNoZWRFbGVtZW50cyA8IGFycmF5Mi5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGFycmF5MltwdWJsaXNoZWRFbGVtZW50c10pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVW5zdXBwb3J0ZWQgY2h1bmsgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gIH07XG59O1xudmFyIGVudW1PdXRwdXRTdHJhdGVneSA9IChlbnVtVmFsdWVzKSA9PiB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyByZXN1bHQsIHNpbmNlIG1vc3QgTExNcyB3aWxsIG5vdFxuICAgIC8vIGJlIGFibGUgdG8gZ2VuZXJhdGUgYW4gZW51bSB2YWx1ZSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgZW51bXMgZGlyZWN0bHkgd2hlbiBtb2RlbCBzdXBwb3J0cyB0b3AtbGV2ZWwgZW51bXNcbiAgICBqc29uU2NoZW1hOiBhc3luYyAoKSA9PiAoe1xuICAgICAgJHNjaGVtYTogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJlc3VsdDogeyB0eXBlOiBcInN0cmluZ1wiLCBlbnVtOiBlbnVtVmFsdWVzIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wicmVzdWx0XCJdLFxuICAgICAgYWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlXG4gICAgfSksXG4gICAgYXN5bmMgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6ICd2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgc3RyaW5nIGluIHRoZSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUucmVzdWx0O1xuICAgICAgcmV0dXJuIGVudW1WYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdCB9IDoge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yNCh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZW51bVwiXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0sXG4gICAgYXN5bmMgdmFsaWRhdGVQYXJ0aWFsUmVzdWx0KHsgdmFsdWUsIHRleHREZWx0YSB9KSB7XG4gICAgICBpZiAoIWlzSlNPTk9iamVjdCh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJlc3VsdCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgIGVycm9yOiBuZXcgVHlwZVZhbGlkYXRpb25FcnJvcjQoe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICBjb25zdCBwb3NzaWJsZUVudW1WYWx1ZXMgPSBlbnVtVmFsdWVzLmZpbHRlcihcbiAgICAgICAgKGVudW1WYWx1ZSkgPT4gZW51bVZhbHVlLnN0YXJ0c1dpdGgocmVzdWx0KVxuICAgICAgKTtcbiAgICAgIGlmICh2YWx1ZS5yZXN1bHQubGVuZ3RoID09PSAwIHx8IHBvc3NpYmxlRW51bVZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3I0KHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiB0aGUgZW51bVwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgcGFydGlhbDogcG9zc2libGVFbnVtVmFsdWVzLmxlbmd0aCA+IDEgPyByZXN1bHQgOiBwb3NzaWJsZUVudW1WYWx1ZXNbMF0sXG4gICAgICAgICAgdGV4dERlbHRhXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSxcbiAgICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yMyh7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwiZWxlbWVudCBzdHJlYW1zIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuZnVuY3Rpb24gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICBvdXRwdXQsXG4gIHNjaGVtYSxcbiAgZW51bVZhbHVlc1xufSkge1xuICBzd2l0Y2ggKG91dHB1dCkge1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHJldHVybiBvYmplY3RPdXRwdXRTdHJhdGVneShhc1NjaGVtYTQoc2NoZW1hKSk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYXJyYXlPdXRwdXRTdHJhdGVneShhc1NjaGVtYTQoc2NoZW1hKSk7XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIHJldHVybiBlbnVtT3V0cHV0U3RyYXRlZ3koZW51bVZhbHVlcyk7XG4gICAgY2FzZSBcIm5vLXNjaGVtYVwiOlxuICAgICAgcmV0dXJuIG5vU2NoZW1hT3V0cHV0U3RyYXRlZ3k7XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG91dHB1dDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3V0cHV0OiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3QvcGFyc2UtYW5kLXZhbGlkYXRlLW9iamVjdC1yZXN1bHQudHNcbmltcG9ydCB7IEpTT05QYXJzZUVycm9yIGFzIEpTT05QYXJzZUVycm9yMiwgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT040IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHQocmVzdWx0LCBvdXRwdXRTdHJhdGVneSwgY29udGV4dDIpIHtcbiAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCBzYWZlUGFyc2VKU09ONCh7IHRleHQ6IHJlc3VsdCB9KTtcbiAgaWYgKCFwYXJzZVJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlLlwiLFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yLFxuICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICB9KTtcbiAgfVxuICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgb3V0cHV0U3RyYXRlZ3kudmFsaWRhdGVGaW5hbFJlc3VsdChcbiAgICBwYXJzZVJlc3VsdC52YWx1ZSxcbiAgICB7XG4gICAgICB0ZXh0OiByZXN1bHQsXG4gICAgICByZXNwb25zZTogY29udGV4dDIucmVzcG9uc2UsXG4gICAgICB1c2FnZTogY29udGV4dDIudXNhZ2VcbiAgICB9XG4gICk7XG4gIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogXCJObyBvYmplY3QgZ2VuZXJhdGVkOiByZXNwb25zZSBkaWQgbm90IG1hdGNoIHNjaGVtYS5cIixcbiAgICAgIGNhdXNlOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yLFxuICAgICAgdGV4dDogcmVzdWx0LFxuICAgICAgcmVzcG9uc2U6IGNvbnRleHQyLnJlc3BvbnNlLFxuICAgICAgdXNhZ2U6IGNvbnRleHQyLnVzYWdlLFxuICAgICAgZmluaXNoUmVhc29uOiBjb250ZXh0Mi5maW5pc2hSZWFzb25cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdC52YWx1ZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyKHJlc3VsdCwgb3V0cHV0U3RyYXRlZ3ksIHJlcGFpclRleHQsIGNvbnRleHQyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHQocmVzdWx0LCBvdXRwdXRTdHJhdGVneSwgY29udGV4dDIpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChyZXBhaXJUZXh0ICE9IG51bGwgJiYgTm9PYmplY3RHZW5lcmF0ZWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSAmJiAoSlNPTlBhcnNlRXJyb3IyLmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3I1LmlzSW5zdGFuY2UoZXJyb3IuY2F1c2UpKSkge1xuICAgICAgY29uc3QgcmVwYWlyZWRUZXh0ID0gYXdhaXQgcmVwYWlyVGV4dCh7XG4gICAgICAgIHRleHQ6IHJlc3VsdCxcbiAgICAgICAgZXJyb3I6IGVycm9yLmNhdXNlXG4gICAgICB9KTtcbiAgICAgIGlmIChyZXBhaXJlZFRleHQgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdChcbiAgICAgICAgcmVwYWlyZWRUZXh0LFxuICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgY29udGV4dDJcbiAgICAgICk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3QvdmFsaWRhdGUtb2JqZWN0LWdlbmVyYXRpb24taW5wdXQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIGlmIChvdXRwdXQgIT0gbnVsbCAmJiBvdXRwdXQgIT09IFwib2JqZWN0XCIgJiYgb3V0cHV0ICE9PSBcImFycmF5XCIgJiYgb3V0cHV0ICE9PSBcImVudW1cIiAmJiBvdXRwdXQgIT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm91dHB1dFwiLFxuICAgICAgdmFsdWU6IG91dHB1dCxcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBvdXRwdXQgdHlwZS5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChvdXRwdXQgPT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyByZXF1aXJlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiRWxlbWVudCBzY2hlbWEgaXMgcmVxdWlyZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImVudW1cIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIHJlcXVpcmVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW51bVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMyA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7IHByZWZpeDogXCJhaW9ialwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlT2JqZWN0KG9wdGlvbnMpIHtcbiAgY29uc3Qge1xuICAgIG1vZGVsOiBtb2RlbEFyZyxcbiAgICBvdXRwdXQgPSBcIm9iamVjdFwiLFxuICAgIHN5c3RlbSxcbiAgICBwcm9tcHQsXG4gICAgbWVzc2FnZXMsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBoZWFkZXJzLFxuICAgIGV4cGVyaW1lbnRhbF9yZXBhaXJUZXh0OiByZXBhaXJUZXh0LFxuICAgIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgICBleHBlcmltZW50YWxfZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgX2ludGVybmFsOiB7XG4gICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IG9yaWdpbmFsR2VuZXJhdGVJZDMsXG4gICAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gICAgfSA9IHt9LFxuICAgIC4uLnNldHRpbmdzXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBtb2RlbCA9IHJlc29sdmVMYW5ndWFnZU1vZGVsKG1vZGVsQXJnKTtcbiAgY29uc3QgZW51bVZhbHVlcyA9IFwiZW51bVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmVudW0gOiB2b2lkIDA7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHNjaGVtYU5hbWVcbiAgfSA9IFwic2NoZW1hXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMgOiB7fTtcbiAgdmFsaWRhdGVPYmplY3RHZW5lcmF0aW9uSW5wdXQoe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3QgeyBtYXhSZXRyaWVzLCByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IG91dHB1dFN0cmF0ZWd5ID0gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg2KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnM6IGhlYWRlcnNXaXRoVXNlckFnZW50LFxuICAgIHNldHRpbmdzOiB7IC4uLmNhbGxTZXR0aW5ncywgbWF4UmV0cmllcyB9XG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgY29uc3QganNvblNjaGVtYTIgPSBhd2FpdCBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlY29yZFNwYW4oe1xuICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgfSksXG4gICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgIFwiYWkucHJvbXB0XCI6IHtcbiAgICAgICAgICAgIGlucHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJhaS5zY2hlbWFcIjoganNvblNjaGVtYTIgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGpzb25TY2hlbWEyKSB9IDogdm9pZCAwLFxuICAgICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5kZXNjcmlwdGlvblwiOiBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICAgICAgICBcImFpLnNldHRpbmdzLm91dHB1dFwiOiBvdXRwdXRTdHJhdGVneS50eXBlXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgdHJhY2VyLFxuICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgIHZhciBfYTIxO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgdXNhZ2U7XG4gICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcmVxdWVzdDtcbiAgICAgICAgbGV0IHJlc3VsdFByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgIGxldCByZWFzb25pbmc7XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IGF3YWl0IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICBzeXN0ZW0sXG4gICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgIHN1cHBvcnRlZFVybHM6IGF3YWl0IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkMlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVPYmplY3QuZG9HZW5lcmF0ZVwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnN5c3RlbVwiOiBtb2RlbC5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBjYWxsU2V0dGluZ3MuZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogY2FsbFNldHRpbmdzLm1heE91dHB1dFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IGNhbGxTZXR0aW5ncy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IGNhbGxTZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogY2FsbFNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTIyLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICAgIHNjaGVtYToganNvblNjaGVtYTIsXG4gICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzV2l0aFVzZXJBZ2VudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2IgPSAoX2EyMiA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIyLmlkKSAhPSBudWxsID8gX2IgOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9kID0gKF9jID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kIDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2YgPSAoX2UgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2UubW9kZWxJZCkgIT0gbnVsbCA/IF9mIDogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiAoX2cgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2cuaGVhZGVycyxcbiAgICAgICAgICAgICAgICBib2R5OiAoX2ggPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2guYm9keVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBjb25zdCB0ZXh0MiA9IGV4dHJhY3RUZXh0Q29udGVudChyZXN1bHQyLmNvbnRlbnQpO1xuICAgICAgICAgICAgICBjb25zdCByZWFzb25pbmcyID0gZXh0cmFjdFJlYXNvbmluZ0NvbnRlbnQocmVzdWx0Mi5jb250ZW50KTtcbiAgICAgICAgICAgICAgaWYgKHRleHQyID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcih7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIG9iamVjdCBnZW5lcmF0ZWQ6IHRoZSBtb2RlbCBkaWQgbm90IHJldHVybiBhIHJlc3BvbnNlLlwiLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgICAgICAgICAgIHVzYWdlOiBhc0xhbmd1YWdlTW9kZWxVc2FnZShyZXN1bHQyLnVzYWdlKSxcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0Mi5maW5pc2hSZWFzb24udW5pZmllZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHJlc3VsdDIuZmluaXNoUmVhc29uLnVuaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHsgb3V0cHV0OiAoKSA9PiB0ZXh0MiB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Mi5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogcmVzdWx0Mi51c2FnZS5pbnB1dFRva2Vucy50b3RhbCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHJlc3VsdDIudXNhZ2Uub3V0cHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQyLmZpbmlzaFJlYXNvbi51bmlmaWVkXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmlucHV0VG9rZW5zLnRvdGFsLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2Uub3V0cHV0VG9rZW5zLnRvdGFsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5yZXN1bHQyLFxuICAgICAgICAgICAgICAgIG9iamVjdFRleHQ6IHRleHQyLFxuICAgICAgICAgICAgICAgIHJlYXNvbmluZzogcmVhc29uaW5nMixcbiAgICAgICAgICAgICAgICByZXNwb25zZURhdGFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQgPSBnZW5lcmF0ZVJlc3VsdC5vYmplY3RUZXh0O1xuICAgICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb24udW5pZmllZDtcbiAgICAgICAgdXNhZ2UgPSBhc0xhbmd1YWdlTW9kZWxVc2FnZShnZW5lcmF0ZVJlc3VsdC51c2FnZSk7XG4gICAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICAgIHJlc3VsdFByb3ZpZGVyTWV0YWRhdGEgPSBnZW5lcmF0ZVJlc3VsdC5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICByZXF1ZXN0ID0gKF9hMjEgPSBnZW5lcmF0ZVJlc3VsdC5yZXF1ZXN0KSAhPSBudWxsID8gX2EyMSA6IHt9O1xuICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJlc3BvbnNlRGF0YTtcbiAgICAgICAgcmVhc29uaW5nID0gZ2VuZXJhdGVSZXN1bHQucmVhc29uaW5nO1xuICAgICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgIG1vZGVsOiBtb2RlbC5tb2RlbElkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvYmplY3QyID0gYXdhaXQgcGFyc2VBbmRWYWxpZGF0ZU9iamVjdFJlc3VsdFdpdGhSZXBhaXIoXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICAgIHJlcGFpclRleHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvblxuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2Uub2JqZWN0XCI6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVwiOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICByZXN1bHRQcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIC8vIFRPRE8gcmVuYW1lIHRlbGVtZXRyeSBhdHRyaWJ1dGVzIHRvIGlucHV0VG9rZW5zIGFuZCBvdXRwdXRUb2tlbnNcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogdXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiB1c2FnZS5vdXRwdXRUb2tlbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZU9iamVjdFJlc3VsdCh7XG4gICAgICAgICAgb2JqZWN0OiBvYmplY3QyLFxuICAgICAgICAgIHJlYXNvbmluZyxcbiAgICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2UsXG4gICAgICAgICAgd2FybmluZ3MsXG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHRQcm92aWRlck1ldGFkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IHdyYXBHYXRld2F5RXJyb3IoZXJyb3IpO1xuICB9XG59XG52YXIgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vYmplY3QgPSBvcHRpb25zLm9iamVjdDtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5yZWFzb25pbmcgPSBvcHRpb25zLnJlYXNvbmluZztcbiAgfVxuICB0b0pzb25SZXNwb25zZShpbml0KSB7XG4gICAgdmFyIF9hMjE7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0aGlzLm9iamVjdCksIHtcbiAgICAgIHN0YXR1czogKF9hMjEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMjEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlSGVhZGVycyhpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMsIHtcbiAgICAgICAgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuaW1wb3J0IHtcbiAgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3I0LFxuICBEZWxheWVkUHJvbWlzZSBhcyBEZWxheWVkUHJvbWlzZTJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3V0aWwvY29zaW5lLXNpbWlsYXJpdHkudHNcbmZ1bmN0aW9uIGNvc2luZVNpbWlsYXJpdHkodmVjdG9yMSwgdmVjdG9yMikge1xuICBpZiAodmVjdG9yMS5sZW5ndGggIT09IHZlY3RvcjIubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJ2ZWN0b3IxLHZlY3RvcjJcIixcbiAgICAgIHZhbHVlOiB7IHZlY3RvcjFMZW5ndGg6IHZlY3RvcjEubGVuZ3RoLCB2ZWN0b3IyTGVuZ3RoOiB2ZWN0b3IyLmxlbmd0aCB9LFxuICAgICAgbWVzc2FnZTogYFZlY3RvcnMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aGBcbiAgICB9KTtcbiAgfVxuICBjb25zdCBuID0gdmVjdG9yMS5sZW5ndGg7XG4gIGlmIChuID09PSAwKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IG1hZ25pdHVkZVNxdWFyZWQxID0gMDtcbiAgbGV0IG1hZ25pdHVkZVNxdWFyZWQyID0gMDtcbiAgbGV0IGRvdFByb2R1Y3QgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGNvbnN0IHZhbHVlMSA9IHZlY3RvcjFbaV07XG4gICAgY29uc3QgdmFsdWUyID0gdmVjdG9yMltpXTtcbiAgICBtYWduaXR1ZGVTcXVhcmVkMSArPSB2YWx1ZTEgKiB2YWx1ZTE7XG4gICAgbWFnbml0dWRlU3F1YXJlZDIgKz0gdmFsdWUyICogdmFsdWUyO1xuICAgIGRvdFByb2R1Y3QgKz0gdmFsdWUxICogdmFsdWUyO1xuICB9XG4gIHJldHVybiBtYWduaXR1ZGVTcXVhcmVkMSA9PT0gMCB8fCBtYWduaXR1ZGVTcXVhcmVkMiA9PT0gMCA/IDAgOiBkb3RQcm9kdWN0IC8gKE1hdGguc3FydChtYWduaXR1ZGVTcXVhcmVkMSkgKiBNYXRoLnNxcnQobWFnbml0dWRlU3F1YXJlZDIpKTtcbn1cblxuLy8gc3JjL3V0aWwvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldFRleHRGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gIGNvbnN0IG1lZGlhVHlwZSA9IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdO1xuICBpZiAobWVkaWFUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIFVSTCBmb3JtYXRcIik7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmF0b2IoYmFzZTY0Q29udGVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBkZWNvZGluZyBkYXRhIFVSTGApO1xuICB9XG59XG5cbi8vIHNyYy91dGlsL2lzLWRlZXAtZXF1YWwtZGF0YS50c1xuZnVuY3Rpb24gaXNEZWVwRXF1YWxEYXRhKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEgPT09IG9iajIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxIGluc3RhbmNlb2YgRGF0ZSAmJiBvYmoyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqMSkpIHtcbiAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtpXSwgb2JqMltpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtrZXldLCBvYmoyW2tleV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvdXRpbC9zZXJpYWwtam9iLWV4ZWN1dG9yLnRzXG52YXIgU2VyaWFsSm9iRXhlY3V0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB0aGlzLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NRdWV1ZSgpIHtcbiAgICBpZiAodGhpcy5pc1Byb2Nlc3NpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgIHdoaWxlICh0aGlzLnF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIGF3YWl0IHRoaXMucXVldWVbMF0oKTtcbiAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICB9XG4gICAgdGhpcy5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICBhc3luYyBydW4oam9iKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlMywgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IGpvYigpO1xuICAgICAgICAgIHJlc29sdmUzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2b2lkIHRoaXMucHJvY2Vzc1F1ZXVlKCk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHNyYy91dGlsL3NpbXVsYXRlLXJlYWRhYmxlLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgZGVsYXlGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5mdW5jdGlvbiBzaW11bGF0ZVJlYWRhYmxlU3RyZWFtKHtcbiAgY2h1bmtzLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMCxcbiAgY2h1bmtEZWxheUluTXMgPSAwLFxuICBfaW50ZXJuYWxcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIGNvbnN0IGRlbGF5MiA9IChfYTIxID0gX2ludGVybmFsID09IG51bGwgPyB2b2lkIDAgOiBfaW50ZXJuYWwuZGVsYXkpICE9IG51bGwgPyBfYTIxIDogZGVsYXlGdW5jdGlvbjtcbiAgbGV0IGluZGV4ID0gMDtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoaW5kZXggPCBjaHVua3MubGVuZ3RoKSB7XG4gICAgICAgIGF3YWl0IGRlbGF5MihpbmRleCA9PT0gMCA/IGluaXRpYWxEZWxheUluTXMgOiBjaHVua0RlbGF5SW5Ncyk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVua3NbaW5kZXgrK10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDQgPSBjcmVhdGVJZEdlbmVyYXRvcjQoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5mdW5jdGlvbiBzdHJlYW1PYmplY3Qob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbW9kZWwsXG4gICAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIG1heFJldHJpZXMsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgaGVhZGVycyxcbiAgICBleHBlcmltZW50YWxfcmVwYWlyVGV4dDogcmVwYWlyVGV4dCxcbiAgICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gICAgZXhwZXJpbWVudGFsX2Rvd25sb2FkOiBkb3dubG9hZDIsXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIG9uRXJyb3IgPSAoeyBlcnJvciB9KSA9PiB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9LFxuICAgIG9uRmluaXNoLFxuICAgIF9pbnRlcm5hbDoge1xuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBvcmlnaW5hbEdlbmVyYXRlSWQ0LFxuICAgICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgIG5vdzogbm93MiA9IG5vd1xuICAgIH0gPSB7fSxcbiAgICAuLi5zZXR0aW5nc1xuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgZW51bVZhbHVlcyA9IFwiZW51bVwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5lbnVtID8gb3B0aW9ucy5lbnVtIDogdm9pZCAwO1xuICBjb25zdCB7XG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgICBzY2hlbWFOYW1lXG4gIH0gPSBcInNjaGVtYVwiIGluIG9wdGlvbnMgPyBvcHRpb25zIDoge307XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIGNvbnN0IG91dHB1dFN0cmF0ZWd5ID0gZ2V0T3V0cHV0U3RyYXRlZ3koe1xuICAgIG91dHB1dCxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIGVudW1WYWx1ZXNcbiAgfSk7XG4gIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3MsXG4gICAgbWF4UmV0cmllcyxcbiAgICBhYm9ydFNpZ25hbCxcbiAgICBvdXRwdXRTdHJhdGVneSxcbiAgICBzeXN0ZW0sXG4gICAgcHJvbXB0LFxuICAgIG1lc3NhZ2VzLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgcHJvdmlkZXJPcHRpb25zLFxuICAgIHJlcGFpclRleHQsXG4gICAgb25FcnJvcixcbiAgICBvbkZpbmlzaCxcbiAgICBkb3dubG9hZDogZG93bmxvYWQyLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIG5vdzogbm93MlxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWw6IG1vZGVsQXJnLFxuICAgIGhlYWRlcnMsXG4gICAgdGVsZW1ldHJ5LFxuICAgIHNldHRpbmdzLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWwsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgc3lzdGVtLFxuICAgIHByb21wdCxcbiAgICBtZXNzYWdlcyxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uLFxuICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICByZXBhaXJUZXh0LFxuICAgIG9uRXJyb3IsXG4gICAgb25GaW5pc2gsXG4gICAgZG93bmxvYWQ6IGRvd25sb2FkMixcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgICBjdXJyZW50RGF0ZSxcbiAgICBub3c6IG5vdzJcbiAgfSkge1xuICAgIHRoaXMuX29iamVjdCA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl91c2FnZSA9IG5ldyBEZWxheWVkUHJvbWlzZTIoKTtcbiAgICB0aGlzLl9wcm92aWRlck1ldGFkYXRhID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3dhcm5pbmdzID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIHRoaXMuX3JlcXVlc3QgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSBuZXcgRGVsYXllZFByb21pc2UyKCk7XG4gICAgdGhpcy5fZmluaXNoUmVhc29uID0gbmV3IERlbGF5ZWRQcm9taXNlMigpO1xuICAgIGNvbnN0IG1vZGVsID0gcmVzb2x2ZUxhbmd1YWdlTW9kZWwobW9kZWxBcmcpO1xuICAgIGNvbnN0IHsgbWF4UmV0cmllcywgcmV0cnkgfSA9IHByZXBhcmVSZXRyaWVzKHtcbiAgICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IGNhbGxTZXR0aW5ncyA9IHByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgbW9kZWwsXG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBoZWFkZXJzLFxuICAgICAgc2V0dGluZ3M6IHsgLi4uY2FsbFNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgICB9KTtcbiAgICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBjb25zdCBzdGl0Y2hhYmxlU3RyZWFtID0gY3JlYXRlU3RpdGNoYWJsZVN0cmVhbSgpO1xuICAgIGNvbnN0IGV2ZW50UHJvY2Vzc29yID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIG9uRXJyb3IoeyBlcnJvcjogd3JhcEdhdGV3YXlFcnJvcihjaHVuay5lcnJvcikgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmJhc2VTdHJlYW0gPSBzdGl0Y2hhYmxlU3RyZWFtLnN0cmVhbS5waXBlVGhyb3VnaChldmVudFByb2Nlc3Nvcik7XG4gICAgcmVjb3JkU3Bhbih7XG4gICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdFwiLFxuICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5zdHJlYW1PYmplY3RcIixcbiAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiYWkuc2NoZW1hXCI6IHtcbiAgICAgICAgICAgIGlucHV0OiBhc3luYyAoKSA9PiBKU09OLnN0cmluZ2lmeShhd2FpdCBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImFpLnNjaGVtYS5uYW1lXCI6IHNjaGVtYU5hbWUsXG4gICAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgICAgXCJhaS5zZXR0aW5ncy5vdXRwdXRcIjogb3V0cHV0U3RyYXRlZ3kudHlwZVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRyYWNlcixcbiAgICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gYXdhaXQgc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgIHN5c3RlbSxcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbWVzc2FnZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgIHJlc3BvbnNlRm9ybWF0OiB7XG4gICAgICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIHNjaGVtYTogYXdhaXQgb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSgpLFxuICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvblxuICAgICAgICAgIH0sXG4gICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDogc3RhbmRhcmRpemVkUHJvbXB0LFxuICAgICAgICAgICAgc3VwcG9ydGVkVXJsczogYXdhaXQgbW9kZWwuc3VwcG9ydGVkVXJscyxcbiAgICAgICAgICAgIGRvd25sb2FkOiBkb3dubG9hZDJcbiAgICAgICAgICB9KSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnMsXG4gICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBpbmNsdWRlUmF3Q2h1bmtzOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmRlbHRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJzdHJlYW0tc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHJlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgICAgZG9TdHJlYW1TcGFuLFxuICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1PYmplY3QuZG9TdHJlYW1cIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gc3RyaW5naWZ5Rm9yVGVsZW1ldHJ5KGNhbGxPcHRpb25zLnByb21wdClcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QuZnJlcXVlbmN5X3BlbmFsdHlcIjogY2FsbFNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IGNhbGxTZXR0aW5ncy5tYXhPdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IGNhbGxTZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50ZW1wZXJhdHVyZVwiOiBjYWxsU2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBjYWxsU2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IGNhbGxTZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBub3cyKCksXG4gICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjogZG9TdHJlYW1TcGFuMixcbiAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucylcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgc2VsZi5fcmVxdWVzdC5yZXNvbHZlKHJlcXVlc3QgIT0gbnVsbCA/IHJlcXVlc3QgOiB7fSk7XG4gICAgICAgIGxldCB3YXJuaW5ncztcbiAgICAgICAgbGV0IHVzYWdlID0gY3JlYXRlTnVsbExhbmd1YWdlTW9kZWxVc2FnZSgpO1xuICAgICAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgICAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgbGV0IG9iamVjdDI7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgICBsZXQgZnVsbFJlc3BvbnNlID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgIHRpbWVzdGFtcDogY3VycmVudERhdGUoKSxcbiAgICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkXG4gICAgICAgIH07XG4gICAgICAgIGxldCBsYXRlc3RPYmplY3RKc29uID0gdm9pZCAwO1xuICAgICAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgICAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzRmlyc3REZWx0YSA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKS5waXBlVGhyb3VnaChcbiAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB2YXIgX2EyMSwgX2IsIF9jO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcIm9iamVjdFwiICYmIGNodW5rLnR5cGUgPT09IFwic3RyZWFtLXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5ncyA9IGNodW5rLndhcm5pbmdzO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaXNGaXJzdENodW5rKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5hZGRFdmVudChcImFpLnN0cmVhbS5maXJzdENodW5rXCIsIHtcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IGF3YWl0IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE9iamVjdEpzb24gIT09IHZvaWQgMCAmJiAhaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdEpzb24sIGN1cnJlbnRPYmplY3RKc29uKSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlUGFydGlhbFJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhLFxuICAgICAgICAgICAgICAgICAgICBsYXRlc3RPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICAgICAgaXNGaW5hbERlbHRhOiBwYXJzZVN0YXRlID09PSBcInN1Y2Nlc3NmdWwtcGFyc2VcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEoXG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsXG4gICAgICAgICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdEpzb24gPSBjdXJyZW50T2JqZWN0SnNvbjtcbiAgICAgICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gdmFsaWRhdGlvblJlc3VsdC52YWx1ZS5wYXJ0aWFsO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgb2JqZWN0OiBsYXRlc3RPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERlbHRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICAgICAgZnVsbFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogKF9hMjEgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMjEgOiBmdWxsUmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogKF9iID0gY2h1bmsudGltZXN0YW1wKSAhPSBudWxsID8gX2IgOiBmdWxsUmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2MgPSBjaHVuay5tb2RlbElkKSAhPSBudWxsID8gX2MgOiBmdWxsUmVzcG9uc2UubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlmICh0ZXh0RGVsdGEgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsIHRleHREZWx0YSB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbiA9IGNodW5rLmZpbmlzaFJlYXNvbi51bmlmaWVkO1xuICAgICAgICAgICAgICAgICAgdXNhZ2UgPSBhc0xhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNodW5rLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbi51bmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGZ1bGxSZXNwb25zZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBzZWxmLl91c2FnZS5yZXNvbHZlKHVzYWdlKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3Byb3ZpZGVyTWV0YWRhdGEucmVzb2x2ZShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgICAgIHNlbGYuX3dhcm5pbmdzLnJlc29sdmUod2FybmluZ3MpO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fcmVzcG9uc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgc2VsZi5fZmluaXNoUmVhc29uLnJlc29sdmUoZmluaXNoUmVhc29uICE9IG51bGwgPyBmaW5pc2hSZWFzb24gOiBcIm90aGVyXCIpO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0MiA9IGF3YWl0IHBhcnNlQW5kVmFsaWRhdGVPYmplY3RSZXN1bHRXaXRoUmVwYWlyKFxuICAgICAgICAgICAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRTdHJhdGVneSxcbiAgICAgICAgICAgICAgICAgICAgICByZXBhaXJUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBmdWxsUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvblxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2JqZWN0LnJlc29sdmUob2JqZWN0Mik7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fb2JqZWN0LnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gaW52b2tlIG9uRmluaXNoIGNhbGxiYWNrIGFuZCByZXNvbHZlIHRvb2xSZXN1bHRzIHByb21pc2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGFib3V0IHRvIGNsb3NlOlxuICAgICAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbmFsVXNhZ2UgPSB1c2FnZSAhPSBudWxsID8gdXNhZ2UgOiB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgYXdhaXQgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmlkXCI6IGZ1bGxSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IGZ1bGxSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGltZXN0YW1wXCI6IGZ1bGxSZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkocHJvdmlkZXJNZXRhZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5pbnB1dFRva2Vuc1wiOiBmaW5hbFVzYWdlLmlucHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2Uub3V0cHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2Uub3V0cHV0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG90YWxUb2tlbnNcIjogZmluYWxVc2FnZS50b3RhbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLnJlYXNvbmluZ1Rva2Vuc1wiOiBmaW5hbFVzYWdlLnJlYXNvbmluZ1Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNhY2hlZElucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmZpbmlzaF9yZWFzb25zXCI6IFtmaW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IGZ1bGxSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiBmdWxsUmVzcG9uc2UubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5pbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2Uub3V0cHV0VG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmlucHV0VG9rZW5zXCI6IGZpbmFsVXNhZ2UuaW5wdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5vdXRwdXRUb2tlbnNcIjogZmluYWxVc2FnZS5vdXRwdXRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b3RhbFRva2Vuc1wiOiBmaW5hbFVzYWdlLnRvdGFsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucmVhc29uaW5nVG9rZW5zXCI6IGZpbmFsVXNhZ2UucmVhc29uaW5nVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY2FjaGVkSW5wdXRUb2tlbnNcIjogZmluYWxVc2FnZS5jYWNoZWRJbnB1dFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdDIpXG4gICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnByb3ZpZGVyTWV0YWRhdGFcIjogSlNPTi5zdHJpbmdpZnkocHJvdmlkZXJNZXRhZGF0YSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGF3YWl0IChvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2goe1xuICAgICAgICAgICAgICAgICAgdXNhZ2U6IGZpbmFsVXNhZ2UsXG4gICAgICAgICAgICAgICAgICBvYmplY3Q6IG9iamVjdDIsXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZ1bGxSZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3I6IGVycm9yMiB9KTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKHRyYW5zZm9ybWVkU3RyZWFtKTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgIHN0aXRjaGFibGVTdHJlYW0uYWRkU3RyZWFtKFxuICAgICAgICBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwiZXJyb3JcIiwgZXJyb3IgfSk7XG4gICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHN0aXRjaGFibGVTdHJlYW0uY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLm91dHB1dFN0cmF0ZWd5ID0gb3V0cHV0U3RyYXRlZ3k7XG4gIH1cbiAgZ2V0IG9iamVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fb2JqZWN0LnByb21pc2U7XG4gIH1cbiAgZ2V0IHVzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl91c2FnZS5wcm9taXNlO1xuICB9XG4gIGdldCBwcm92aWRlck1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm92aWRlck1ldGFkYXRhLnByb21pc2U7XG4gIH1cbiAgZ2V0IHdhcm5pbmdzKCkge1xuICAgIHJldHVybiB0aGlzLl93YXJuaW5ncy5wcm9taXNlO1xuICB9XG4gIGdldCByZXF1ZXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0LnByb21pc2U7XG4gIH1cbiAgZ2V0IHJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5wcm9taXNlO1xuICB9XG4gIGdldCBmaW5pc2hSZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaFJlYXNvbi5wcm9taXNlO1xuICB9XG4gIGdldCBwYXJ0aWFsT2JqZWN0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKFxuICAgICAgdGhpcy5iYXNlU3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLm9iamVjdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBnZXQgZWxlbWVudFN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRTdHJhdGVneS5jcmVhdGVFbGVtZW50U3RyZWFtKHRoaXMuYmFzZVN0cmVhbSk7XG4gIH1cbiAgZ2V0IHRleHRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oXG4gICAgICB0aGlzLmJhc2VTdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBjaHVuaztcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMuYmFzZVN0cmVhbSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgdGV4dFN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLFxuICAgICAgLi4uaW5pdFxuICAgIH0pO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dFN0cmVhbVJlc3BvbnNlKHtcbiAgICAgIHRleHRTdHJlYW06IHRoaXMudGV4dFN0cmVhbSxcbiAgICAgIC4uLmluaXRcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXNwZWVjaC9nZW5lcmF0ZS1zcGVlY2gudHNcbmltcG9ydCB7IHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvZ2VuZXJhdGUtc3BlZWNoL2dlbmVyYXRlZC1hdWRpby1maWxlLnRzXG52YXIgRGVmYXVsdEdlbmVyYXRlZEF1ZGlvRmlsZSA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdEdlbmVyYXRlZEZpbGUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZWRpYVR5cGVcbiAgfSkge1xuICAgIHN1cGVyKHsgZGF0YSwgbWVkaWFUeXBlIH0pO1xuICAgIGxldCBmb3JtYXQgPSBcIm1wM1wiO1xuICAgIGlmIChtZWRpYVR5cGUpIHtcbiAgICAgIGNvbnN0IG1lZGlhVHlwZVBhcnRzID0gbWVkaWFUeXBlLnNwbGl0KFwiL1wiKTtcbiAgICAgIGlmIChtZWRpYVR5cGVQYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKG1lZGlhVHlwZSAhPT0gXCJhdWRpby9tcGVnXCIpIHtcbiAgICAgICAgICBmb3JtYXQgPSBtZWRpYVR5cGVQYXJ0c1sxXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkF1ZGlvIGZvcm1hdCBtdXN0IGJlIHByb3ZpZGVkIG9yIGRldGVybWluYWJsZSBmcm9tIG1lZGlhIHR5cGVcIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gIH1cbn07XG5cbi8vIHNyYy9nZW5lcmF0ZS1zcGVlY2gvZ2VuZXJhdGUtc3BlZWNoLnRzXG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0ZVNwZWVjaCh7XG4gIG1vZGVsLFxuICB0ZXh0OiB0ZXh0MixcbiAgdm9pY2UsXG4gIG91dHB1dEZvcm1hdCxcbiAgaW5zdHJ1Y3Rpb25zLFxuICBzcGVlZCxcbiAgbGFuZ3VhZ2UsXG4gIHByb3ZpZGVyT3B0aW9ucyA9IHt9LFxuICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzQXJnLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVyc1xufSkge1xuICB2YXIgX2EyMTtcbiAgY29uc3QgcmVzb2x2ZWRNb2RlbCA9IHJlc29sdmVTcGVlY2hNb2RlbChtb2RlbCk7XG4gIGlmICghcmVzb2x2ZWRNb2RlbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGNvdWxkIG5vdCBiZSByZXNvbHZlZFwiKTtcbiAgfVxuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg3KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICgpID0+IHJlc29sdmVkTW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICB0ZXh0OiB0ZXh0MixcbiAgICAgIHZvaWNlLFxuICAgICAgb3V0cHV0Rm9ybWF0LFxuICAgICAgaW5zdHJ1Y3Rpb25zLFxuICAgICAgc3BlZWQsXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICBwcm92aWRlck9wdGlvbnNcbiAgICB9KVxuICApO1xuICBpZiAoIXJlc3VsdC5hdWRpbyB8fCByZXN1bHQuYXVkaW8ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE5vU3BlZWNoR2VuZXJhdGVkRXJyb3IoeyByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdIH0pO1xuICB9XG4gIGxvZ1dhcm5pbmdzKHtcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHByb3ZpZGVyOiByZXNvbHZlZE1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsOiByZXNvbHZlZE1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIHJldHVybiBuZXcgRGVmYXVsdFNwZWVjaFJlc3VsdCh7XG4gICAgYXVkaW86IG5ldyBEZWZhdWx0R2VuZXJhdGVkQXVkaW9GaWxlKHtcbiAgICAgIGRhdGE6IHJlc3VsdC5hdWRpbyxcbiAgICAgIG1lZGlhVHlwZTogKF9hMjEgPSBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICBkYXRhOiByZXN1bHQuYXVkaW8sXG4gICAgICAgIHNpZ25hdHVyZXM6IGF1ZGlvTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgfSkpICE9IG51bGwgPyBfYTIxIDogXCJhdWRpby9tcDNcIlxuICAgIH0pLFxuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3BlZWNoUmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgdGhpcy5hdWRpbyA9IG9wdGlvbnMuYXVkaW87XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yZXNwb25zZXMgPSBvcHRpb25zLnJlc3BvbnNlcztcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSAoX2EyMSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YSkgIT0gbnVsbCA/IF9hMjEgOiB7fTtcbiAgfVxufTtcblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvcHJ1bmUtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIHBydW5lTWVzc2FnZXMoe1xuICBtZXNzYWdlcyxcbiAgcmVhc29uaW5nID0gXCJub25lXCIsXG4gIHRvb2xDYWxscyA9IFtdLFxuICBlbXB0eU1lc3NhZ2VzID0gXCJyZW1vdmVcIlxufSkge1xuICBpZiAocmVhc29uaW5nID09PSBcImFsbFwiIHx8IHJlYXNvbmluZyA9PT0gXCJiZWZvcmUtbGFzdC1tZXNzYWdlXCIpIHtcbiAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgbWVzc2FnZUluZGV4KSA9PiB7XG4gICAgICBpZiAobWVzc2FnZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8IHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIgfHwgcmVhc29uaW5nID09PSBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIiAmJiBtZXNzYWdlSW5kZXggPT09IG1lc3NhZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwicmVhc29uaW5nXCIpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGlmICh0b29sQ2FsbHMgPT09IFwibm9uZVwiKSB7XG4gICAgdG9vbENhbGxzID0gW107XG4gIH0gZWxzZSBpZiAodG9vbENhbGxzID09PSBcImFsbFwiKSB7XG4gICAgdG9vbENhbGxzID0gW3sgdHlwZTogXCJhbGxcIiB9XTtcbiAgfSBlbHNlIGlmICh0b29sQ2FsbHMgPT09IFwiYmVmb3JlLWxhc3QtbWVzc2FnZVwiKSB7XG4gICAgdG9vbENhbGxzID0gW3sgdHlwZTogXCJiZWZvcmUtbGFzdC1tZXNzYWdlXCIgfV07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHRvb2xDYWxscyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvb2xDYWxscyA9IFt7IHR5cGU6IHRvb2xDYWxscyB9XTtcbiAgfVxuICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIHRvb2xDYWxscykge1xuICAgIGNvbnN0IGtlZXBMYXN0TWVzc2FnZXNDb3VudCA9IHRvb2xDYWxsLnR5cGUgPT09IFwiYWxsXCIgPyB2b2lkIDAgOiB0b29sQ2FsbC50eXBlID09PSBcImJlZm9yZS1sYXN0LW1lc3NhZ2VcIiA/IDEgOiBOdW1iZXIoXG4gICAgICB0b29sQ2FsbC50eXBlLnNsaWNlKFwiYmVmb3JlLWxhc3QtXCIubGVuZ3RoKS5zbGljZSgwLCAtXCItbWVzc2FnZXNcIi5sZW5ndGgpXG4gICAgKTtcbiAgICBjb25zdCBrZXB0VG9vbENhbGxJZHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGNvbnN0IGtlcHRBcHByb3ZhbElkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgaWYgKGtlZXBMYXN0TWVzc2FnZXNDb3VudCAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMuc2xpY2UoLWtlZXBMYXN0TWVzc2FnZXNDb3VudCkpIHtcbiAgICAgICAgaWYgKChtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgfHwgbWVzc2FnZS5yb2xlID09PSBcInRvb2xcIikgJiYgdHlwZW9mIG1lc3NhZ2UuY29udGVudCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAoY29uc3QgcGFydCBvZiBtZXNzYWdlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpIHtcbiAgICAgICAgICAgICAga2VwdFRvb2xDYWxsSWRzLmFkZChwYXJ0LnRvb2xDYWxsSWQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIikge1xuICAgICAgICAgICAgICBrZXB0QXBwcm92YWxJZHMuYWRkKHBhcnQuYXBwcm92YWxJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1lc3NhZ2VzID0gbWVzc2FnZXMubWFwKChtZXNzYWdlLCBtZXNzYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmIChtZXNzYWdlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgJiYgbWVzc2FnZS5yb2xlICE9PSBcInRvb2xcIiB8fCB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiIHx8IGtlZXBMYXN0TWVzc2FnZXNDb3VudCAmJiBtZXNzYWdlSW5kZXggPj0gbWVzc2FnZXMubGVuZ3RoIC0ga2VlcExhc3RNZXNzYWdlc0NvdW50KSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9vbENhbGxJZFRvVG9vbE5hbWUgPSB7fTtcbiAgICAgIGNvbnN0IGFwcHJvdmFsSWRUb1Rvb2xOYW1lID0ge307XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQuZmlsdGVyKChwYXJ0KSA9PiB7XG4gICAgICAgICAgaWYgKHBhcnQudHlwZSAhPT0gXCJ0b29sLWNhbGxcIiAmJiBwYXJ0LnR5cGUgIT09IFwidG9vbC1yZXN1bHRcIiAmJiBwYXJ0LnR5cGUgIT09IFwidG9vbC1hcHByb3ZhbC1yZXF1ZXN0XCIgJiYgcGFydC50eXBlICE9PSBcInRvb2wtYXBwcm92YWwtcmVzcG9uc2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIpIHtcbiAgICAgICAgICAgIHRvb2xDYWxsSWRUb1Rvb2xOYW1lW3BhcnQudG9vbENhbGxJZF0gPSBwYXJ0LnRvb2xOYW1lO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiKSB7XG4gICAgICAgICAgICBhcHByb3ZhbElkVG9Ub29sTmFtZVtwYXJ0LmFwcHJvdmFsSWRdID0gdG9vbENhbGxJZFRvVG9vbE5hbWVbcGFydC50b29sQ2FsbElkXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKChwYXJ0LnR5cGUgPT09IFwidG9vbC1jYWxsXCIgfHwgcGFydC50eXBlID09PSBcInRvb2wtcmVzdWx0XCIpICYmIGtlcHRUb29sQ2FsbElkcy5oYXMocGFydC50b29sQ2FsbElkKSB8fCAocGFydC50eXBlID09PSBcInRvb2wtYXBwcm92YWwtcmVxdWVzdFwiIHx8IHBhcnQudHlwZSA9PT0gXCJ0b29sLWFwcHJvdmFsLXJlc3BvbnNlXCIpICYmIGtlcHRBcHByb3ZhbElkcy5oYXMocGFydC5hcHByb3ZhbElkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0b29sQ2FsbC50b29scyAhPSBudWxsICYmICF0b29sQ2FsbC50b29scy5pbmNsdWRlcyhcbiAgICAgICAgICAgIHBhcnQudHlwZSA9PT0gXCJ0b29sLWNhbGxcIiB8fCBwYXJ0LnR5cGUgPT09IFwidG9vbC1yZXN1bHRcIiA/IHBhcnQudG9vbE5hbWUgOiBhcHByb3ZhbElkVG9Ub29sTmFtZVtwYXJ0LmFwcHJvdmFsSWRdXG4gICAgICAgICAgKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgaWYgKGVtcHR5TWVzc2FnZXMgPT09IFwicmVtb3ZlXCIpIHtcbiAgICBtZXNzYWdlcyA9IG1lc3NhZ2VzLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5jb250ZW50Lmxlbmd0aCA+IDApO1xuICB9XG4gIHJldHVybiBtZXNzYWdlcztcbn1cblxuLy8gc3JjL2dlbmVyYXRlLXRleHQvc21vb3RoLXN0cmVhbS50c1xuaW1wb3J0IHsgZGVsYXkgYXMgb3JpZ2luYWxEZWxheSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciBhcyBJbnZhbGlkQXJndW1lbnRFcnJvcjIgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIENIVU5LSU5HX1JFR0VYUFMgPSB7XG4gIHdvcmQ6IC9cXFMrXFxzKy9tLFxuICBsaW5lOiAvXFxuKy9tXG59O1xuZnVuY3Rpb24gc21vb3RoU3RyZWFtKHtcbiAgZGVsYXlJbk1zID0gMTAsXG4gIGNodW5raW5nID0gXCJ3b3JkXCIsXG4gIF9pbnRlcm5hbDogeyBkZWxheTogZGVsYXkyID0gb3JpZ2luYWxEZWxheSB9ID0ge31cbn0gPSB7fSkge1xuICBsZXQgZGV0ZWN0Q2h1bms7XG4gIGlmIChjaHVua2luZyAhPSBudWxsICYmIHR5cGVvZiBjaHVua2luZyA9PT0gXCJvYmplY3RcIiAmJiBcInNlZ21lbnRcIiBpbiBjaHVua2luZyAmJiB0eXBlb2YgY2h1bmtpbmcuc2VnbWVudCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2VnbWVudGVyID0gY2h1bmtpbmc7XG4gICAgZGV0ZWN0Q2h1bmsgPSAoYnVmZmVyKSA9PiB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHNlZ21lbnRlci5zZWdtZW50KGJ1ZmZlcilbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgY29uc3QgZmlyc3QgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICByZXR1cm4gKGZpcnN0ID09IG51bGwgPyB2b2lkIDAgOiBmaXJzdC5zZWdtZW50KSB8fCBudWxsO1xuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5raW5nID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY2h1bmtpbmcoYnVmZmVyKTtcbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCFtYXRjaC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaHVua2luZyBmdW5jdGlvbiBtdXN0IHJldHVybiBhIG5vbi1lbXB0eSBzdHJpbmcuYCk7XG4gICAgICB9XG4gICAgICBpZiAoIWJ1ZmZlci5zdGFydHNXaXRoKG1hdGNoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENodW5raW5nIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgbWF0Y2ggdGhhdCBpcyBhIHByZWZpeCBvZiB0aGUgYnVmZmVyLiBSZWNlaXZlZDogXCIke21hdGNofVwiIGV4cGVjdGVkIHRvIHN0YXJ0IHdpdGggXCIke2J1ZmZlcn1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNodW5raW5nUmVnZXggPSB0eXBlb2YgY2h1bmtpbmcgPT09IFwic3RyaW5nXCIgPyBDSFVOS0lOR19SRUdFWFBTW2NodW5raW5nXSA6IGNodW5raW5nIGluc3RhbmNlb2YgUmVnRXhwID8gY2h1bmtpbmcgOiB2b2lkIDA7XG4gICAgaWYgKGNodW5raW5nUmVnZXggPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yMih7XG4gICAgICAgIGFyZ3VtZW50OiBcImNodW5raW5nXCIsXG4gICAgICAgIG1lc3NhZ2U6IGBDaHVua2luZyBtdXN0IGJlIFwid29yZFwiLCBcImxpbmVcIiwgYSBSZWdFeHAsIGFuIEludGwuU2VnbWVudGVyLCBvciBhIENodW5rRGV0ZWN0b3IgZnVuY3Rpb24uIFJlY2VpdmVkOiAke2NodW5raW5nfWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZXRlY3RDaHVuayA9IChidWZmZXIpID0+IHtcbiAgICAgIGNvbnN0IG1hdGNoID0gY2h1bmtpbmdSZWdleC5leGVjKGJ1ZmZlcik7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAobWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IG1hdGNoWzBdKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gICAgbGV0IGlkID0gXCJcIjtcbiAgICBsZXQgdHlwZSA9IHZvaWQgMDtcbiAgICBsZXQgcHJvdmlkZXJNZXRhZGF0YSA9IHZvaWQgMDtcbiAgICBmdW5jdGlvbiBmbHVzaEJ1ZmZlcihjb250cm9sbGVyKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDAgJiYgdHlwZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICB0ZXh0OiBidWZmZXIsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgLi4ucHJvdmlkZXJNZXRhZGF0YSAhPSBudWxsID8geyBwcm92aWRlck1ldGFkYXRhIH0gOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgYnVmZmVyID0gXCJcIjtcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlICE9PSBcInRleHQtZGVsdGFcIiAmJiBjaHVuay50eXBlICE9PSBcInJlYXNvbmluZy1kZWx0YVwiKSB7XG4gICAgICAgICAgZmx1c2hCdWZmZXIoY29udHJvbGxlcik7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjaHVuay50eXBlICE9PSB0eXBlIHx8IGNodW5rLmlkICE9PSBpZCkgJiYgYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmbHVzaEJ1ZmZlcihjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIgKz0gY2h1bmsudGV4dDtcbiAgICAgICAgaWQgPSBjaHVuay5pZDtcbiAgICAgICAgdHlwZSA9IGNodW5rLnR5cGU7XG4gICAgICAgIGlmIChjaHVuay5wcm92aWRlck1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhID0gY2h1bmsucHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBkZXRlY3RDaHVuayhidWZmZXIpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZSwgdGV4dDogbWF0Y2gsIGlkIH0pO1xuICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShtYXRjaC5sZW5ndGgpO1xuICAgICAgICAgIGF3YWl0IGRlbGF5MihkZWxheUluTXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS12aWRlby9nZW5lcmF0ZS12aWRlby50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSBhcyBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NSxcbiAgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4OFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuYXN5bmMgZnVuY3Rpb24gZXhwZXJpbWVudGFsX2dlbmVyYXRlVmlkZW8oe1xuICBtb2RlbDogbW9kZWxBcmcsXG4gIHByb21wdDogcHJvbXB0QXJnLFxuICBuID0gMSxcbiAgbWF4VmlkZW9zUGVyQ2FsbCxcbiAgYXNwZWN0UmF0aW8sXG4gIHJlc29sdXRpb24sXG4gIGR1cmF0aW9uLFxuICBmcHMsXG4gIHNlZWQsXG4gIHByb3ZpZGVyT3B0aW9ucyxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIGNvbnN0IG1vZGVsID0gcmVzb2x2ZVZpZGVvTW9kZWwobW9kZWxBcmcpO1xuICBjb25zdCBoZWFkZXJzV2l0aFVzZXJBZ2VudCA9IHdpdGhVc2VyQWdlbnRTdWZmaXg4KFxuICAgIGhlYWRlcnMgIT0gbnVsbCA/IGhlYWRlcnMgOiB7fSxcbiAgICBgYWkvJHtWRVJTSU9OfWBcbiAgKTtcbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IHsgcHJvbXB0LCBpbWFnZSB9ID0gbm9ybWFsaXplUHJvbXB0Mihwcm9tcHRBcmcpO1xuICBjb25zdCBtYXhWaWRlb3NQZXJDYWxsV2l0aERlZmF1bHQgPSAoX2EyMSA9IG1heFZpZGVvc1BlckNhbGwgIT0gbnVsbCA/IG1heFZpZGVvc1BlckNhbGwgOiBhd2FpdCBpbnZva2VNb2RlbE1heFZpZGVvc1BlckNhbGwobW9kZWwpKSAhPSBudWxsID8gX2EyMSA6IDE7XG4gIGNvbnN0IGNhbGxDb3VudCA9IE1hdGguY2VpbChuIC8gbWF4VmlkZW9zUGVyQ2FsbFdpdGhEZWZhdWx0KTtcbiAgY29uc3QgY2FsbFZpZGVvQ291bnRzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY2FsbENvdW50IH0sIChfLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IG4gLSBpbmRleCAqIG1heFZpZGVvc1BlckNhbGxXaXRoRGVmYXVsdDtcbiAgICByZXR1cm4gTWF0aC5taW4ocmVtYWluaW5nLCBtYXhWaWRlb3NQZXJDYWxsV2l0aERlZmF1bHQpO1xuICB9KTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIGNhbGxWaWRlb0NvdW50cy5tYXAoXG4gICAgICBhc3luYyAoY2FsbFZpZGVvQ291bnQpID0+IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgbjogY2FsbFZpZGVvQ291bnQsXG4gICAgICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICAgICAgcmVzb2x1dGlvbixcbiAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICBmcHMsXG4gICAgICAgICAgc2VlZCxcbiAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICBwcm92aWRlck9wdGlvbnM6IHByb3ZpZGVyT3B0aW9ucyAhPSBudWxsID8gcHJvdmlkZXJPcHRpb25zIDoge30sXG4gICAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICApXG4gICk7XG4gIGNvbnN0IHZpZGVvcyA9IFtdO1xuICBjb25zdCB3YXJuaW5ncyA9IFtdO1xuICBjb25zdCByZXNwb25zZXMgPSBbXTtcbiAgY29uc3QgcHJvdmlkZXJNZXRhZGF0YSA9IHt9O1xuICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgZm9yIChjb25zdCB2aWRlb0RhdGEgb2YgcmVzdWx0LnZpZGVvcykge1xuICAgICAgc3dpdGNoICh2aWRlb0RhdGEudHlwZSkge1xuICAgICAgICBjYXNlIFwidXJsXCI6IHtcbiAgICAgICAgICBjb25zdCB7IGRhdGEsIG1lZGlhVHlwZTogZG93bmxvYWRlZE1lZGlhVHlwZSB9ID0gYXdhaXQgZG93bmxvYWQoe1xuICAgICAgICAgICAgdXJsOiBuZXcgVVJMKHZpZGVvRGF0YS51cmwpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgaXNVc2FibGVNZWRpYVR5cGUgPSAodHlwZSkgPT4gISF0eXBlICYmIHR5cGUgIT09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgICAgY29uc3QgbWVkaWFUeXBlID0gaXNVc2FibGVNZWRpYVR5cGUodmlkZW9EYXRhLm1lZGlhVHlwZSkgJiYgdmlkZW9EYXRhLm1lZGlhVHlwZSB8fCBpc1VzYWJsZU1lZGlhVHlwZShkb3dubG9hZGVkTWVkaWFUeXBlKSAmJiBkb3dubG9hZGVkTWVkaWFUeXBlIHx8IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgc2lnbmF0dXJlczogdmlkZW9NZWRpYVR5cGVTaWduYXR1cmVzXG4gICAgICAgICAgfSkgfHwgXCJ2aWRlby9tcDRcIjtcbiAgICAgICAgICB2aWRlb3MucHVzaChcbiAgICAgICAgICAgIG5ldyBEZWZhdWx0R2VuZXJhdGVkRmlsZSh7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIjoge1xuICAgICAgICAgIHZpZGVvcy5wdXNoKFxuICAgICAgICAgICAgbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHtcbiAgICAgICAgICAgICAgZGF0YTogdmlkZW9EYXRhLmRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZTogdmlkZW9EYXRhLm1lZGlhVHlwZSB8fCBcInZpZGVvL21wNFwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJpbmFyeVwiOiB7XG4gICAgICAgICAgY29uc3QgbWVkaWFUeXBlID0gdmlkZW9EYXRhLm1lZGlhVHlwZSB8fCBkZXRlY3RNZWRpYVR5cGUoe1xuICAgICAgICAgICAgZGF0YTogdmlkZW9EYXRhLmRhdGEsXG4gICAgICAgICAgICBzaWduYXR1cmVzOiB2aWRlb01lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgICB9KSB8fCBcInZpZGVvL21wNFwiO1xuICAgICAgICAgIHZpZGVvcy5wdXNoKFxuICAgICAgICAgICAgbmV3IERlZmF1bHRHZW5lcmF0ZWRGaWxlKHtcbiAgICAgICAgICAgICAgZGF0YTogdmlkZW9EYXRhLmRhdGEsXG4gICAgICAgICAgICAgIG1lZGlhVHlwZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHdhcm5pbmdzLnB1c2goLi4ucmVzdWx0Lndhcm5pbmdzKTtcbiAgICByZXNwb25zZXMucHVzaCh7XG4gICAgICB0aW1lc3RhbXA6IHJlc3VsdC5yZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICBtb2RlbElkOiByZXN1bHQucmVzcG9uc2UubW9kZWxJZCxcbiAgICAgIGhlYWRlcnM6IHJlc3VsdC5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0LnByb3ZpZGVyTWV0YWRhdGFcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LnByb3ZpZGVyTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBbcHJvdmlkZXJOYW1lLCBtZXRhZGF0YV0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgICAgIHJlc3VsdC5wcm92aWRlck1ldGFkYXRhXG4gICAgICApKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTWV0YWRhdGEgPSBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV07XG4gICAgICAgIGlmIChleGlzdGluZ01ldGFkYXRhICE9IG51bGwgJiYgdHlwZW9mIGV4aXN0aW5nTWV0YWRhdGEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhW3Byb3ZpZGVyTmFtZV0gPSB7XG4gICAgICAgICAgICAuLi5leGlzdGluZ01ldGFkYXRhLFxuICAgICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChcInZpZGVvc1wiIGluIGV4aXN0aW5nTWV0YWRhdGEgJiYgQXJyYXkuaXNBcnJheShleGlzdGluZ01ldGFkYXRhLnZpZGVvcykgJiYgXCJ2aWRlb3NcIiBpbiBtZXRhZGF0YSAmJiBBcnJheS5pc0FycmF5KG1ldGFkYXRhLnZpZGVvcykpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXS52aWRlb3MgPSBbXG4gICAgICAgICAgICAgIC4uLmV4aXN0aW5nTWV0YWRhdGEudmlkZW9zLFxuICAgICAgICAgICAgICAuLi5tZXRhZGF0YS52aWRlb3NcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGFbcHJvdmlkZXJOYW1lXSA9IG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2aWRlb3MubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IE5vVmlkZW9HZW5lcmF0ZWRFcnJvcih7IHJlc3BvbnNlcyB9KTtcbiAgfVxuICBpZiAod2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgIGxvZ1dhcm5pbmdzKHtcbiAgICAgIHdhcm5pbmdzLFxuICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgbW9kZWw6IG1vZGVsLm1vZGVsSWRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZpZGVvOiB2aWRlb3NbMF0sXG4gICAgdmlkZW9zLFxuICAgIHdhcm5pbmdzLFxuICAgIHJlc3BvbnNlcyxcbiAgICBwcm92aWRlck1ldGFkYXRhXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVQcm9tcHQyKHByb21wdEFyZykge1xuICB2YXIgX2EyMSwgX2I7XG4gIGlmICh0eXBlb2YgcHJvbXB0QXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb21wdDogcHJvbXB0QXJnLFxuICAgICAgaW1hZ2U6IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgbGV0IGltYWdlO1xuICBpZiAocHJvbXB0QXJnLmltYWdlICE9IG51bGwpIHtcbiAgICBjb25zdCBkYXRhQ29udGVudCA9IHByb21wdEFyZy5pbWFnZTtcbiAgICBpZiAodHlwZW9mIGRhdGFDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAoZGF0YUNvbnRlbnQuc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHwgZGF0YUNvbnRlbnQuc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpKSB7XG4gICAgICAgIGltYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwidXJsXCIsXG4gICAgICAgICAgdXJsOiBkYXRhQ29udGVudFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkYXRhQ29udGVudC5zdGFydHNXaXRoKFwiZGF0YTpcIikpIHtcbiAgICAgICAgY29uc3QgeyBtZWRpYVR5cGUsIGJhc2U2NENvbnRlbnQgfSA9IHNwbGl0RGF0YVVybChkYXRhQ29udGVudCk7XG4gICAgICAgIGltYWdlID0ge1xuICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgIG1lZGlhVHlwZTogbWVkaWFUeXBlICE9IG51bGwgPyBtZWRpYVR5cGUgOiBcImltYWdlL3BuZ1wiLFxuICAgICAgICAgIGRhdGE6IGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXk1KGJhc2U2NENvbnRlbnQgIT0gbnVsbCA/IGJhc2U2NENvbnRlbnQgOiBcIlwiKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5NShkYXRhQ29udGVudCk7XG4gICAgICAgIGNvbnN0IG1lZGlhVHlwZSA9IChfYTIxID0gZGV0ZWN0TWVkaWFUeXBlKHtcbiAgICAgICAgICBkYXRhOiBieXRlcyxcbiAgICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgICAgfSkpICE9IG51bGwgPyBfYTIxIDogXCJpbWFnZS9wbmdcIjtcbiAgICAgICAgaW1hZ2UgPSB7XG4gICAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgICAgbWVkaWFUeXBlLFxuICAgICAgICAgIGRhdGE6IGJ5dGVzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhQ29udGVudCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIGNvbnN0IG1lZGlhVHlwZSA9IChfYiA9IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgIGRhdGE6IGRhdGFDb250ZW50LFxuICAgICAgICBzaWduYXR1cmVzOiBpbWFnZU1lZGlhVHlwZVNpZ25hdHVyZXNcbiAgICAgIH0pKSAhPSBudWxsID8gX2IgOiBcImltYWdlL3BuZ1wiO1xuICAgICAgaW1hZ2UgPSB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIGRhdGE6IGRhdGFDb250ZW50XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHByb21wdDogcHJvbXB0QXJnLnRleHQsXG4gICAgaW1hZ2VcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGludm9rZU1vZGVsTWF4VmlkZW9zUGVyQ2FsbChtb2RlbCkge1xuICBpZiAodHlwZW9mIG1vZGVsLm1heFZpZGVvc1BlckNhbGwgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBhd2FpdCBtb2RlbC5tYXhWaWRlb3NQZXJDYWxsKHsgbW9kZWxJZDogbW9kZWwubW9kZWxJZCB9KTtcbiAgfVxuICByZXR1cm4gbW9kZWwubWF4VmlkZW9zUGVyQ2FsbDtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZGVmYXVsdC1lbWJlZGRpbmctc2V0dGluZ3MtbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZGVmYXVsdEVtYmVkZGluZ1NldHRpbmdzTWlkZGxld2FyZSh7XG4gIHNldHRpbmdzXG59KSB7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB0cmFuc2Zvcm1QYXJhbXM6IGFzeW5jICh7IHBhcmFtcyB9KSA9PiB7XG4gICAgICByZXR1cm4gbWVyZ2VPYmplY3RzKHNldHRpbmdzLCBwYXJhbXMpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZGVmYXVsdC1zZXR0aW5ncy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGluZ3NNaWRkbGV3YXJlKHtcbiAgc2V0dGluZ3Ncbn0pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHJldHVybiBtZXJnZU9iamVjdHMoc2V0dGluZ3MsIHBhcmFtcyk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9leHRyYWN0LWpzb24tbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZGVmYXVsdFRyYW5zZm9ybSh0ZXh0Mikge1xuICByZXR1cm4gdGV4dDIucmVwbGFjZSgvXmBgYCg/Ompzb24pP1xccypcXG4/LywgXCJcIikucmVwbGFjZSgvXFxuP2BgYFxccyokLywgXCJcIikudHJpbSgpO1xufVxuZnVuY3Rpb24gZXh0cmFjdEpzb25NaWRkbGV3YXJlKG9wdGlvbnMpIHtcbiAgdmFyIF9hMjE7XG4gIGNvbnN0IHRyYW5zZm9ybSA9IChfYTIxID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy50cmFuc2Zvcm0pICE9IG51bGwgPyBfYTIxIDogZGVmYXVsdFRyYW5zZm9ybTtcbiAgY29uc3QgaGFzQ3VzdG9tVHJhbnNmb3JtID0gKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudHJhbnNmb3JtKSAhPT0gdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgd3JhcEdlbmVyYXRlOiBhc3luYyAoeyBkb0dlbmVyYXRlIH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY29udGVudCwgLi4ucmVzdCB9ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRDb250ZW50ID0gW107XG4gICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudCkge1xuICAgICAgICBpZiAocGFydC50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHBhcnQpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zZm9ybWVkQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAuLi5wYXJ0LFxuICAgICAgICAgIHRleHQ6IHRyYW5zZm9ybShwYXJ0LnRleHQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29udGVudDogdHJhbnNmb3JtZWRDb250ZW50LCAuLi5yZXN0IH07XG4gICAgfSxcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cmVhbSwgLi4ucmVzdCB9ID0gYXdhaXQgZG9TdHJlYW0oKTtcbiAgICAgIGNvbnN0IHRleHRCbG9ja3MgPSB7fTtcbiAgICAgIGNvbnN0IFNVRkZJWF9CVUZGRVJfU0laRSA9IDEyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RyZWFtOiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QmxvY2tzW2NodW5rLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0RXZlbnQ6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gQ3VzdG9tIHRyYW5zZm9ybXMgbmVlZCB0byBidWZmZXIgYWxsIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAgIHBoYXNlOiBoYXNDdXN0b21UcmFuc2Zvcm0gPyBcImJ1ZmZlcmluZ1wiIDogXCJwcmVmaXhcIixcbiAgICAgICAgICAgICAgICAgIGJ1ZmZlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgIHByZWZpeFN0cmlwcGVkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2suYnVmZmVyICs9IGNodW5rLmRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwicHJlZml4XCIpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5idWZmZXIubGVuZ3RoID4gMCAmJiAhYmxvY2suYnVmZmVyLnN0YXJ0c1dpdGgoXCJgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5idWZmZXIuc3RhcnRzV2l0aChcImBgYFwiKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2suYnVmZmVyLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4TWF0Y2ggPSBibG9jay5idWZmZXIubWF0Y2goL15gYGAoPzpqc29uKT9cXHMqXFxuLyk7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgPSBibG9jay5idWZmZXIuc2xpY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeE1hdGNoWzBdLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnByZWZpeFN0cmlwcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShibG9jay5zdGFydEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sucGhhc2UgPSBcInN0cmVhbWluZ1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChibG9jay5idWZmZXIubGVuZ3RoID49IDMgJiYgIWJsb2NrLmJ1ZmZlci5zdGFydHNXaXRoKFwiYGBgXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnBoYXNlID0gXCJzdHJlYW1pbmdcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwic3RyZWFtaW5nXCIgJiYgYmxvY2suYnVmZmVyLmxlbmd0aCA+IFNVRkZJWF9CVUZGRVJfU0laRSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgdG9TdHJlYW0gPSBibG9jay5idWZmZXIuc2xpY2UoMCwgLVNVRkZJWF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgICBibG9jay5idWZmZXIgPSBibG9jay5idWZmZXIuc2xpY2UoLVNVRkZJWF9CVUZGRVJfU0laRSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRleHQtZGVsdGFcIixcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICBkZWx0YTogdG9TdHJlYW1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1lbmRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0gdGV4dEJsb2Nrc1tjaHVuay5pZF07XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGhhc2UgPT09IFwicHJlZml4XCIgfHwgYmxvY2sucGhhc2UgPT09IFwiYnVmZmVyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGJsb2NrLnN0YXJ0RXZlbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IGJsb2NrLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgIGlmIChibG9jay5waGFzZSA9PT0gXCJidWZmZXJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICByZW1haW5pbmcgPSB0cmFuc2Zvcm0ocmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYmxvY2sucHJlZml4U3RyaXBwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nID0gcmVtYWluaW5nLnJlcGxhY2UoL1xcbj9gYGBcXHMqJC8sIFwiXCIpLnRyaW1FbmQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IHRyYW5zZm9ybShyZW1haW5pbmcpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlbWFpbmluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiByZW1haW5pbmdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRleHRCbG9ja3NbY2h1bmsuaWRdO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvdXRpbC9nZXQtcG90ZW50aWFsLXN0YXJ0LWluZGV4LnRzXG5mdW5jdGlvbiBnZXRQb3RlbnRpYWxTdGFydEluZGV4KHRleHQyLCBzZWFyY2hlZFRleHQpIHtcbiAgaWYgKHNlYXJjaGVkVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaXJlY3RJbmRleCA9IHRleHQyLmluZGV4T2Yoc2VhcmNoZWRUZXh0KTtcbiAgaWYgKGRpcmVjdEluZGV4ICE9PSAtMSkge1xuICAgIHJldHVybiBkaXJlY3RJbmRleDtcbiAgfVxuICBmb3IgKGxldCBpID0gdGV4dDIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdWZmaXggPSB0ZXh0Mi5zdWJzdHJpbmcoaSk7XG4gICAgaWYgKHNlYXJjaGVkVGV4dC5zdGFydHNXaXRoKHN1ZmZpeCkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvZXh0cmFjdC1yZWFzb25pbmctbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gZXh0cmFjdFJlYXNvbmluZ01pZGRsZXdhcmUoe1xuICB0YWdOYW1lLFxuICBzZXBhcmF0b3IgPSBcIlxcblwiLFxuICBzdGFydFdpdGhSZWFzb25pbmcgPSBmYWxzZVxufSkge1xuICBjb25zdCBvcGVuaW5nVGFnID0gYDwke3RhZ05hbWV9PmA7XG4gIGNvbnN0IGNsb3NpbmdUYWcgPSBgPC8ke3RhZ05hbWV9PmA7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICB3cmFwR2VuZXJhdGU6IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBjb250ZW50LCAuLi5yZXN0IH0gPSBhd2FpdCBkb0dlbmVyYXRlKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZENvbnRlbnQgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgcGFydCBvZiBjb250ZW50KSB7XG4gICAgICAgIGlmIChwYXJ0LnR5cGUgIT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2gocGFydCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dDIgPSBzdGFydFdpdGhSZWFzb25pbmcgPyBvcGVuaW5nVGFnICsgcGFydC50ZXh0IDogcGFydC50ZXh0O1xuICAgICAgICBjb25zdCByZWdleHAgPSBuZXcgUmVnRXhwKGAke29wZW5pbmdUYWd9KC4qPykke2Nsb3NpbmdUYWd9YCwgXCJnc1wiKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odGV4dDIubWF0Y2hBbGwocmVnZXhwKSk7XG4gICAgICAgIGlmICghbWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1lZENvbnRlbnQucHVzaChwYXJ0KTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWFzb25pbmdUZXh0ID0gbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaFsxXSkuam9pbihzZXBhcmF0b3IpO1xuICAgICAgICBsZXQgdGV4dFdpdGhvdXRSZWFzb25pbmcgPSB0ZXh0MjtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hdGNoZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgY29uc3QgYmVmb3JlTWF0Y2ggPSB0ZXh0V2l0aG91dFJlYXNvbmluZy5zbGljZSgwLCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgY29uc3QgYWZ0ZXJNYXRjaCA9IHRleHRXaXRob3V0UmVhc29uaW5nLnNsaWNlKFxuICAgICAgICAgICAgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICAgIHRleHRXaXRob3V0UmVhc29uaW5nID0gYmVmb3JlTWF0Y2ggKyAoYmVmb3JlTWF0Y2gubGVuZ3RoID4gMCAmJiBhZnRlck1hdGNoLmxlbmd0aCA+IDAgPyBzZXBhcmF0b3IgOiBcIlwiKSArIGFmdGVyTWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nXCIsXG4gICAgICAgICAgdGV4dDogcmVhc29uaW5nVGV4dFxuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNmb3JtZWRDb250ZW50LnB1c2goe1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHRleHQ6IHRleHRXaXRob3V0UmVhc29uaW5nXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgY29udGVudDogdHJhbnNmb3JtZWRDb250ZW50LCAuLi5yZXN0IH07XG4gICAgfSxcbiAgICB3cmFwU3RyZWFtOiBhc3luYyAoeyBkb1N0cmVhbSB9KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cmVhbSwgLi4ucmVzdCB9ID0gYXdhaXQgZG9TdHJlYW0oKTtcbiAgICAgIGNvbnN0IHJlYXNvbmluZ0V4dHJhY3Rpb25zID0ge307XG4gICAgICBsZXQgZGVsYXllZFRleHRTdGFydDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1zdGFydFwiKSB7XG4gICAgICAgICAgICAgICAgZGVsYXllZFRleHRTdGFydCA9IGNodW5rO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWVuZFwiICYmIGRlbGF5ZWRUZXh0U3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGVsYXllZFRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgZGVsYXllZFRleHRTdGFydCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVhc29uaW5nRXh0cmFjdGlvbnNbY2h1bmsuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWFzb25pbmdFeHRyYWN0aW9uc1tjaHVuay5pZF0gPSB7XG4gICAgICAgICAgICAgICAgICBpc0ZpcnN0UmVhc29uaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgaXNGaXJzdFRleHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhZnRlclN3aXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICBpc1JlYXNvbmluZzogc3RhcnRXaXRoUmVhc29uaW5nLFxuICAgICAgICAgICAgICAgICAgYnVmZmVyOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgaWRDb3VudGVyOiAwLFxuICAgICAgICAgICAgICAgICAgdGV4dElkOiBjaHVuay5pZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgYWN0aXZlRXh0cmFjdGlvbiA9IHJlYXNvbmluZ0V4dHJhY3Rpb25zW2NodW5rLmlkXTtcbiAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIgKz0gY2h1bmsuZGVsdGE7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIHB1Ymxpc2godGV4dDIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dDIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gYWN0aXZlRXh0cmFjdGlvbi5hZnRlclN3aXRjaCAmJiAoYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZyA/ICFhY3RpdmVFeHRyYWN0aW9uLmlzRmlyc3RSZWFzb25pbmcgOiAhYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0VGV4dCkgPyBzZXBhcmF0b3IgOiBcIlwiO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgJiYgKGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggfHwgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0UmVhc29uaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgaWQ6IGByZWFzb25pbmctJHthY3RpdmVFeHRyYWN0aW9uLmlkQ291bnRlcn1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgIGRlbHRhOiBwcmVmaXggKyB0ZXh0MixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyfWBcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVsYXllZFRleHRTdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWxheWVkVGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICBkZWxheWVkVGV4dFN0YXJ0ID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0LWRlbHRhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHByZWZpeCArIHRleHQyLFxuICAgICAgICAgICAgICAgICAgICAgIGlkOiBhY3RpdmVFeHRyYWN0aW9uLnRleHRJZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFeHRyYWN0aW9uLmlzUmVhc29uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5pc0ZpcnN0VGV4dCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRhZyA9IGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgPyBjbG9zaW5nVGFnIDogb3BlbmluZ1RhZztcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gZ2V0UG90ZW50aWFsU3RhcnRJbmRleChcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgbmV4dFRhZ1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcHVibGlzaChhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHVibGlzaChhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZm91bmRGdWxsTWF0Y2ggPSBzdGFydEluZGV4ICsgbmV4dFRhZy5sZW5ndGggPD0gYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZEZ1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgYWN0aXZlRXh0cmFjdGlvbi5idWZmZXIgPSBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleCArIG5leHRUYWcubGVuZ3RoXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZUV4dHJhY3Rpb24uaXNGaXJzdFJlYXNvbmluZykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGByZWFzb25pbmctJHthY3RpdmVFeHRyYWN0aW9uLmlkQ291bnRlcn1gXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1lbmRcIixcbiAgICAgICAgICAgICAgICAgICAgICBpZDogYHJlYXNvbmluZy0ke2FjdGl2ZUV4dHJhY3Rpb24uaWRDb3VudGVyKyt9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uaXNSZWFzb25pbmcgPSAhYWN0aXZlRXh0cmFjdGlvbi5pc1JlYXNvbmluZztcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZUV4dHJhY3Rpb24uYWZ0ZXJTd2l0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhY3RpdmVFeHRyYWN0aW9uLmJ1ZmZlciA9IGFjdGl2ZUV4dHJhY3Rpb24uYnVmZmVyLnNsaWNlKHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IHdoaWxlICh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvc2ltdWxhdGUtc3RyZWFtaW5nLW1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIHNpbXVsYXRlU3RyZWFtaW5nTWlkZGxld2FyZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHdyYXBTdHJlYW06IGFzeW5jICh7IGRvR2VuZXJhdGUgfSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZG9HZW5lcmF0ZSgpO1xuICAgICAgbGV0IGlkID0gMDtcbiAgICAgIGNvbnN0IHNpbXVsYXRlZFN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJzdHJlYW0tc3RhcnRcIixcbiAgICAgICAgICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3NcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInJlc3BvbnNlLW1ldGFkYXRhXCIsIC4uLnJlc3VsdC5yZXNwb25zZSB9KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcmVzdWx0LmNvbnRlbnQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFydC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICBpZiAocGFydC50ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1zdGFydFwiLCBpZDogU3RyaW5nKGlkKSB9KTtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGE6IHBhcnQudGV4dFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZW5kXCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSBcInJlYXNvbmluZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicmVhc29uaW5nLXN0YXJ0XCIsXG4gICAgICAgICAgICAgICAgICBpZDogU3RyaW5nKGlkKSxcbiAgICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcInJlYXNvbmluZy1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgaWQ6IFN0cmluZyhpZCksXG4gICAgICAgICAgICAgICAgICBkZWx0YTogcGFydC50ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJyZWFzb25pbmctZW5kXCIsIGlkOiBTdHJpbmcoaWQpIH0pO1xuICAgICAgICAgICAgICAgIGlkKys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgdHlwZTogXCJmaW5pc2hcIixcbiAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIHVzYWdlOiByZXN1bHQudXNhZ2UsXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdHJlYW06IHNpbXVsYXRlZFN0cmVhbSxcbiAgICAgICAgcmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzcG9uc2VcbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWlkZGxld2FyZS9hZGQtdG9vbC1pbnB1dC1leGFtcGxlcy1taWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBkZWZhdWx0Rm9ybWF0RXhhbXBsZShleGFtcGxlKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShleGFtcGxlLmlucHV0KTtcbn1cbmZ1bmN0aW9uIGFkZFRvb2xJbnB1dEV4YW1wbGVzTWlkZGxld2FyZSh7XG4gIHByZWZpeCA9IFwiSW5wdXQgRXhhbXBsZXM6XCIsXG4gIGZvcm1hdCA9IGRlZmF1bHRGb3JtYXRFeGFtcGxlLFxuICByZW1vdmUgPSB0cnVlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHRyYW5zZm9ybVBhcmFtczogYXN5bmMgKHsgcGFyYW1zIH0pID0+IHtcbiAgICAgIHZhciBfYTIxO1xuICAgICAgaWYgKCEoKF9hMjEgPSBwYXJhbXMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkVG9vbHMgPSBwYXJhbXMudG9vbHMubWFwKCh0b29sMikgPT4ge1xuICAgICAgICB2YXIgX2EyMjtcbiAgICAgICAgaWYgKHRvb2wyLnR5cGUgIT09IFwiZnVuY3Rpb25cIiB8fCAhKChfYTIyID0gdG9vbDIuaW5wdXRFeGFtcGxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjIubGVuZ3RoKSkge1xuICAgICAgICAgIHJldHVybiB0b29sMjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXR0ZWRFeGFtcGxlcyA9IHRvb2wyLmlucHV0RXhhbXBsZXMubWFwKChleGFtcGxlLCBpbmRleCkgPT4gZm9ybWF0KGV4YW1wbGUsIGluZGV4KSkuam9pbihcIlxcblwiKTtcbiAgICAgICAgY29uc3QgZXhhbXBsZXNTZWN0aW9uID0gYCR7cHJlZml4fVxuJHtmb3JtYXR0ZWRFeGFtcGxlc31gO1xuICAgICAgICBjb25zdCB0b29sRGVzY3JpcHRpb24gPSB0b29sMi5kZXNjcmlwdGlvbiA/IGAke3Rvb2wyLmRlc2NyaXB0aW9ufVxuXG4ke2V4YW1wbGVzU2VjdGlvbn1gIDogZXhhbXBsZXNTZWN0aW9uO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRvb2wyLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sRGVzY3JpcHRpb24sXG4gICAgICAgICAgaW5wdXRFeGFtcGxlczogcmVtb3ZlID8gdm9pZCAwIDogdG9vbDIuaW5wdXRFeGFtcGxlc1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHRvb2xzOiB0cmFuc2Zvcm1lZFRvb2xzXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1sYW5ndWFnZS1tb2RlbC50c1xudmFyIHdyYXBMYW5ndWFnZU1vZGVsID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IG1pZGRsZXdhcmVBcmcsXG4gIG1vZGVsSWQsXG4gIHByb3ZpZGVySWRcbn0pID0+IHtcbiAgcmV0dXJuIFsuLi5hc0FycmF5KG1pZGRsZXdhcmVBcmcpXS5yZXZlcnNlKCkucmVkdWNlKCh3cmFwcGVkTW9kZWwsIG1pZGRsZXdhcmUpID0+IHtcbiAgICByZXR1cm4gZG9XcmFwKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZToge1xuICAgIHRyYW5zZm9ybVBhcmFtcyxcbiAgICB3cmFwR2VuZXJhdGUsXG4gICAgd3JhcFN0cmVhbSxcbiAgICBvdmVycmlkZVByb3ZpZGVyLFxuICAgIG92ZXJyaWRlTW9kZWxJZCxcbiAgICBvdmVycmlkZVN1cHBvcnRlZFVybHNcbiAgfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2EyMSwgX2IsIF9jO1xuICBhc3luYyBmdW5jdGlvbiBkb1RyYW5zZm9ybSh7XG4gICAgcGFyYW1zLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYXJhbXMgPyBhd2FpdCB0cmFuc2Zvcm1QYXJhbXMoeyBwYXJhbXMsIHR5cGUsIG1vZGVsIH0pIDogcGFyYW1zO1xuICB9XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBwcm92aWRlcjogKF9hMjEgPSBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogb3ZlcnJpZGVQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVQcm92aWRlcih7IG1vZGVsIH0pKSAhPSBudWxsID8gX2EyMSA6IG1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsSWQ6IChfYiA9IG1vZGVsSWQgIT0gbnVsbCA/IG1vZGVsSWQgOiBvdmVycmlkZU1vZGVsSWQgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTW9kZWxJZCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2IgOiBtb2RlbC5tb2RlbElkLFxuICAgIHN1cHBvcnRlZFVybHM6IChfYyA9IG92ZXJyaWRlU3VwcG9ydGVkVXJscyA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVTdXBwb3J0ZWRVcmxzKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYyA6IG1vZGVsLnN1cHBvcnRlZFVybHMsXG4gICAgYXN5bmMgZG9HZW5lcmF0ZShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwiZ2VuZXJhdGVcIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7XG4gICAgICAgIGRvR2VuZXJhdGUsXG4gICAgICAgIGRvU3RyZWFtLFxuICAgICAgICBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLFxuICAgICAgICBtb2RlbFxuICAgICAgfSkgOiBkb0dlbmVyYXRlKCk7XG4gICAgfSxcbiAgICBhc3luYyBkb1N0cmVhbShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwic3RyZWFtXCIgfSk7XG4gICAgICBjb25zdCBkb0dlbmVyYXRlID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9HZW5lcmF0ZSh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICBjb25zdCBkb1N0cmVhbSA9IGFzeW5jICgpID0+IG1vZGVsLmRvU3RyZWFtKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwU3RyZWFtID8gd3JhcFN0cmVhbSh7IGRvR2VuZXJhdGUsIGRvU3RyZWFtLCBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLCBtb2RlbCB9KSA6IGRvU3RyZWFtKCk7XG4gICAgfVxuICB9O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUvd3JhcC1lbWJlZGRpbmctbW9kZWwudHNcbnZhciB3cmFwRW1iZWRkaW5nTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAyKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAyID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHtcbiAgICB0cmFuc2Zvcm1QYXJhbXMsXG4gICAgd3JhcEVtYmVkLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgb3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHNcbiAgfSxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICB2YXIgX2EyMSwgX2IsIF9jLCBfZDtcbiAgYXN5bmMgZnVuY3Rpb24gZG9UcmFuc2Zvcm0oe1xuICAgIHBhcmFtc1xuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgbW9kZWwgfSkgOiBwYXJhbXM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2EyMSA9IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBvdmVycmlkZVByb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZVByb3ZpZGVyKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYTIxIDogbW9kZWwucHJvdmlkZXIsXG4gICAgbW9kZWxJZDogKF9iID0gbW9kZWxJZCAhPSBudWxsID8gbW9kZWxJZCA6IG92ZXJyaWRlTW9kZWxJZCA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVNb2RlbElkKHsgbW9kZWwgfSkpICE9IG51bGwgPyBfYiA6IG1vZGVsLm1vZGVsSWQsXG4gICAgbWF4RW1iZWRkaW5nc1BlckNhbGw6IChfYyA9IG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTWF4RW1iZWRkaW5nc1BlckNhbGwoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwubWF4RW1iZWRkaW5nc1BlckNhbGwsXG4gICAgc3VwcG9ydHNQYXJhbGxlbENhbGxzOiAoX2QgPSBvdmVycmlkZVN1cHBvcnRzUGFyYWxsZWxDYWxscyA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVTdXBwb3J0c1BhcmFsbGVsQ2FsbHMoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9kIDogbW9kZWwuc3VwcG9ydHNQYXJhbGxlbENhbGxzLFxuICAgIGFzeW5jIGRvRW1iZWQocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pO1xuICAgICAgY29uc3QgZG9FbWJlZCA9IGFzeW5jICgpID0+IG1vZGVsLmRvRW1iZWQodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBFbWJlZCA/IHdyYXBFbWJlZCh7XG4gICAgICAgIGRvRW1iZWQsXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvRW1iZWQoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS93cmFwLWltYWdlLW1vZGVsLnRzXG52YXIgd3JhcEltYWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogbWlkZGxld2FyZUFyZyxcbiAgbW9kZWxJZCxcbiAgcHJvdmlkZXJJZFxufSkgPT4ge1xuICByZXR1cm4gWy4uLmFzQXJyYXkobWlkZGxld2FyZUFyZyldLnJldmVyc2UoKS5yZWR1Y2UoKHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSkgPT4ge1xuICAgIHJldHVybiBkb1dyYXAzKHsgbW9kZWw6IHdyYXBwZWRNb2RlbCwgbWlkZGxld2FyZSwgbW9kZWxJZCwgcHJvdmlkZXJJZCB9KTtcbiAgfSwgbW9kZWwpO1xufTtcbnZhciBkb1dyYXAzID0gKHtcbiAgbW9kZWwsXG4gIG1pZGRsZXdhcmU6IHtcbiAgICB0cmFuc2Zvcm1QYXJhbXMsXG4gICAgd3JhcEdlbmVyYXRlLFxuICAgIG92ZXJyaWRlUHJvdmlkZXIsXG4gICAgb3ZlcnJpZGVNb2RlbElkLFxuICAgIG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbFxuICB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIHZhciBfYTIxLCBfYiwgX2M7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUGFyYW1zID8gYXdhaXQgdHJhbnNmb3JtUGFyYW1zKHsgcGFyYW1zLCBtb2RlbCB9KSA6IHBhcmFtcztcbiAgfVxuICBjb25zdCBtYXhJbWFnZXNQZXJDYWxsUmF3ID0gKF9hMjEgPSBvdmVycmlkZU1heEltYWdlc1BlckNhbGwgPT0gbnVsbCA/IHZvaWQgMCA6IG92ZXJyaWRlTWF4SW1hZ2VzUGVyQ2FsbCh7IG1vZGVsIH0pKSAhPSBudWxsID8gX2EyMSA6IG1vZGVsLm1heEltYWdlc1BlckNhbGw7XG4gIGNvbnN0IG1heEltYWdlc1BlckNhbGwgPSBtYXhJbWFnZXNQZXJDYWxsUmF3IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBtYXhJbWFnZXNQZXJDYWxsUmF3LmJpbmQobW9kZWwpIDogbWF4SW1hZ2VzUGVyQ2FsbFJhdztcbiAgcmV0dXJuIHtcbiAgICBzcGVjaWZpY2F0aW9uVmVyc2lvbjogXCJ2M1wiLFxuICAgIHByb3ZpZGVyOiAoX2IgPSBwcm92aWRlcklkICE9IG51bGwgPyBwcm92aWRlcklkIDogb3ZlcnJpZGVQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogb3ZlcnJpZGVQcm92aWRlcih7IG1vZGVsIH0pKSAhPSBudWxsID8gX2IgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiAoX2MgPSBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogb3ZlcnJpZGVNb2RlbElkID09IG51bGwgPyB2b2lkIDAgOiBvdmVycmlkZU1vZGVsSWQoeyBtb2RlbCB9KSkgIT0gbnVsbCA/IF9jIDogbW9kZWwubW9kZWxJZCxcbiAgICBtYXhJbWFnZXNQZXJDYWxsLFxuICAgIGFzeW5jIGRvR2VuZXJhdGUocGFyYW1zKSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZFBhcmFtcyA9IGF3YWl0IGRvVHJhbnNmb3JtKHsgcGFyYW1zIH0pO1xuICAgICAgY29uc3QgZG9HZW5lcmF0ZSA9IGFzeW5jICgpID0+IG1vZGVsLmRvR2VuZXJhdGUodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBHZW5lcmF0ZSA/IHdyYXBHZW5lcmF0ZSh7XG4gICAgICAgIGRvR2VuZXJhdGUsXG4gICAgICAgIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsXG4gICAgICAgIG1vZGVsXG4gICAgICB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvbW9kZWwvYXMtcHJvdmlkZXItdjMudHNcbmZ1bmN0aW9uIGFzUHJvdmlkZXJWMyhwcm92aWRlcikge1xuICBpZiAoXCJzcGVjaWZpY2F0aW9uVmVyc2lvblwiIGluIHByb3ZpZGVyICYmIHByb3ZpZGVyLnNwZWNpZmljYXRpb25WZXJzaW9uID09PSBcInYzXCIpIHtcbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgY29uc3QgdjJQcm92aWRlciA9IHByb3ZpZGVyO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgbGFuZ3VhZ2VNb2RlbDogKG1vZGVsSWQpID0+IGFzTGFuZ3VhZ2VNb2RlbFYzKHYyUHJvdmlkZXIubGFuZ3VhZ2VNb2RlbChtb2RlbElkKSksXG4gICAgZW1iZWRkaW5nTW9kZWw6IChtb2RlbElkKSA9PiBhc0VtYmVkZGluZ01vZGVsVjModjJQcm92aWRlci50ZXh0RW1iZWRkaW5nTW9kZWwobW9kZWxJZCkpLFxuICAgIGltYWdlTW9kZWw6IChtb2RlbElkKSA9PiBhc0ltYWdlTW9kZWxWMyh2MlByb3ZpZGVyLmltYWdlTW9kZWwobW9kZWxJZCkpLFxuICAgIHRyYW5zY3JpcHRpb25Nb2RlbDogdjJQcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwgPyAobW9kZWxJZCkgPT4gYXNUcmFuc2NyaXB0aW9uTW9kZWxWMyh2MlByb3ZpZGVyLnRyYW5zY3JpcHRpb25Nb2RlbChtb2RlbElkKSkgOiB2b2lkIDAsXG4gICAgc3BlZWNoTW9kZWw6IHYyUHJvdmlkZXIuc3BlZWNoTW9kZWwgPyAobW9kZWxJZCkgPT4gYXNTcGVlY2hNb2RlbFYzKHYyUHJvdmlkZXIuc3BlZWNoTW9kZWwobW9kZWxJZCkpIDogdm9pZCAwLFxuICAgIHJlcmFua2luZ01vZGVsOiB2b2lkIDBcbiAgICAvLyB2MiBwcm92aWRlcnMgZG9uJ3QgaGF2ZSByZXJhbmtpbmcgbW9kZWxzXG4gIH07XG59XG5cbi8vIHNyYy9taWRkbGV3YXJlL3dyYXAtcHJvdmlkZXIudHNcbmZ1bmN0aW9uIHdyYXBQcm92aWRlcih7XG4gIHByb3ZpZGVyLFxuICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgaW1hZ2VNb2RlbE1pZGRsZXdhcmVcbn0pIHtcbiAgY29uc3QgcHJvdmlkZXJWMyA9IGFzUHJvdmlkZXJWMyhwcm92aWRlcik7XG4gIHJldHVybiB7XG4gICAgc3BlY2lmaWNhdGlvblZlcnNpb246IFwidjNcIixcbiAgICBsYW5ndWFnZU1vZGVsOiAobW9kZWxJZCkgPT4gd3JhcExhbmd1YWdlTW9kZWwoe1xuICAgICAgbW9kZWw6IHByb3ZpZGVyVjMubGFuZ3VhZ2VNb2RlbChtb2RlbElkKSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgfSksXG4gICAgZW1iZWRkaW5nTW9kZWw6IHByb3ZpZGVyVjMuZW1iZWRkaW5nTW9kZWwsXG4gICAgaW1hZ2VNb2RlbDogKG1vZGVsSWQpID0+IHtcbiAgICAgIGxldCBtb2RlbCA9IHByb3ZpZGVyVjMuaW1hZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIGlmIChpbWFnZU1vZGVsTWlkZGxld2FyZSAhPSBudWxsKSB7XG4gICAgICAgIG1vZGVsID0gd3JhcEltYWdlTW9kZWwoeyBtb2RlbCwgbWlkZGxld2FyZTogaW1hZ2VNb2RlbE1pZGRsZXdhcmUgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWw6IHByb3ZpZGVyVjMudHJhbnNjcmlwdGlvbk1vZGVsLFxuICAgIHNwZWVjaE1vZGVsOiBwcm92aWRlclYzLnNwZWVjaE1vZGVsLFxuICAgIHJlcmFua2luZ01vZGVsOiBwcm92aWRlclYzLnJlcmFua2luZ01vZGVsXG4gIH07XG59XG5cbi8vIHNyYy9yZWdpc3RyeS9jdXN0b20tcHJvdmlkZXIudHNcbmltcG9ydCB7XG4gIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGN1c3RvbVByb3ZpZGVyKHtcbiAgbGFuZ3VhZ2VNb2RlbHMsXG4gIGVtYmVkZGluZ01vZGVscyxcbiAgaW1hZ2VNb2RlbHMsXG4gIHRyYW5zY3JpcHRpb25Nb2RlbHMsXG4gIHNwZWVjaE1vZGVscyxcbiAgcmVyYW5raW5nTW9kZWxzLFxuICBmYWxsYmFja1Byb3ZpZGVyOiBmYWxsYmFja1Byb3ZpZGVyQXJnXG59KSB7XG4gIGNvbnN0IGZhbGxiYWNrUHJvdmlkZXIgPSBmYWxsYmFja1Byb3ZpZGVyQXJnID8gYXNQcm92aWRlclYzKGZhbGxiYWNrUHJvdmlkZXJBcmcpIDogdm9pZCAwO1xuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYzXCIsXG4gICAgbGFuZ3VhZ2VNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAobGFuZ3VhZ2VNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIGxhbmd1YWdlTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBsYW5ndWFnZU1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLmxhbmd1YWdlTW9kZWwobW9kZWxJZCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjIoeyBtb2RlbElkLCBtb2RlbFR5cGU6IFwibGFuZ3VhZ2VNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgZW1iZWRkaW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gZW1iZWRkaW5nTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBlbWJlZGRpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5lbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJlbWJlZGRpbmdNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgaW1hZ2VNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAoaW1hZ2VNb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIGltYWdlTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBpbWFnZU1vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyID09IG51bGwgPyB2b2lkIDAgOiBmYWxsYmFja1Byb3ZpZGVyLmltYWdlTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIuaW1hZ2VNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJpbWFnZU1vZGVsXCIgfSk7XG4gICAgfSxcbiAgICB0cmFuc2NyaXB0aW9uTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHRyYW5zY3JpcHRpb25Nb2RlbHMgIT0gbnVsbCAmJiBtb2RlbElkIGluIHRyYW5zY3JpcHRpb25Nb2RlbHMpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zY3JpcHRpb25Nb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrUHJvdmlkZXIudHJhbnNjcmlwdGlvbk1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgc3BlZWNoTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHNwZWVjaE1vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gc3BlZWNoTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiBzcGVlY2hNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5zcGVlY2hNb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5zcGVlY2hNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJzcGVlY2hNb2RlbFwiIH0pO1xuICAgIH0sXG4gICAgcmVyYW5raW5nTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKHJlcmFua2luZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gcmVyYW5raW5nTW9kZWxzKSB7XG4gICAgICAgIHJldHVybiByZXJhbmtpbmdNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlciA9PSBudWxsID8gdm9pZCAwIDogZmFsbGJhY2tQcm92aWRlci5yZXJhbmtpbmdNb2RlbCkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5yZXJhbmtpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJyZXJhbmtpbmdNb2RlbFwiIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIgPSBjdXN0b21Qcm92aWRlcjtcblxuLy8gc3JjL3JlZ2lzdHJ5L25vLXN1Y2gtcHJvdmlkZXItZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjI0LCBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3IzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lMjAgPSBcIkFJX05vU3VjaFByb3ZpZGVyRXJyb3JcIjtcbnZhciBtYXJrZXIyMCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMjB9YDtcbnZhciBzeW1ib2wyMCA9IFN5bWJvbC5mb3IobWFya2VyMjApO1xudmFyIF9hMjA7XG52YXIgTm9TdWNoUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgTm9TdWNoTW9kZWxFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbW9kZWxJZCxcbiAgICBtb2RlbFR5cGUsXG4gICAgcHJvdmlkZXJJZCxcbiAgICBhdmFpbGFibGVQcm92aWRlcnMsXG4gICAgbWVzc2FnZSA9IGBObyBzdWNoIHByb3ZpZGVyOiAke3Byb3ZpZGVySWR9IChhdmFpbGFibGUgcHJvdmlkZXJzOiAke2F2YWlsYWJsZVByb3ZpZGVycy5qb2luKCl9KWBcbiAgfSkge1xuICAgIHN1cGVyKHsgZXJyb3JOYW1lOiBuYW1lMjAsIG1vZGVsSWQsIG1vZGVsVHlwZSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hMjBdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVySWQgPSBwcm92aWRlcklkO1xuICAgIHRoaXMuYXZhaWxhYmxlUHJvdmlkZXJzID0gYXZhaWxhYmxlUHJvdmlkZXJzO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIwKTtcbiAgfVxufTtcbl9hMjAgPSBzeW1ib2wyMDtcblxuLy8gc3JjL3JlZ2lzdHJ5L3Byb3ZpZGVyLXJlZ2lzdHJ5LnRzXG5pbXBvcnQge1xuICBOb1N1Y2hNb2RlbEVycm9yIGFzIE5vU3VjaE1vZGVsRXJyb3I0XG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5KHByb3ZpZGVycywge1xuICBzZXBhcmF0b3IgPSBcIjpcIixcbiAgbGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUsXG4gIGltYWdlTW9kZWxNaWRkbGV3YXJlXG59ID0ge30pIHtcbiAgY29uc3QgcmVnaXN0cnkgPSBuZXcgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkoe1xuICAgIHNlcGFyYXRvcixcbiAgICBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZSxcbiAgICBpbWFnZU1vZGVsTWlkZGxld2FyZVxuICB9KTtcbiAgZm9yIChjb25zdCBbaWQsIHByb3ZpZGVyXSBvZiBPYmplY3QuZW50cmllcyhwcm92aWRlcnMpKSB7XG4gICAgcmVnaXN0cnkucmVnaXN0ZXJQcm92aWRlcih7IGlkLCBwcm92aWRlciB9KTtcbiAgfVxuICByZXR1cm4gcmVnaXN0cnk7XG59XG52YXIgZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkgPSBjcmVhdGVQcm92aWRlclJlZ2lzdHJ5O1xudmFyIERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc2VwYXJhdG9yLFxuICAgIGxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlLFxuICAgIGltYWdlTW9kZWxNaWRkbGV3YXJlXG4gIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVycyA9IHt9O1xuICAgIHRoaXMuc2VwYXJhdG9yID0gc2VwYXJhdG9yO1xuICAgIHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgPSBsYW5ndWFnZU1vZGVsTWlkZGxld2FyZTtcbiAgICB0aGlzLmltYWdlTW9kZWxNaWRkbGV3YXJlID0gaW1hZ2VNb2RlbE1pZGRsZXdhcmU7XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7XG4gICAgaWQsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzW2lkXSA9IHByb3ZpZGVyO1xuICB9XG4gIGdldFByb3ZpZGVyKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMucHJvdmlkZXJzW2lkXTtcbiAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaFByb3ZpZGVyRXJyb3Ioe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBwcm92aWRlcklkOiBpZCxcbiAgICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiBPYmplY3Qua2V5cyh0aGlzLnByb3ZpZGVycylcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcHJvdmlkZXI7XG4gIH1cbiAgc3BsaXRJZChpZCwgbW9kZWxUeXBlKSB7XG4gICAgY29uc3QgaW5kZXggPSBpZC5pbmRleE9mKHRoaXMuc2VwYXJhdG9yKTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlLFxuICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCAke21vZGVsVHlwZX0gaWQgZm9yIHJlZ2lzdHJ5OiAke2lkfSAobXVzdCBiZSBpbiB0aGUgZm9ybWF0IFwicHJvdmlkZXJJZCR7dGhpcy5zZXBhcmF0b3J9bW9kZWxJZFwiKWBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gW2lkLnNsaWNlKDAsIGluZGV4KSwgaWQuc2xpY2UoaW5kZXggKyB0aGlzLnNlcGFyYXRvci5sZW5ndGgpXTtcbiAgfVxuICBsYW5ndWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjEsIF9iO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJsYW5ndWFnZU1vZGVsXCIpO1xuICAgIGxldCBtb2RlbCA9IChfYiA9IChfYTIxID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImxhbmd1YWdlTW9kZWxcIikpLmxhbmd1YWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKFxuICAgICAgX2EyMSxcbiAgICAgIG1vZGVsSWRcbiAgICApO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubGFuZ3VhZ2VNb2RlbE1pZGRsZXdhcmUgIT0gbnVsbCkge1xuICAgICAgbW9kZWwgPSB3cmFwTGFuZ3VhZ2VNb2RlbCh7XG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLmxhbmd1YWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIGVtYmVkZGluZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcImVtYmVkZGluZ01vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci5lbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGU6IFwiZW1iZWRkaW5nTW9kZWxcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxuICBpbWFnZU1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImltYWdlTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwiaW1hZ2VNb2RlbFwiKTtcbiAgICBsZXQgbW9kZWwgPSAoX2EyMSA9IHByb3ZpZGVyLmltYWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImltYWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaW1hZ2VNb2RlbE1pZGRsZXdhcmUgIT0gbnVsbCkge1xuICAgICAgbW9kZWwgPSB3cmFwSW1hZ2VNb2RlbCh7XG4gICAgICAgIG1vZGVsLFxuICAgICAgICBtaWRkbGV3YXJlOiB0aGlzLmltYWdlTW9kZWxNaWRkbGV3YXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRyYW5zY3JpcHRpb25Nb2RlbChpZCkge1xuICAgIHZhciBfYTIxO1xuICAgIGNvbnN0IFtwcm92aWRlcklkLCBtb2RlbElkXSA9IHRoaXMuc3BsaXRJZChpZCwgXCJ0cmFuc2NyaXB0aW9uTW9kZWxcIik7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLmdldFByb3ZpZGVyKHByb3ZpZGVySWQsIFwidHJhbnNjcmlwdGlvbk1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci50cmFuc2NyaXB0aW9uTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRyYW5zY3JpcHRpb25Nb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHNwZWVjaE1vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInNwZWVjaE1vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci5zcGVlY2hNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwic3BlZWNoTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHJlcmFua2luZ01vZGVsKGlkKSB7XG4gICAgdmFyIF9hMjE7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInJlcmFua2luZ01vZGVsXCIpO1xuICAgIGNvbnN0IHByb3ZpZGVyID0gdGhpcy5nZXRQcm92aWRlcihwcm92aWRlcklkLCBcInJlcmFua2luZ01vZGVsXCIpO1xuICAgIGNvbnN0IG1vZGVsID0gKF9hMjEgPSBwcm92aWRlci5yZXJhbmtpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbChwcm92aWRlciwgbW9kZWxJZCk7XG4gICAgaWYgKG1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7IG1vZGVsSWQ6IGlkLCBtb2RlbFR5cGU6IFwicmVyYW5raW5nTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG59O1xuXG4vLyBzcmMvcmVyYW5rL3JlcmFuay50c1xuYXN5bmMgZnVuY3Rpb24gcmVyYW5rKHtcbiAgbW9kZWwsXG4gIGRvY3VtZW50cyxcbiAgcXVlcnksXG4gIHRvcE4sXG4gIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gIGFib3J0U2lnbmFsLFxuICBoZWFkZXJzLFxuICBwcm92aWRlck9wdGlvbnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgRGVmYXVsdFJlcmFua1Jlc3VsdCh7XG4gICAgICBvcmlnaW5hbERvY3VtZW50czogW10sXG4gICAgICByYW5raW5nOiBbXSxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHZvaWQgMCxcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIHRpbWVzdGFtcDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIG1vZGVsSWQ6IG1vZGVsLm1vZGVsSWRcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCB7IG1heFJldHJpZXMsIHJldHJ5IH0gPSBwcmVwYXJlUmV0cmllcyh7XG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KTtcbiAgY29uc3QgZG9jdW1lbnRzVG9TZW5kID0gdHlwZW9mIGRvY3VtZW50c1swXSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlczogZG9jdW1lbnRzIH0gOiB7IHR5cGU6IFwib2JqZWN0XCIsIHZhbHVlczogZG9jdW1lbnRzIH07XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLnJlcmFua1wiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5yZXJhbmtcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgXCJhaS5kb2N1bWVudHNcIjoge1xuICAgICAgICAgIGlucHV0OiAoKSA9PiBkb2N1bWVudHMubWFwKChkb2N1bWVudCkgPT4gSlNPTi5zdHJpbmdpZnkoZG9jdW1lbnQpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoKSA9PiB7XG4gICAgICB2YXIgX2EyMSwgX2I7XG4gICAgICBjb25zdCB7IHJhbmtpbmcsIHJlc3BvbnNlLCBwcm92aWRlck1ldGFkYXRhLCB3YXJuaW5ncyB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgIG5hbWU6IFwiYWkucmVyYW5rLmRvUmVyYW5rXCIsXG4gICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkucmVyYW5rLmRvUmVyYW5rXCIsXG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICBcImFpLmRvY3VtZW50c1wiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGRvY3VtZW50cy5tYXAoKGRvY3VtZW50KSA9PiBKU09OLnN0cmluZ2lmeShkb2N1bWVudCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1JlcmFua1NwYW4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb1JlcmFuayh7XG4gICAgICAgICAgICAgIGRvY3VtZW50czogZG9jdW1lbnRzVG9TZW5kLFxuICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgdG9wTixcbiAgICAgICAgICAgICAgcHJvdmlkZXJPcHRpb25zLFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByYW5raW5nMiA9IG1vZGVsUmVzcG9uc2UucmFua2luZztcbiAgICAgICAgICAgIGRvUmVyYW5rU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBhd2FpdCBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS5yYW5raW5nLnR5cGVcIjogZG9jdW1lbnRzVG9TZW5kLnR5cGUsXG4gICAgICAgICAgICAgICAgICBcImFpLnJhbmtpbmdcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJhbmtpbmcyLm1hcCgocmFua2luZzMpID0+IEpTT04uc3RyaW5naWZ5KHJhbmtpbmczKSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgcmFua2luZzogcmFua2luZzIsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgICAgICAgcmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmVzcG9uc2UsXG4gICAgICAgICAgICAgIHdhcm5pbmdzOiBtb2RlbFJlc3BvbnNlLndhcm5pbmdzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBsb2dXYXJuaW5ncyh7XG4gICAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncyAhPSBudWxsID8gd2FybmluZ3MgOiBbXSxcbiAgICAgICAgcHJvdmlkZXI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICBtb2RlbDogbW9kZWwubW9kZWxJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRSZXJhbmtSZXN1bHQoe1xuICAgICAgICBvcmlnaW5hbERvY3VtZW50czogZG9jdW1lbnRzLFxuICAgICAgICByYW5raW5nOiByYW5raW5nLm1hcCgocmFua2luZzIpID0+ICh7XG4gICAgICAgICAgb3JpZ2luYWxJbmRleDogcmFua2luZzIuaW5kZXgsXG4gICAgICAgICAgc2NvcmU6IHJhbmtpbmcyLnJlbGV2YW5jZVNjb3JlLFxuICAgICAgICAgIGRvY3VtZW50OiBkb2N1bWVudHNbcmFua2luZzIuaW5kZXhdXG4gICAgICAgIH0pKSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICBpZDogcmVzcG9uc2UgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICAgIHRpbWVzdGFtcDogKF9hMjEgPSByZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmVzcG9uc2UudGltZXN0YW1wKSAhPSBudWxsID8gX2EyMSA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICAgIG1vZGVsSWQ6IChfYiA9IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5tb2RlbElkKSAhPSBudWxsID8gX2IgOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHJlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFJlcmFua1Jlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3JpZ2luYWxEb2N1bWVudHMgPSBvcHRpb25zLm9yaWdpbmFsRG9jdW1lbnRzO1xuICAgIHRoaXMucmFua2luZyA9IG9wdGlvbnMucmFua2luZztcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnByb3ZpZGVyTWV0YWRhdGEgPSBvcHRpb25zLnByb3ZpZGVyTWV0YWRhdGE7XG4gIH1cbiAgZ2V0IHJlcmFua2VkRG9jdW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLnJhbmtpbmcubWFwKChyYW5raW5nKSA9PiByYW5raW5nLmRvY3VtZW50KTtcbiAgfVxufTtcblxuLy8gc3JjL3RyYW5zY3JpYmUvdHJhbnNjcmliZS50c1xuaW1wb3J0IHsgd2l0aFVzZXJBZ2VudFN1ZmZpeCBhcyB3aXRoVXNlckFnZW50U3VmZml4OSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5hc3luYyBmdW5jdGlvbiB0cmFuc2NyaWJlKHtcbiAgbW9kZWwsXG4gIGF1ZGlvLFxuICBwcm92aWRlck9wdGlvbnMgPSB7fSxcbiAgbWF4UmV0cmllczogbWF4UmV0cmllc0FyZyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnNcbn0pIHtcbiAgY29uc3QgcmVzb2x2ZWRNb2RlbCA9IHJlc29sdmVUcmFuc2NyaXB0aW9uTW9kZWwobW9kZWwpO1xuICBpZiAoIXJlc29sdmVkTW9kZWwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2RlbCBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcIik7XG4gIH1cbiAgY29uc3QgeyByZXRyeSB9ID0gcHJlcGFyZVJldHJpZXMoe1xuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXNBcmcsXG4gICAgYWJvcnRTaWduYWxcbiAgfSk7XG4gIGNvbnN0IGhlYWRlcnNXaXRoVXNlckFnZW50ID0gd2l0aFVzZXJBZ2VudFN1ZmZpeDkoXG4gICAgaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9LFxuICAgIGBhaS8ke1ZFUlNJT059YFxuICApO1xuICBjb25zdCBhdWRpb0RhdGEgPSBhdWRpbyBpbnN0YW5jZW9mIFVSTCA/IChhd2FpdCBkb3dubG9hZCh7IHVybDogYXVkaW8gfSkpLmRhdGEgOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYXVkaW8pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiB7XG4gICAgICB2YXIgX2EyMTtcbiAgICAgIHJldHVybiByZXNvbHZlZE1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICBhdWRpbzogYXVkaW9EYXRhLFxuICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogaGVhZGVyc1dpdGhVc2VyQWdlbnQsXG4gICAgICAgIHByb3ZpZGVyT3B0aW9ucyxcbiAgICAgICAgbWVkaWFUeXBlOiAoX2EyMSA9IGRldGVjdE1lZGlhVHlwZSh7XG4gICAgICAgICAgZGF0YTogYXVkaW9EYXRhLFxuICAgICAgICAgIHNpZ25hdHVyZXM6IGF1ZGlvTWVkaWFUeXBlU2lnbmF0dXJlc1xuICAgICAgICB9KSkgIT0gbnVsbCA/IF9hMjEgOiBcImF1ZGlvL3dhdlwiXG4gICAgICB9KTtcbiAgICB9XG4gICk7XG4gIGxvZ1dhcm5pbmdzKHtcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHByb3ZpZGVyOiByZXNvbHZlZE1vZGVsLnByb3ZpZGVyLFxuICAgIG1vZGVsOiByZXNvbHZlZE1vZGVsLm1vZGVsSWRcbiAgfSk7XG4gIGlmICghcmVzdWx0LnRleHQpIHtcbiAgICB0aHJvdyBuZXcgTm9UcmFuc2NyaXB0R2VuZXJhdGVkRXJyb3IoeyByZXNwb25zZXM6IFtyZXN1bHQucmVzcG9uc2VdIH0pO1xuICB9XG4gIHJldHVybiBuZXcgRGVmYXVsdFRyYW5zY3JpcHRpb25SZXN1bHQoe1xuICAgIHRleHQ6IHJlc3VsdC50ZXh0LFxuICAgIHNlZ21lbnRzOiByZXN1bHQuc2VnbWVudHMsXG4gICAgbGFuZ3VhZ2U6IHJlc3VsdC5sYW5ndWFnZSxcbiAgICBkdXJhdGlvbkluU2Vjb25kczogcmVzdWx0LmR1cmF0aW9uSW5TZWNvbmRzLFxuICAgIHdhcm5pbmdzOiByZXN1bHQud2FybmluZ3MsXG4gICAgcmVzcG9uc2VzOiBbcmVzdWx0LnJlc3BvbnNlXSxcbiAgICBwcm92aWRlck1ldGFkYXRhOiByZXN1bHQucHJvdmlkZXJNZXRhZGF0YVxuICB9KTtcbn1cbnZhciBEZWZhdWx0VHJhbnNjcmlwdGlvblJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfYTIxO1xuICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcbiAgICB0aGlzLnNlZ21lbnRzID0gb3B0aW9ucy5zZWdtZW50cztcbiAgICB0aGlzLmxhbmd1YWdlID0gb3B0aW9ucy5sYW5ndWFnZTtcbiAgICB0aGlzLmR1cmF0aW9uSW5TZWNvbmRzID0gb3B0aW9ucy5kdXJhdGlvbkluU2Vjb25kcztcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlc3BvbnNlcyA9IG9wdGlvbnMucmVzcG9uc2VzO1xuICAgIHRoaXMucHJvdmlkZXJNZXRhZGF0YSA9IChfYTIxID0gb3B0aW9ucy5wcm92aWRlck1ldGFkYXRhKSAhPSBudWxsID8gX2EyMSA6IHt9O1xuICB9XG59O1xuXG4vLyBzcmMvdWkvY2FsbC1jb21wbGV0aW9uLWFwaS50c1xuaW1wb3J0IHtcbiAgcGFyc2VKc29uRXZlbnRTdHJlYW0sXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDEwLFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQgYXMgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50MlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvdWkvcHJvY2Vzcy10ZXh0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1RleHRTdHJlYW0oe1xuICBzdHJlYW0sXG4gIG9uVGV4dFBhcnRcbn0pIHtcbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5nZXRSZWFkZXIoKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYXdhaXQgb25UZXh0UGFydCh2YWx1ZSk7XG4gIH1cbn1cblxuLy8gc3JjL3VpL2NhbGwtY29tcGxldGlvbi1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIGZldGNoOiBmZXRjaDIgPSBnZXRPcmlnaW5hbEZldGNoKClcbn0pIHtcbiAgdmFyIF9hMjE7XG4gIHRyeSB7XG4gICAgc2V0TG9hZGluZyh0cnVlKTtcbiAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBzZXRBYm9ydENvbnRyb2xsZXIoYWJvcnRDb250cm9sbGVyKTtcbiAgICBzZXRDb21wbGV0aW9uKFwiXCIpO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9KSxcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczogd2l0aFVzZXJBZ2VudFN1ZmZpeDEwKFxuICAgICAgICB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBgYWktc2RrLyR7VkVSU0lPTn1gLFxuICAgICAgICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQyKClcbiAgICAgICksXG4gICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2EyMSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9hMjEgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgYXdhaXQgcHJvY2Vzc1RleHRTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbTogcmVzcG9uc2UuYm9keSxcbiAgICAgICAgICBvblRleHRQYXJ0OiAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaHVuaztcbiAgICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgYXdhaXQgY29uc3VtZVN0cmVhbSh7XG4gICAgICAgICAgc3RyZWFtOiBwYXJzZUpzb25FdmVudFN0cmVhbSh7XG4gICAgICAgICAgICBzdHJlYW06IHJlc3BvbnNlLmJvZHksXG4gICAgICAgICAgICBzY2hlbWE6IHVpTWVzc2FnZUNodW5rU2NoZW1hXG4gICAgICAgICAgfSkucGlwZVRocm91Z2goXG4gICAgICAgICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKHBhcnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgcGFydC5lcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyZWFtUGFydCA9IHBhcnQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbVBhcnQudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzdHJlYW1QYXJ0LmRlbHRhO1xuICAgICAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyZWFtUGFydC50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHJlYW1QYXJ0LmVycm9yVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICksXG4gICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvdWkvY2hhdC50c1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuYzJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL2NvbnZlcnQtZmlsZS1saXN0LXRvLWZpbGUtdWktcGFydHMudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMoZmlsZXMpIHtcbiAgaWYgKGZpbGVzID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFnbG9iYWxUaGlzLkZpbGVMaXN0IHx8ICEoZmlsZXMgaW5zdGFuY2VvZiBnbG9iYWxUaGlzLkZpbGVMaXN0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZpbGVMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcIik7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgIEFycmF5LmZyb20oZmlsZXMpLm1hcChhc3luYyAoZmlsZSkgPT4ge1xuICAgICAgY29uc3QgeyBuYW1lOiBuYW1lMjEsIHR5cGUgfSA9IGZpbGU7XG4gICAgICBjb25zdCBkYXRhVXJsID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUzLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChyZWFkZXJFdmVudCkgPT4ge1xuICAgICAgICAgIHZhciBfYTIxO1xuICAgICAgICAgIHJlc29sdmUzKChfYTIxID0gcmVhZGVyRXZlbnQudGFyZ2V0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICBtZWRpYVR5cGU6IHR5cGUsXG4gICAgICAgIGZpbGVuYW1lOiBuYW1lMjEsXG4gICAgICAgIHVybDogZGF0YVVybFxuICAgICAgfTtcbiAgICB9KVxuICApO1xufVxuXG4vLyBzcmMvdWkvZGVmYXVsdC1jaGF0LXRyYW5zcG9ydC50c1xuaW1wb3J0IHsgcGFyc2VKc29uRXZlbnRTdHJlYW0gYXMgcGFyc2VKc29uRXZlbnRTdHJlYW0yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3VpL2h0dHAtY2hhdC10cmFuc3BvcnQudHNcbmltcG9ydCB7XG4gIG5vcm1hbGl6ZUhlYWRlcnMsXG4gIHJlc29sdmUgYXMgcmVzb2x2ZTIsXG4gIHdpdGhVc2VyQWdlbnRTdWZmaXggYXMgd2l0aFVzZXJBZ2VudFN1ZmZpeDExLFxuICBnZXRSdW50aW1lRW52aXJvbm1lbnRVc2VyQWdlbnQgYXMgZ2V0UnVudGltZUVudmlyb25tZW50VXNlckFnZW50M1xufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xudmFyIEh0dHBDaGF0VHJhbnNwb3J0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYXBpID0gXCIvYXBpL2NoYXRcIixcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHksXG4gICAgZmV0Y2g6IGZldGNoMixcbiAgICBwcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCxcbiAgICBwcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0XG4gIH0pIHtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgICB0aGlzLmNyZWRlbnRpYWxzID0gY3JlZGVudGlhbHM7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDI7XG4gICAgdGhpcy5wcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCA9IHByZXBhcmVTZW5kTWVzc2FnZXNSZXF1ZXN0O1xuICAgIHRoaXMucHJlcGFyZVJlY29ubmVjdFRvU3RyZWFtUmVxdWVzdCA9IHByZXBhcmVSZWNvbm5lY3RUb1N0cmVhbVJlcXVlc3Q7XG4gIH1cbiAgYXN5bmMgc2VuZE1lc3NhZ2VzKHtcbiAgICBhYm9ydFNpZ25hbCxcbiAgICAuLi5vcHRpb25zXG4gIH0pIHtcbiAgICB2YXIgX2EyMSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgcmVzb2x2ZWRCb2R5ID0gYXdhaXQgcmVzb2x2ZTIodGhpcy5ib2R5KTtcbiAgICBjb25zdCByZXNvbHZlZEhlYWRlcnMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICBjb25zdCBiYXNlSGVhZGVycyA9IHtcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMocmVzb2x2ZWRIZWFkZXJzKSxcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZXF1ZXN0ID0gYXdhaXQgKChfYTIxID0gdGhpcy5wcmVwYXJlU2VuZE1lc3NhZ2VzUmVxdWVzdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuY2FsbCh0aGlzLCB7XG4gICAgICBhcGk6IHRoaXMuYXBpLFxuICAgICAgaWQ6IG9wdGlvbnMuY2hhdElkLFxuICAgICAgbWVzc2FnZXM6IG9wdGlvbnMubWVzc2FnZXMsXG4gICAgICBib2R5OiB7IC4uLnJlc29sdmVkQm9keSwgLi4ub3B0aW9ucy5ib2R5IH0sXG4gICAgICBoZWFkZXJzOiBiYXNlSGVhZGVycyxcbiAgICAgIGNyZWRlbnRpYWxzOiByZXNvbHZlZENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdE1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhLFxuICAgICAgdHJpZ2dlcjogb3B0aW9ucy50cmlnZ2VyLFxuICAgICAgbWVzc2FnZUlkOiBvcHRpb25zLm1lc3NhZ2VJZFxuICAgIH0pKTtcbiAgICBjb25zdCBhcGkgPSAoX2IgPSBwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5hcGkpICE9IG51bGwgPyBfYiA6IHRoaXMuYXBpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSAocHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuaGVhZGVycykgIT09IHZvaWQgMCA/IG5vcm1hbGl6ZUhlYWRlcnMocHJlcGFyZWRSZXF1ZXN0LmhlYWRlcnMpIDogYmFzZUhlYWRlcnM7XG4gICAgY29uc3QgYm9keSA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5ib2R5KSAhPT0gdm9pZCAwID8gcHJlcGFyZWRSZXF1ZXN0LmJvZHkgOiB7XG4gICAgICAuLi5yZXNvbHZlZEJvZHksXG4gICAgICAuLi5vcHRpb25zLmJvZHksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgIHRyaWdnZXI6IG9wdGlvbnMudHJpZ2dlcixcbiAgICAgIG1lc3NhZ2VJZDogb3B0aW9ucy5tZXNzYWdlSWRcbiAgICB9O1xuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0gKF9jID0gcHJlcGFyZWRSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBwcmVwYXJlZFJlcXVlc3QuY3JlZGVudGlhbHMpICE9IG51bGwgPyBfYyA6IHJlc29sdmVkQ3JlZGVudGlhbHM7XG4gICAgY29uc3QgZmV0Y2gyID0gKF9kID0gdGhpcy5mZXRjaCkgIT0gbnVsbCA/IF9kIDogZ2xvYmFsVGhpcy5mZXRjaDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4MTEoXG4gICAgICAgIHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAuLi5oZWFkZXJzXG4gICAgICAgIH0sXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDMoKVxuICAgICAgKSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfZSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHJlc3BvbnNlLmJvZHkpO1xuICB9XG4gIGFzeW5jIHJlY29ubmVjdFRvU3RyZWFtKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EyMSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgcmVzb2x2ZWRCb2R5ID0gYXdhaXQgcmVzb2x2ZTIodGhpcy5ib2R5KTtcbiAgICBjb25zdCByZXNvbHZlZEhlYWRlcnMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmhlYWRlcnMpO1xuICAgIGNvbnN0IHJlc29sdmVkQ3JlZGVudGlhbHMgPSBhd2FpdCByZXNvbHZlMih0aGlzLmNyZWRlbnRpYWxzKTtcbiAgICBjb25zdCBiYXNlSGVhZGVycyA9IHtcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMocmVzb2x2ZWRIZWFkZXJzKSxcbiAgICAgIC4uLm5vcm1hbGl6ZUhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKVxuICAgIH07XG4gICAgY29uc3QgcHJlcGFyZWRSZXF1ZXN0ID0gYXdhaXQgKChfYTIxID0gdGhpcy5wcmVwYXJlUmVjb25uZWN0VG9TdHJlYW1SZXF1ZXN0KSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5jYWxsKHRoaXMsIHtcbiAgICAgIGFwaTogdGhpcy5hcGksXG4gICAgICBpZDogb3B0aW9ucy5jaGF0SWQsXG4gICAgICBib2R5OiB7IC4uLnJlc29sdmVkQm9keSwgLi4ub3B0aW9ucy5ib2R5IH0sXG4gICAgICBoZWFkZXJzOiBiYXNlSGVhZGVycyxcbiAgICAgIGNyZWRlbnRpYWxzOiByZXNvbHZlZENyZWRlbnRpYWxzLFxuICAgICAgcmVxdWVzdE1ldGFkYXRhOiBvcHRpb25zLm1ldGFkYXRhXG4gICAgfSkpO1xuICAgIGNvbnN0IGFwaSA9IChfYiA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmFwaSkgIT0gbnVsbCA/IF9iIDogYCR7dGhpcy5hcGl9LyR7b3B0aW9ucy5jaGF0SWR9L3N0cmVhbWA7XG4gICAgY29uc3QgaGVhZGVycyA9IChwcmVwYXJlZFJlcXVlc3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXBhcmVkUmVxdWVzdC5oZWFkZXJzKSAhPT0gdm9pZCAwID8gbm9ybWFsaXplSGVhZGVycyhwcmVwYXJlZFJlcXVlc3QuaGVhZGVycykgOiBiYXNlSGVhZGVycztcbiAgICBjb25zdCBjcmVkZW50aWFscyA9IChfYyA9IHByZXBhcmVkUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogcHJlcGFyZWRSZXF1ZXN0LmNyZWRlbnRpYWxzKSAhPSBudWxsID8gX2MgOiByZXNvbHZlZENyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGZldGNoMiA9IChfZCA9IHRoaXMuZmV0Y2gpICE9IG51bGwgPyBfZCA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB3aXRoVXNlckFnZW50U3VmZml4MTEoXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIGBhaS1zZGsvJHtWRVJTSU9OfWAsXG4gICAgICAgIGdldFJ1bnRpbWVFbnZpcm9ubWVudFVzZXJBZ2VudDMoKVxuICAgICAgKSxcbiAgICAgIGNyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAoX2UgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfZSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Jlc3BvbnNlU3RyZWFtKHJlc3BvbnNlLmJvZHkpO1xuICB9XG59O1xuXG4vLyBzcmMvdWkvZGVmYXVsdC1jaGF0LXRyYW5zcG9ydC50c1xudmFyIERlZmF1bHRDaGF0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBIdHRwQ2hhdFRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHByb2Nlc3NSZXNwb25zZVN0cmVhbShzdHJlYW0pIHtcbiAgICByZXR1cm4gcGFyc2VKc29uRXZlbnRTdHJlYW0yKHtcbiAgICAgIHN0cmVhbSxcbiAgICAgIHNjaGVtYTogdWlNZXNzYWdlQ2h1bmtTY2hlbWFcbiAgICB9KS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoIWNodW5rLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRocm93IGNodW5rLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn07XG5cbi8vIHNyYy91aS9jaGF0LnRzXG52YXIgQWJzdHJhY3RDaGF0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuYzIsXG4gICAgaWQgPSBnZW5lcmF0ZUlkMigpLFxuICAgIHRyYW5zcG9ydCA9IG5ldyBEZWZhdWx0Q2hhdFRyYW5zcG9ydCgpLFxuICAgIG1lc3NhZ2VNZXRhZGF0YVNjaGVtYSxcbiAgICBkYXRhUGFydFNjaGVtYXMsXG4gICAgc3RhdGUsXG4gICAgb25FcnJvcixcbiAgICBvblRvb2xDYWxsLFxuICAgIG9uRmluaXNoLFxuICAgIG9uRGF0YSxcbiAgICBzZW5kQXV0b21hdGljYWxseVdoZW5cbiAgfSkge1xuICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgdGhpcy5qb2JFeGVjdXRvciA9IG5ldyBTZXJpYWxKb2JFeGVjdXRvcigpO1xuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgb3IgcmVwbGFjZXMgYSB1c2VyIG1lc3NhZ2UgdG8gdGhlIGNoYXQgbGlzdC4gVGhpcyB0cmlnZ2VycyB0aGUgQVBJIGNhbGwgdG8gZmV0Y2hcbiAgICAgKiB0aGUgYXNzaXN0YW50J3MgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBJZiBhIG1lc3NhZ2VJZCBpcyBwcm92aWRlZCwgdGhlIG1lc3NhZ2Ugd2lsbCBiZSByZXBsYWNlZC5cbiAgICAgKi9cbiAgICB0aGlzLnNlbmRNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcbiAgICAgIHZhciBfYTIxLCBfYiwgX2MsIF9kO1xuICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuICAgICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICB0cmlnZ2VyOiBcInN1Ym1pdC1tZXNzYWdlXCIsXG4gICAgICAgICAgbWVzc2FnZUlkOiAoX2EyMSA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIxLmlkLFxuICAgICAgICAgIC4uLm9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB1aU1lc3NhZ2U7XG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gbWVzc2FnZSB8fCBcImZpbGVzXCIgaW4gbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWxlUGFydHMgPSBBcnJheS5pc0FycmF5KG1lc3NhZ2UuZmlsZXMpID8gbWVzc2FnZS5maWxlcyA6IGF3YWl0IGNvbnZlcnRGaWxlTGlzdFRvRmlsZVVJUGFydHMobWVzc2FnZS5maWxlcyk7XG4gICAgICAgIHVpTWVzc2FnZSA9IHtcbiAgICAgICAgICBwYXJ0czogW1xuICAgICAgICAgICAgLi4uZmlsZVBhcnRzLFxuICAgICAgICAgICAgLi4uXCJ0ZXh0XCIgaW4gbWVzc2FnZSAmJiBtZXNzYWdlLnRleHQgIT0gbnVsbCA/IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLnRleHQgfV0gOiBbXVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVpTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5tZXNzYWdlSWQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlSW5kZXggPSB0aGlzLnN0YXRlLm1lc3NhZ2VzLmZpbmRJbmRleChcbiAgICAgICAgICAobSkgPT4gbS5pZCA9PT0gbWVzc2FnZS5tZXNzYWdlSWRcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKG1lc3NhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1lc3NhZ2Ugd2l0aCBpZCAke21lc3NhZ2UubWVzc2FnZUlkfSBub3QgZm91bmRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tZXNzYWdlc1ttZXNzYWdlSW5kZXhdLnJvbGUgIT09IFwidXNlclwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYG1lc3NhZ2Ugd2l0aCBpZCAke21lc3NhZ2UubWVzc2FnZUlkfSBpcyBub3QgYSB1c2VyIG1lc3NhZ2VgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcy5zbGljZSgwLCBtZXNzYWdlSW5kZXggKyAxKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5yZXBsYWNlTWVzc2FnZShtZXNzYWdlSW5kZXgsIHtcbiAgICAgICAgICAuLi51aU1lc3NhZ2UsXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UubWVzc2FnZUlkLFxuICAgICAgICAgIHJvbGU6IChfYiA9IHVpTWVzc2FnZS5yb2xlKSAhPSBudWxsID8gX2IgOiBcInVzZXJcIixcbiAgICAgICAgICBtZXRhZGF0YTogbWVzc2FnZS5tZXRhZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhdGUucHVzaE1lc3NhZ2Uoe1xuICAgICAgICAgIC4uLnVpTWVzc2FnZSxcbiAgICAgICAgICBpZDogKF9jID0gdWlNZXNzYWdlLmlkKSAhPSBudWxsID8gX2MgOiB0aGlzLmdlbmVyYXRlSWQoKSxcbiAgICAgICAgICByb2xlOiAoX2QgPSB1aU1lc3NhZ2Uucm9sZSkgIT0gbnVsbCA/IF9kIDogXCJ1c2VyXCIsXG4gICAgICAgICAgbWV0YWRhdGE6IG1lc3NhZ2UubWV0YWRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICBtZXNzYWdlSWQ6IG1lc3NhZ2UubWVzc2FnZUlkLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGUgdGhlIGFzc2lzdGFudCBtZXNzYWdlIHdpdGggdGhlIHByb3ZpZGVkIG1lc3NhZ2UgaWQuXG4gICAgICogSWYgbm8gbWVzc2FnZSBpZCBpcyBwcm92aWRlZCwgdGhlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2Ugd2lsbCBiZSByZWdlbmVyYXRlZC5cbiAgICAgKi9cbiAgICB0aGlzLnJlZ2VuZXJhdGUgPSBhc3luYyAoe1xuICAgICAgbWVzc2FnZUlkLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZUluZGV4ID0gbWVzc2FnZUlkID09IG51bGwgPyB0aGlzLnN0YXRlLm1lc3NhZ2VzLmxlbmd0aCAtIDEgOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLmZpbmRJbmRleCgobWVzc2FnZSkgPT4gbWVzc2FnZS5pZCA9PT0gbWVzc2FnZUlkKTtcbiAgICAgIGlmIChtZXNzYWdlSW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbWVzc2FnZSAke21lc3NhZ2VJZH0gbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcy5zbGljZShcbiAgICAgICAgMCxcbiAgICAgICAgLy8gaWYgdGhlIG1lc3NhZ2UgaXMgYSB1c2VyIG1lc3NhZ2UsIHdlIG5lZWQgdG8gaW5jbHVkZSBpdCBpbiB0aGUgcmVxdWVzdDpcbiAgICAgICAgdGhpcy5tZXNzYWdlc1ttZXNzYWdlSW5kZXhdLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgPyBtZXNzYWdlSW5kZXggOiBtZXNzYWdlSW5kZXggKyAxXG4gICAgICApO1xuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgIHRyaWdnZXI6IFwicmVnZW5lcmF0ZS1tZXNzYWdlXCIsXG4gICAgICAgIG1lc3NhZ2VJZCxcbiAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIHJlc3VtZSBhbiBvbmdvaW5nIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgKi9cbiAgICB0aGlzLnJlc3VtZVN0cmVhbSA9IGFzeW5jIChvcHRpb25zID0ge30pID0+IHtcbiAgICAgIGF3YWl0IHRoaXMubWFrZVJlcXVlc3QoeyB0cmlnZ2VyOiBcInJlc3VtZS1zdHJlYW1cIiwgLi4ub3B0aW9ucyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBlcnJvciBzdGF0ZSBhbmQgc2V0IHRoZSBzdGF0dXMgdG8gcmVhZHkgaWYgdGhlIGNoYXQgaXMgaW4gYW4gZXJyb3Igc3RhdGUuXG4gICAgICovXG4gICAgdGhpcy5jbGVhckVycm9yID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5lcnJvciA9IHZvaWQgMDtcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwicmVhZHlcIiB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkVG9vbEFwcHJvdmFsUmVzcG9uc2UgPSBhc3luYyAoe1xuICAgICAgaWQsXG4gICAgICBhcHByb3ZlZCxcbiAgICAgIHJlYXNvblxuICAgIH0pID0+IHRoaXMuam9iRXhlY3V0b3IucnVuKGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5zdGF0ZS5tZXNzYWdlcztcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gICAgICBjb25zdCB1cGRhdGVQYXJ0ID0gKHBhcnQpID0+IGlzVG9vbFVJUGFydChwYXJ0KSAmJiBwYXJ0LnN0YXRlID09PSBcImFwcHJvdmFsLXJlcXVlc3RlZFwiICYmIHBhcnQuYXBwcm92YWwuaWQgPT09IGlkID8ge1xuICAgICAgICAuLi5wYXJ0LFxuICAgICAgICBzdGF0ZTogXCJhcHByb3ZhbC1yZXNwb25kZWRcIixcbiAgICAgICAgYXBwcm92YWw6IHsgaWQsIGFwcHJvdmVkLCByZWFzb24gfVxuICAgICAgfSA6IHBhcnQ7XG4gICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKG1lc3NhZ2VzLmxlbmd0aCAtIDEsIHtcbiAgICAgICAgLi4ubGFzdE1lc3NhZ2UsXG4gICAgICAgIHBhcnRzOiBsYXN0TWVzc2FnZS5wYXJ0cy5tYXAodXBkYXRlUGFydClcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzID0gdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzdHJlYW1pbmdcIiAmJiB0aGlzLnN0YXR1cyAhPT0gXCJzdWJtaXR0ZWRcIiAmJiB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbikge1xuICAgICAgICB0aGlzLnNob3VsZFNlbmRBdXRvbWF0aWNhbGx5KCkudGhlbigoc2hvdWxkU2VuZCkgPT4ge1xuICAgICAgICAgIHZhciBfYTIxO1xuICAgICAgICAgIGlmIChzaG91bGRTZW5kKSB7XG4gICAgICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IChfYTIxID0gdGhpcy5sYXN0TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hZGRUb29sT3V0cHV0ID0gYXN5bmMgKHtcbiAgICAgIHN0YXRlID0gXCJvdXRwdXQtYXZhaWxhYmxlXCIsXG4gICAgICB0b29sOiB0b29sMixcbiAgICAgIHRvb2xDYWxsSWQsXG4gICAgICBvdXRwdXQsXG4gICAgICBlcnJvclRleHRcbiAgICB9KSA9PiB0aGlzLmpvYkV4ZWN1dG9yLnJ1bihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtZXNzYWdlcyA9IHRoaXMuc3RhdGUubWVzc2FnZXM7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgY29uc3QgdXBkYXRlUGFydCA9IChwYXJ0KSA9PiBpc1Rvb2xVSVBhcnQocGFydCkgJiYgcGFydC50b29sQ2FsbElkID09PSB0b29sQ2FsbElkID8geyAuLi5wYXJ0LCBzdGF0ZSwgb3V0cHV0LCBlcnJvclRleHQgfSA6IHBhcnQ7XG4gICAgICB0aGlzLnN0YXRlLnJlcGxhY2VNZXNzYWdlKG1lc3NhZ2VzLmxlbmd0aCAtIDEsIHtcbiAgICAgICAgLi4ubGFzdE1lc3NhZ2UsXG4gICAgICAgIHBhcnRzOiBsYXN0TWVzc2FnZS5wYXJ0cy5tYXAodXBkYXRlUGFydClcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMuYWN0aXZlUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzID0gdGhpcy5hY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlLnBhcnRzLm1hcCh1cGRhdGVQYXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzdHJlYW1pbmdcIiAmJiB0aGlzLnN0YXR1cyAhPT0gXCJzdWJtaXR0ZWRcIiAmJiB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbikge1xuICAgICAgICB0aGlzLnNob3VsZFNlbmRBdXRvbWF0aWNhbGx5KCkudGhlbigoc2hvdWxkU2VuZCkgPT4ge1xuICAgICAgICAgIHZhciBfYTIxO1xuICAgICAgICAgIGlmIChzaG91bGRTZW5kKSB7XG4gICAgICAgICAgICB0aGlzLm1ha2VSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgdHJpZ2dlcjogXCJzdWJtaXQtbWVzc2FnZVwiLFxuICAgICAgICAgICAgICBtZXNzYWdlSWQ6IChfYTIxID0gdGhpcy5sYXN0TWVzc2FnZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMjEuaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBhZGRUb29sT3V0cHV0ICovXG4gICAgdGhpcy5hZGRUb29sUmVzdWx0ID0gdGhpcy5hZGRUb29sT3V0cHV0O1xuICAgIC8qKlxuICAgICAqIEFib3J0IHRoZSBjdXJyZW50IHJlcXVlc3QgaW1tZWRpYXRlbHksIGtlZXAgdGhlIGdlbmVyYXRlZCB0b2tlbnMgaWYgYW55LlxuICAgICAqL1xuICAgIHRoaXMuc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBfYTIxO1xuICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInN0cmVhbWluZ1wiICYmIHRoaXMuc3RhdHVzICE9PSBcInN1Ym1pdHRlZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoKF9hMjEgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5hYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBnZW5lcmF0ZUlkMjtcbiAgICB0aGlzLm1lc3NhZ2VNZXRhZGF0YVNjaGVtYSA9IG1lc3NhZ2VNZXRhZGF0YVNjaGVtYTtcbiAgICB0aGlzLmRhdGFQYXJ0U2NoZW1hcyA9IGRhdGFQYXJ0U2NoZW1hcztcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5vbkVycm9yID0gb25FcnJvcjtcbiAgICB0aGlzLm9uVG9vbENhbGwgPSBvblRvb2xDYWxsO1xuICAgIHRoaXMub25GaW5pc2ggPSBvbkZpbmlzaDtcbiAgICB0aGlzLm9uRGF0YSA9IG9uRGF0YTtcbiAgICB0aGlzLnNlbmRBdXRvbWF0aWNhbGx5V2hlbiA9IHNlbmRBdXRvbWF0aWNhbGx5V2hlbjtcbiAgfVxuICAvKipcbiAgICogSG9vayBzdGF0dXM6XG4gICAqXG4gICAqIC0gYHN1Ym1pdHRlZGA6IFRoZSBtZXNzYWdlIGhhcyBiZWVuIHNlbnQgdG8gdGhlIEFQSSBhbmQgd2UncmUgYXdhaXRpbmcgdGhlIHN0YXJ0IG9mIHRoZSByZXNwb25zZSBzdHJlYW0uXG4gICAqIC0gYHN0cmVhbWluZ2A6IFRoZSByZXNwb25zZSBpcyBhY3RpdmVseSBzdHJlYW1pbmcgaW4gZnJvbSB0aGUgQVBJLCByZWNlaXZpbmcgY2h1bmtzIG9mIGRhdGEuXG4gICAqIC0gYHJlYWR5YDogVGhlIGZ1bGwgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQgYW5kIHByb2Nlc3NlZDsgYSBuZXcgdXNlciBtZXNzYWdlIGNhbiBiZSBzdWJtaXR0ZWQuXG4gICAqIC0gYGVycm9yYDogQW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBBUEkgcmVxdWVzdCwgcHJldmVudGluZyBzdWNjZXNzZnVsIGNvbXBsZXRpb24uXG4gICAqL1xuICBnZXQgc3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnN0YXR1cztcbiAgfVxuICBzZXRTdGF0dXMoe1xuICAgIHN0YXR1cyxcbiAgICBlcnJvclxuICB9KSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzID09PSBzdGF0dXMpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5zdGF0ZS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5zdGF0ZS5lcnJvciA9IGVycm9yO1xuICB9XG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5lcnJvcjtcbiAgfVxuICBnZXQgbWVzc2FnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUubWVzc2FnZXM7XG4gIH1cbiAgZ2V0IGxhc3RNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm1lc3NhZ2VzW3RoaXMuc3RhdGUubWVzc2FnZXMubGVuZ3RoIC0gMV07XG4gIH1cbiAgc2V0IG1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgdGhpcy5zdGF0ZS5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICB9XG4gIGFzeW5jIHNob3VsZFNlbmRBdXRvbWF0aWNhbGx5KCkge1xuICAgIGlmICghdGhpcy5zZW5kQXV0b21hdGljYWxseVdoZW4pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zZW5kQXV0b21hdGljYWxseVdoZW4oe1xuICAgICAgbWVzc2FnZXM6IHRoaXMuc3RhdGUubWVzc2FnZXNcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gcmVzdWx0KSB7XG4gICAgICByZXR1cm4gYXdhaXQgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIG1ha2VSZXF1ZXN0KHtcbiAgICB0cmlnZ2VyLFxuICAgIG1ldGFkYXRhLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keSxcbiAgICBtZXNzYWdlSWRcbiAgfSkge1xuICAgIHZhciBfYTIxLCBfYiwgX2M7XG4gICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwic3VibWl0dGVkXCIsIGVycm9yOiB2b2lkIDAgfSk7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB0aGlzLmxhc3RNZXNzYWdlO1xuICAgIGxldCBpc0Fib3J0ID0gZmFsc2U7XG4gICAgbGV0IGlzRGlzY29ubmVjdCA9IGZhbHNlO1xuICAgIGxldCBpc0Vycm9yID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGFjdGl2ZVJlc3BvbnNlID0ge1xuICAgICAgICBzdGF0ZTogY3JlYXRlU3RyZWFtaW5nVUlNZXNzYWdlU3RhdGUoe1xuICAgICAgICAgIGxhc3RNZXNzYWdlOiB0aGlzLnN0YXRlLnNuYXBzaG90KGxhc3RNZXNzYWdlKSxcbiAgICAgICAgICBtZXNzYWdlSWQ6IHRoaXMuZ2VuZXJhdGVJZCgpXG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydENvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXIoKVxuICAgICAgfTtcbiAgICAgIGFjdGl2ZVJlc3BvbnNlLmFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsICgpID0+IHtcbiAgICAgICAgaXNBYm9ydCA9IHRydWU7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuYWN0aXZlUmVzcG9uc2UgPSBhY3RpdmVSZXNwb25zZTtcbiAgICAgIGxldCBzdHJlYW07XG4gICAgICBpZiAodHJpZ2dlciA9PT0gXCJyZXN1bWUtc3RyZWFtXCIpIHtcbiAgICAgICAgY29uc3QgcmVjb25uZWN0ID0gYXdhaXQgdGhpcy50cmFuc3BvcnQucmVjb25uZWN0VG9TdHJlYW0oe1xuICAgICAgICAgIGNoYXRJZDogdGhpcy5pZCxcbiAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgIGJvZHlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyZWNvbm5lY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbSA9IHJlY29ubmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cmVhbSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRNZXNzYWdlcyh7XG4gICAgICAgICAgY2hhdElkOiB0aGlzLmlkLFxuICAgICAgICAgIG1lc3NhZ2VzOiB0aGlzLnN0YXRlLm1lc3NhZ2VzLFxuICAgICAgICAgIGFib3J0U2lnbmFsOiBhY3RpdmVSZXNwb25zZS5hYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgYm9keSxcbiAgICAgICAgICB0cmlnZ2VyLFxuICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ1blVwZGF0ZU1lc3NhZ2VKb2IgPSAoam9iKSA9PiAoXG4gICAgICAgIC8vIHNlcmlhbGl6ZSB0aGUgam9iIGV4ZWN1dGlvbiB0byBhdm9pZCByYWNlIGNvbmRpdGlvbnM6XG4gICAgICAgIHRoaXMuam9iRXhlY3V0b3IucnVuKFxuICAgICAgICAgICgpID0+IGpvYih7XG4gICAgICAgICAgICBzdGF0ZTogYWN0aXZlUmVzcG9uc2Uuc3RhdGUsXG4gICAgICAgICAgICB3cml0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyMjtcbiAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwic3RyZWFtaW5nXCIgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VMYXN0TWVzc2FnZSA9IGFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UuaWQgPT09ICgoX2EyMiA9IHRoaXMubGFzdE1lc3NhZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTIyLmlkKTtcbiAgICAgICAgICAgICAgaWYgKHJlcGxhY2VMYXN0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVwbGFjZU1lc3NhZ2UoXG4gICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1lc3NhZ2VzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgICBhY3RpdmVSZXNwb25zZS5zdGF0ZS5tZXNzYWdlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnB1c2hNZXNzYWdlKGFjdGl2ZVJlc3BvbnNlLnN0YXRlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGF3YWl0IGNvbnN1bWVTdHJlYW0oe1xuICAgICAgICBzdHJlYW06IHByb2Nlc3NVSU1lc3NhZ2VTdHJlYW0oe1xuICAgICAgICAgIHN0cmVhbSxcbiAgICAgICAgICBvblRvb2xDYWxsOiB0aGlzLm9uVG9vbENhbGwsXG4gICAgICAgICAgb25EYXRhOiB0aGlzLm9uRGF0YSxcbiAgICAgICAgICBtZXNzYWdlTWV0YWRhdGFTY2hlbWE6IHRoaXMubWVzc2FnZU1ldGFkYXRhU2NoZW1hLFxuICAgICAgICAgIGRhdGFQYXJ0U2NoZW1hczogdGhpcy5kYXRhUGFydFNjaGVtYXMsXG4gICAgICAgICAgcnVuVXBkYXRlTWVzc2FnZUpvYixcbiAgICAgICAgICBvbkVycm9yOiAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoaXNBYm9ydCB8fCBlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgICAgaXNBYm9ydCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKHsgc3RhdHVzOiBcInJlYWR5XCIgfSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaXNFcnJvciA9IHRydWU7XG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIChlcnIubWVzc2FnZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKFwiZmV0Y2hcIikgfHwgZXJyLm1lc3NhZ2UudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcIm5ldHdvcmtcIikpKSB7XG4gICAgICAgIGlzRGlzY29ubmVjdCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRoaXMub25FcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0dXMoeyBzdGF0dXM6IFwiZXJyb3JcIiwgZXJyb3I6IGVyciB9KTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgKF9iID0gdGhpcy5vbkZpbmlzaCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwodGhpcywge1xuICAgICAgICAgIG1lc3NhZ2U6IHRoaXMuYWN0aXZlUmVzcG9uc2Uuc3RhdGUubWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlczogdGhpcy5zdGF0ZS5tZXNzYWdlcyxcbiAgICAgICAgICBpc0Fib3J0LFxuICAgICAgICAgIGlzRGlzY29ubmVjdCxcbiAgICAgICAgICBpc0Vycm9yLFxuICAgICAgICAgIGZpbmlzaFJlYXNvbjogKF9hMjEgPSB0aGlzLmFjdGl2ZVJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2EyMS5zdGF0ZS5maW5pc2hSZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmVSZXNwb25zZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKCFpc0Vycm9yICYmIGF3YWl0IHRoaXMuc2hvdWxkU2VuZEF1dG9tYXRpY2FsbHkoKSkge1xuICAgICAgYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh7XG4gICAgICAgIHRyaWdnZXI6IFwic3VibWl0LW1lc3NhZ2VcIixcbiAgICAgICAgbWVzc2FnZUlkOiAoX2MgPSB0aGlzLmxhc3RNZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaWQsXG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy91aS9kaXJlY3QtY2hhdC10cmFuc3BvcnQudHNcbnZhciBEaXJlY3RDaGF0VHJhbnNwb3J0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYWdlbnQsXG4gICAgb3B0aW9ucyxcbiAgICAuLi51aU1lc3NhZ2VTdHJlYW1PcHRpb25zXG4gIH0pIHtcbiAgICB0aGlzLmFnZW50ID0gYWdlbnQ7XG4gICAgdGhpcy5hZ2VudE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMudWlNZXNzYWdlU3RyZWFtT3B0aW9ucyA9IHVpTWVzc2FnZVN0cmVhbU9wdGlvbnM7XG4gIH1cbiAgYXN5bmMgc2VuZE1lc3NhZ2VzKHtcbiAgICBtZXNzYWdlcyxcbiAgICBhYm9ydFNpZ25hbFxuICB9KSB7XG4gICAgY29uc3QgdmFsaWRhdGVkTWVzc2FnZXMgPSBhd2FpdCB2YWxpZGF0ZVVJTWVzc2FnZXMoe1xuICAgICAgbWVzc2FnZXMsXG4gICAgICB0b29sczogdGhpcy5hZ2VudC50b29sc1xuICAgIH0pO1xuICAgIGNvbnN0IG1vZGVsTWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9Nb2RlbE1lc3NhZ2VzKHZhbGlkYXRlZE1lc3NhZ2VzLCB7XG4gICAgICB0b29sczogdGhpcy5hZ2VudC50b29sc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuYWdlbnQuc3RyZWFtKHtcbiAgICAgIHByb21wdDogbW9kZWxNZXNzYWdlcyxcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgLi4udGhpcy5hZ2VudE9wdGlvbnMgIT09IHZvaWQgMCA/IHsgb3B0aW9uczogdGhpcy5hZ2VudE9wdGlvbnMgfSA6IHt9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC50b1VJTWVzc2FnZVN0cmVhbSh0aGlzLnVpTWVzc2FnZVN0cmVhbU9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBEaXJlY3QgdHJhbnNwb3J0IGRvZXMgbm90IHN1cHBvcnQgcmVjb25uZWN0aW9uIHNpbmNlIHRoZXJlIGlzIG5vXG4gICAqIHBlcnNpc3RlbnQgc2VydmVyLXNpZGUgc3RyZWFtIHRvIHJlY29ubmVjdCB0by5cbiAgICpcbiAgICogQHJldHVybnMgQWx3YXlzIHJldHVybnMgYG51bGxgXG4gICAqL1xuICBhc3luYyByZWNvbm5lY3RUb1N0cmVhbShfb3B0aW9ucykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vLyBzcmMvdWkvbGFzdC1hc3Npc3RhbnQtbWVzc2FnZS1pcy1jb21wbGV0ZS13aXRoLWFwcHJvdmFsLXJlc3BvbnNlcy50c1xuZnVuY3Rpb24gbGFzdEFzc2lzdGFudE1lc3NhZ2VJc0NvbXBsZXRlV2l0aEFwcHJvdmFsUmVzcG9uc2VzKHtcbiAgbWVzc2FnZXNcbn0pIHtcbiAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoIW1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0U3RlcFN0YXJ0SW5kZXggPSBtZXNzYWdlLnBhcnRzLnJlZHVjZSgobGFzdEluZGV4LCBwYXJ0LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiID8gaW5kZXggOiBsYXN0SW5kZXg7XG4gIH0sIC0xKTtcbiAgY29uc3QgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnBhcnRzLnNsaWNlKGxhc3RTdGVwU3RhcnRJbmRleCArIDEpLmZpbHRlcihpc1Rvb2xVSVBhcnQpLmZpbHRlcigocGFydCkgPT4gIXBhcnQucHJvdmlkZXJFeGVjdXRlZCk7XG4gIHJldHVybiAoXG4gICAgLy8gaGFzIGF0IGxlYXN0IG9uZSB0b29sIGFwcHJvdmFsIHJlc3BvbnNlXG4gICAgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnN0YXRlID09PSBcImFwcHJvdmFsLXJlc3BvbmRlZFwiKS5sZW5ndGggPiAwICYmIC8vIGFsbCB0b29sIGFwcHJvdmFscyBtdXN0IGhhdmUgYSByZXNwb25zZVxuICAgIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmV2ZXJ5KFxuICAgICAgKHBhcnQpID0+IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWF2YWlsYWJsZVwiIHx8IHBhcnQuc3RhdGUgPT09IFwib3V0cHV0LWVycm9yXCIgfHwgcGFydC5zdGF0ZSA9PT0gXCJhcHByb3ZhbC1yZXNwb25kZWRcIlxuICAgIClcbiAgKTtcbn1cblxuLy8gc3JjL3VpL2xhc3QtYXNzaXN0YW50LW1lc3NhZ2UtaXMtY29tcGxldGUtd2l0aC10b29sLWNhbGxzLnRzXG5mdW5jdGlvbiBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoVG9vbENhbGxzKHtcbiAgbWVzc2FnZXNcbn0pIHtcbiAgY29uc3QgbWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICBpZiAoIW1lc3NhZ2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG1lc3NhZ2Uucm9sZSAhPT0gXCJhc3Npc3RhbnRcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBsYXN0U3RlcFN0YXJ0SW5kZXggPSBtZXNzYWdlLnBhcnRzLnJlZHVjZSgobGFzdEluZGV4LCBwYXJ0LCBpbmRleCkgPT4ge1xuICAgIHJldHVybiBwYXJ0LnR5cGUgPT09IFwic3RlcC1zdGFydFwiID8gaW5kZXggOiBsYXN0SW5kZXg7XG4gIH0sIC0xKTtcbiAgY29uc3QgbGFzdFN0ZXBUb29sSW52b2NhdGlvbnMgPSBtZXNzYWdlLnBhcnRzLnNsaWNlKGxhc3RTdGVwU3RhcnRJbmRleCArIDEpLmZpbHRlcihpc1Rvb2xVSVBhcnQpLmZpbHRlcigocGFydCkgPT4gIXBhcnQucHJvdmlkZXJFeGVjdXRlZCk7XG4gIHJldHVybiBsYXN0U3RlcFRvb2xJbnZvY2F0aW9ucy5sZW5ndGggPiAwICYmIGxhc3RTdGVwVG9vbEludm9jYXRpb25zLmV2ZXJ5KFxuICAgIChwYXJ0KSA9PiBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1hdmFpbGFibGVcIiB8fCBwYXJ0LnN0YXRlID09PSBcIm91dHB1dC1lcnJvclwiXG4gICk7XG59XG5cbi8vIHNyYy91aS90cmFuc2Zvcm0tdGV4dC10by11aS1tZXNzYWdlLXN0cmVhbS50c1xuZnVuY3Rpb24gdHJhbnNmb3JtVGV4dFRvVWlNZXNzYWdlU3RyZWFtKHtcbiAgc3RyZWFtXG59KSB7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goXG4gICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwic3RhcnRcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJzdGFydC1zdGVwXCIgfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1zdGFydFwiLCBpZDogXCJ0ZXh0LTFcIiB9KTtcbiAgICAgIH0sXG4gICAgICBhc3luYyB0cmFuc2Zvcm0ocGFydCwgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcInRleHQtZGVsdGFcIiwgaWQ6IFwidGV4dC0xXCIsIGRlbHRhOiBwYXJ0IH0pO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJ0ZXh0LWVuZFwiLCBpZDogXCJ0ZXh0LTFcIiB9KTtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJmaW5pc2gtc3RlcFwiIH0pO1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyB0eXBlOiBcImZpbmlzaFwiIH0pO1xuICAgICAgfVxuICAgIH0pXG4gICk7XG59XG5cbi8vIHNyYy91aS90ZXh0LXN0cmVhbS1jaGF0LXRyYW5zcG9ydC50c1xudmFyIFRleHRTdHJlYW1DaGF0VHJhbnNwb3J0ID0gY2xhc3MgZXh0ZW5kcyBIdHRwQ2hhdFRyYW5zcG9ydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG4gIHByb2Nlc3NSZXNwb25zZVN0cmVhbShzdHJlYW0pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtVGV4dFRvVWlNZXNzYWdlU3RyZWFtKHtcbiAgICAgIHN0cmVhbTogc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgQUlTREtFcnJvcjIxIGFzIEFJU0RLRXJyb3IsXG4gIEFQSUNhbGxFcnJvcixcbiAgQWJzdHJhY3RDaGF0LFxuICBEZWZhdWx0Q2hhdFRyYW5zcG9ydCxcbiAgRGVmYXVsdEdlbmVyYXRlZEZpbGUsXG4gIERpcmVjdENoYXRUcmFuc3BvcnQsXG4gIERvd25sb2FkRXJyb3IsXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIFRvb2xMb29wQWdlbnQgYXMgRXhwZXJpbWVudGFsX0FnZW50LFxuICBIdHRwQ2hhdFRyYW5zcG9ydCxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IsXG4gIEludmFsaWREYXRhQ29udGVudEVycm9yLFxuICBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRTdHJlYW1QYXJ0RXJyb3IsXG4gIEludmFsaWRUb29sQXBwcm92YWxFcnJvcixcbiAgSW52YWxpZFRvb2xJbnB1dEVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgSnNvblRvU3NlVHJhbnNmb3JtU3RyZWFtLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IsXG4gIE1pc3NpbmdUb29sUmVzdWx0c0Vycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9JbWFnZUdlbmVyYXRlZEVycm9yLFxuICBOb09iamVjdEdlbmVyYXRlZEVycm9yLFxuICBOb091dHB1dEdlbmVyYXRlZEVycm9yLFxuICBOb1NwZWVjaEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBOb1N1Y2hQcm92aWRlckVycm9yLFxuICBOb1N1Y2hUb29sRXJyb3IsXG4gIE5vVHJhbnNjcmlwdEdlbmVyYXRlZEVycm9yLFxuICBOb1ZpZGVvR2VuZXJhdGVkRXJyb3IsXG4gIG91dHB1dF9leHBvcnRzIGFzIE91dHB1dCxcbiAgUmV0cnlFcnJvcixcbiAgU2VyaWFsSm9iRXhlY3V0b3IsXG4gIFRleHRTdHJlYW1DaGF0VHJhbnNwb3J0LFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUb29sQ2FsbE5vdEZvdW5kRm9yQXBwcm92YWxFcnJvcixcbiAgVG9vbENhbGxSZXBhaXJFcnJvcixcbiAgVG9vbExvb3BBZ2VudCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVUlNZXNzYWdlU3RyZWFtRXJyb3IsXG4gIFVJX01FU1NBR0VfU1RSRUFNX0hFQURFUlMsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBVbnN1cHBvcnRlZE1vZGVsVmVyc2lvbkVycm9yLFxuICBhZGRUb29sSW5wdXRFeGFtcGxlc01pZGRsZXdhcmUsXG4gIGFzU2NoZW1hNSBhcyBhc1NjaGVtYSxcbiAgYXNzaXN0YW50TW9kZWxNZXNzYWdlU2NoZW1hLFxuICBjYWxsQ29tcGxldGlvbkFwaSxcbiAgY29uc3VtZVN0cmVhbSxcbiAgY29udmVydEZpbGVMaXN0VG9GaWxlVUlQYXJ0cyxcbiAgY29udmVydFRvTW9kZWxNZXNzYWdlcyxcbiAgY29zaW5lU2ltaWxhcml0eSxcbiAgY3JlYXRlQWdlbnRVSVN0cmVhbSxcbiAgY3JlYXRlQWdlbnRVSVN0cmVhbVJlc3BvbnNlLFxuICBjcmVhdGVHYXRld2F5LFxuICBjcmVhdGVJZEdlbmVyYXRvcjUgYXMgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZVByb3ZpZGVyUmVnaXN0cnksXG4gIGNyZWF0ZVRleHRTdHJlYW1SZXNwb25zZSxcbiAgY3JlYXRlVUlNZXNzYWdlU3RyZWFtLFxuICBjcmVhdGVVSU1lc3NhZ2VTdHJlYW1SZXNwb25zZSxcbiAgY3VzdG9tUHJvdmlkZXIsXG4gIGRlZmF1bHRFbWJlZGRpbmdTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGRlZmF1bHRTZXR0aW5nc01pZGRsZXdhcmUsXG4gIGR5bmFtaWNUb29sLFxuICBlbWJlZCxcbiAgZW1iZWRNYW55LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVJbWFnZSxcbiAgZ2VuZXJhdGVTcGVlY2ggYXMgZXhwZXJpbWVudGFsX2dlbmVyYXRlU3BlZWNoLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVWaWRlbyxcbiAgdHJhbnNjcmliZSBhcyBleHBlcmltZW50YWxfdHJhbnNjcmliZSxcbiAgZXh0cmFjdEpzb25NaWRkbGV3YXJlLFxuICBleHRyYWN0UmVhc29uaW5nTWlkZGxld2FyZSxcbiAgZ2F0ZXdheTIgYXMgZ2F0ZXdheSxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2VuZXJhdGVJbWFnZSxcbiAgZ2VuZXJhdGVPYmplY3QsXG4gIGdlbmVyYXRlVGV4dCxcbiAgZ2V0U3RhdGljVG9vbE5hbWUsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgZ2V0VG9vbE5hbWUsXG4gIGdldFRvb2xPckR5bmFtaWNUb29sTmFtZSxcbiAgaGFzVG9vbENhbGwsXG4gIGlzRGF0YVVJUGFydCxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBpc0ZpbGVVSVBhcnQsXG4gIGlzUmVhc29uaW5nVUlQYXJ0LFxuICBpc1N0YXRpY1Rvb2xVSVBhcnQsXG4gIGlzVGV4dFVJUGFydCxcbiAgaXNUb29sT3JEeW5hbWljVG9vbFVJUGFydCxcbiAgaXNUb29sVUlQYXJ0LFxuICBqc29uU2NoZW1hLFxuICBsYXN0QXNzaXN0YW50TWVzc2FnZUlzQ29tcGxldGVXaXRoQXBwcm92YWxSZXNwb25zZXMsXG4gIGxhc3RBc3Npc3RhbnRNZXNzYWdlSXNDb21wbGV0ZVdpdGhUb29sQ2FsbHMsXG4gIG1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgcGFyc2VKc29uRXZlbnRTdHJlYW0zIGFzIHBhcnNlSnNvbkV2ZW50U3RyZWFtLFxuICBwYXJzZVBhcnRpYWxKc29uLFxuICBwaXBlQWdlbnRVSVN0cmVhbVRvUmVzcG9uc2UsXG4gIHBpcGVUZXh0U3RyZWFtVG9SZXNwb25zZSxcbiAgcGlwZVVJTWVzc2FnZVN0cmVhbVRvUmVzcG9uc2UsXG4gIHBydW5lTWVzc2FnZXMsXG4gIHJlYWRVSU1lc3NhZ2VTdHJlYW0sXG4gIHJlcmFuayxcbiAgc2FmZVZhbGlkYXRlVUlNZXNzYWdlcyxcbiAgc2ltdWxhdGVSZWFkYWJsZVN0cmVhbSxcbiAgc2ltdWxhdGVTdHJlYW1pbmdNaWRkbGV3YXJlLFxuICBzbW9vdGhTdHJlYW0sXG4gIHN0ZXBDb3VudElzLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN5c3RlbU1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdG9vbCxcbiAgdG9vbE1vZGVsTWVzc2FnZVNjaGVtYSxcbiAgdWlNZXNzYWdlQ2h1bmtTY2hlbWEsXG4gIHVzZXJNb2RlbE1lc3NhZ2VTY2hlbWEsXG4gIHZhbGlkYXRlVUlNZXNzYWdlcyxcbiAgd3JhcEVtYmVkZGluZ01vZGVsLFxuICB3cmFwSW1hZ2VNb2RlbCxcbiAgd3JhcExhbmd1YWdlTW9kZWwsXG4gIHdyYXBQcm92aWRlcixcbiAgem9kU2NoZW1hMyBhcyB6b2RTY2hlbWFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;